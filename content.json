{"meta":{"title":"LuKing","subtitle":"","description":"最美的不是下雨天，是曾与你躲过雨的屋檐","author":"LuKing-Xun","url":"https://1314xulujin.github.io","root":"/blog/"},"pages":[{"title":"","date":"2022-10-15T01:06:16.314Z","updated":"2022-01-19T01:52:21.434Z","comments":true,"path":"html/字节飞书问答题.html","permalink":"https://1314xulujin.github.io/html/%E5%AD%97%E8%8A%82%E9%A3%9E%E4%B9%A6%E9%97%AE%E7%AD%94%E9%A2%98.html","excerpt":"","text":"Document // 一、 // var arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] // 1. // arr.splice(2, 1) // 2. // let arr1 = arr.filter((item, index) => { // return index !== 2 // }) // 3. // let arr1 = []; // arr.forEach((item, index) => { // if (index !== 2) { // arr1.push(item) // } // }) // 二、 // let reg = /^[0-9]{3}-[0-9]{8}$|^[0-9]{3}-10010$|^[0-9]{3}-110$/ // console.log(reg.test('020-110')) // 三、 let arrSubStraction = [5, [[4, 3], 2, 1]]; let number = 0; function substraction(arr) { arr.forEach((item, index) => { if (typeof item !== 'number') { substraction(item) } else { if (index === 0) { number += item } else { number += -item } } }); } substraction(arrSubStraction) console.log(number)"}],"posts":[{"title":"","slug":"Good Saying","date":"2023-09-08T08:08:38.799Z","updated":"2023-09-08T08:39:06.837Z","comments":true,"path":"2023/09/08/Good Saying/","link":"","permalink":"https://1314xulujin.github.io/2023/09/08/Good%20Saying/","excerpt":"","text":"123title: Good Sayingdate: 2023-09-08 17:10:00tags: Good Saying Good Saying Nothing will not change a person`s original heart, Life also will not defeat ours confidence, chest up! hold up head! look forward!, just ourselves could control our own life. Make a decision immediately on an unimportant thing, Do not think about a lot, just do it! Do not waste your time on such futile thing, save your energy and time. Imperfection is better than perfection!","categories":[],"tags":[]},{"title":"","slug":"deepclone&shallowclone","date":"2023-06-18T10:13:59.639Z","updated":"2023-06-21T02:23:44.393Z","comments":true,"path":"2023/06/18/deepclone&shallowclone/","link":"","permalink":"https://1314xulujin.github.io/2023/06/18/deepclone&shallowclone/","excerpt":"","text":"123title: assign value, deep clone and shallow clonedate: 2020-06-10 12:40:11tags: interview question Assign Value, Deep Clone and Shallow Clone1. Assign Value (Copy) Assign Value, It`s process to assign a value or object to a variable, The details of Assignment fall into the following: 1. Base data type: just assign value, Do not effect each others variable after assigned, convert or change, because they compile or design label. 2. Reference data type: assign address, Every variable have the some reference address, point to the same object, will effect each others. Here are some examples to describe clearly: （Abraham: some examples below show you how to use） Assign value to Base data type, Do not affect / impact each others // saucxs let a = &quot;saucxs&quot;; let b = a; console.log(b); // saucxs a = &quot;change&quot;; console.log(a); // change console.log(b); // saucxs 1234567891011121314151617181920212223242526272829303132&gt;2. Variables will point to the same address If you use reference data to operate assignment. It means if you change &quot;a&quot;, &quot;b&quot; also will change, Even you just change the base data in &quot;a&quot; 1. ~~~javascript &#x2F;&#x2F; saucxs let a &#x3D; &#123; name: &quot;saucxs&quot;, book: &#123; title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot; &#125; &#125; let b &#x3D; a; console.log(b); &#x2F;&#x2F; &#123; &#x2F;&#x2F; name: &quot;saucxs&quot;, &#x2F;&#x2F; book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot;&#125; &#x2F;&#x2F; &#125; a.name &#x3D; &quot;change&quot;; a.book.price &#x3D; &quot;55&quot;; console.log(a); &#x2F;&#x2F; &#123; &#x2F;&#x2F; name: &quot;change&quot;, &#x2F;&#x2F; book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;&#125; &#x2F;&#x2F; &#125; console.log(b); &#x2F;&#x2F; &#123; &#x2F;&#x2F; name: &quot;change&quot;, &#x2F;&#x2F; book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;&#125; &#x2F;&#x2F; &#125; In general / Generally, We don`t want / hope to change the &quot;b&quot; after changed &quot;a&quot;, You should use shallow or deep clone by now. 2. Shallow clone What is Shallow clone?Create a new object, This object have a exact copy of the original object property values. If property is base data type, then the copy is base type value, If property is reference data type, then the copy is cache address. So if you one of these objects change this address, then it will affect another object. In short, We can think shallow clone just resolve first level question, just copy the base data type value first layer, and reference type address of first layer Shallow clone usage scenario Object.assign() You can copy the enumerable value from one or more source object to target object, then it will return the target object. There are some developer say that “Object.assign()” is deep clone, But that`s actually not true. 123456789101112131415161718192021222324252627282930// saucxslet a = &#123; name: &quot;saucxs&quot;, book: &#123; title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot; &#125;&#125;let b = Object.assign(&#123;&#125;, a);console.log(b);// &#123;// name: &quot;saucxs&quot;,// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;// &#125; a.name = &quot;change&quot;;a.book.price = &quot;55&quot;;console.log(a);// &#123;// name: &quot;change&quot;,// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;// &#125; console.log(b);// &#123;// name: &quot;saucxs&quot;,// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;// &#125; Spread grammar12345678910111213141516171819202122232425262728// saucxslet a = &#123; name: &quot;saucxs&quot;, book: &#123; title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot; &#125;&#125;let b = &#123;...a&#125;;console.log(b);// &#123;// name: &quot;saucxs&quot;,// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;// &#125; a.name = &quot;change&quot;;a.book.price = &quot;55&quot;;console.log(a);// &#123;// name: &quot;change&quot;,// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;// &#125; console.log(b);// &#123;// name: &quot;saucxs&quot;,// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;// &#125; Array.prototype.slice“slice” don`t change the old array, “slice” can return a new array object, The object is shallow clone of old array was decided by begin and end. 12345678910111213// saucxslet a = [0, &quot;1&quot;, [2, 3]];let b = a.slice(1);console.log(b);// [&quot;1&quot;, [2, 3]]a[1] = &quot;99&quot;;a[2][0] = 4;console.log(a);// [0, &quot;99&quot;, [4, 3]]console.log(b);// [&quot;1&quot;, [4, 3]] From codes, we could see that the “b[0]” was not changed when the “a[1]” changed, But after changing “a[2][0]”, “b[1][0]” changed with it. It means “slice” just is shallow clone. Also, “concat” is shallow clone and etc, We ought pay more attention to this at work.","categories":[],"tags":[]},{"title":"0222面试问题","slug":"0222面试问题","date":"2023-02-22T05:10:10.000Z","updated":"2023-04-12T06:42:35.234Z","comments":true,"path":"2023/02/22/0222面试问题/","link":"","permalink":"https://1314xulujin.github.io/2023/02/22/0222%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/","excerpt":"","text":"技术问题: vue2和vue3响应式原理，及其区别？ 性能优化的经历？ 假如一个页面有50多个请求，怎么优化？ 根据是否要出发点击事件，按需触发 上下滚动屏幕，到了显示位置，懒加载 项目问题： 针对我的《数据资产管理平台》问碰到的问题，怎么解决？ 项目开发人员配置？ hr问题： 与同事开发联调碰到什么问题，怎么去根除这个问题？ 担任开发leader怎么去计划排期？ 开周会解决什么问题？ 怎么去提升自己？ 为啥离职？","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"","slug":"js将多个图片拼在一起下载成一张图片","date":"2022-10-15T01:06:16.427Z","updated":"2021-08-26T10:02:05.781Z","comments":true,"path":"2022/10/15/js将多个图片拼在一起下载成一张图片/","link":"","permalink":"https://1314xulujin.github.io/2022/10/15/js%E5%B0%86%E5%A4%9A%E4%B8%AA%E5%9B%BE%E7%89%87%E6%8B%BC%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%B8%8B%E8%BD%BD%E6%88%90%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87/","excerpt":"","text":"实现思路： ​ 1.准备下载 html2-canvas 插件（基于canvas drawImgae() 方法截图） ​ 2.调用 html2-canvas 方法截取多个图片，再将多个图片生成在一个div中 ​ 3.再调用html2-canvas 方法截取当前div ​ 4.调用 window.atob 将 base64 下载下来","categories":[],"tags":[]},{"title":"将node-sass换成dart-sass","slug":"将node-sass换成dart-sass","date":"2022-06-16T03:55:29.000Z","updated":"2022-06-16T06:34:32.830Z","comments":true,"path":"2022/06/16/将node-sass换成dart-sass/","link":"","permalink":"https://1314xulujin.github.io/2022/06/16/%E5%B0%86node-sass%E6%8D%A2%E6%88%90dart-sass/","excerpt":"","text":"问题描述：node-sass在 node-v16版本 报错兼容性差（将node-sass换成dart-sass）问题起因：因为sass官方在nide-v14版本以后使用dart-sass代替了node-sass,node-sass要依靠电脑底层C++语言进行编译，兼容性较差，sass官方便使用了dart-sass以虚拟的sass形式最后编译成css文件，这样不仅兼容性好且性能高 解决办法： 将nodejs版本换到16以上 卸载node-sass sass-loader sass (npm uninstall node-sass sass-loader sass) 再安装新的 sass-loader sass (npm install sass-loader sass -D)注意sass-loader要下载^10.1.1 更新vue.config.js文件12345678910// vue.config.jsmodule.exports = &#123; css: &#123; loaderOptions: &#123; sass: &#123; implementation: require(&#x27;sass&#x27;), // This line must in sass option &#125;, &#125;, &#125;&#125; 重启项目，如果node-gyp报错就全局安装更新 (npm install node-gyp -g) 如果报Rule can only have one resource source (provided resource and test + include + exclude) in，就安装 (npm install webpack@^4.0.0 –save-dev)注意sass-loader要下载^10.1.1这一步才能成功，不然会报错 this.getOption is not a function错误 如果 vue.config中的 sass prependData报错123Syntax Error: ValidationError: Invalid options object. Sass Loader has been initialized using an options object that does not match the API schema. - options has an unknown property &#x27;prependData&#x27;. These properties are valid: object &#123; implementation?, api?, sassOptions?, additionalData?, sourceMap?, webpackImporter?, warnRuleAsWarning? &#125; 就修改 原来的 1234567css: &#123; loaderOptions: &#123; sass: &#123; prependData: `@import &quot;~@/styles/variables.scss&quot;;` &#125; &#125; &#125; 修改后的 1234567css: &#123; loaderOptions: &#123; sass: &#123; additionalData: `@import &quot;~@/styles/variables.scss&quot;;` &#125; &#125; &#125; 如果 sass /deep/ 报错 就把 /deep/ 换成 ::v-deep 不出意外就可以正常运行了","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"自己对软件开发及交付流程理解","slug":"自己对软件开发及交付流程理解","date":"2022-05-25T05:31:29.000Z","updated":"2022-05-26T01:34:27.731Z","comments":true,"path":"2022/05/25/自己对软件开发及交付流程理解/","link":"","permalink":"https://1314xulujin.github.io/2022/05/25/%E8%87%AA%E5%B7%B1%E5%AF%B9%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8F%8A%E4%BA%A4%E4%BB%98%E6%B5%81%E7%A8%8B%E7%90%86%E8%A7%A3/","excerpt":"","text":"1.销售及售前阶段 方案 标书 SOW 2.项目准备阶段 客户初始需求 项目启动会 项目规范 开发规范 文档规范 3.蓝图设计阶段 需求概要设计 蓝图汇报 UI/UE原型 指标文档 技术设计说明书 4.项目实施阶段 数据模型设计 数据流设计 集成接口设计及数据字典 UI/UE原型（报表表样） 5.项目测试阶段 测试用例 UAT测试报告 6.上线及试运行阶段 用户培训手册 权限配置手册 上线文档 7.项目验收阶段 验收文档 8.项目运维阶段 运维及运营报告 运维手册 问题整理及销项表 9.项目后评估及结项阶段 项目总结报告 项目案例效益分析 客户投诉总结 10.项目上线阶段 上线部署文档 上线报告","categories":[],"tags":[{"name":"软实力","slug":"软实力","permalink":"https://1314xulujin.github.io/tags/%E8%BD%AF%E5%AE%9E%E5%8A%9B/"}]},{"title":"web前端关键词","slug":"web前端常见关键词","date":"2022-05-16T02:21:19.000Z","updated":"2022-05-16T03:22:02.897Z","comments":true,"path":"2022/05/16/web前端常见关键词/","link":"","permalink":"https://1314xulujin.github.io/2022/05/16/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E8%AF%8D/","excerpt":"","text":"PV （Page View）页面浏览量 FED（Front-End Development）前端开发 F2E（Front-End Engineer）前端工程师 WWW（World Wide Web）万维网 W3C（World Wide Web Consortium）万维网联盟 BBS（Bulletin Board System）电子公告板 URL（Uniform Resource Locator）统一资源定位符 URN（Uniform Resource Name）统一资源标名称 URI（Uniform Resource Identifier）统一资源标识符 NPM（Node Package Manager）Node.js包管理器 XML（Extensible Markup Language）可扩展标记语言 DTD（Document Type Definition）文档类型定义 XHR（XMLHttpRequest）XMLHTTP的请求API函数 CSS（Cascading Style Sheets）层叠样式表 BFC（Block Formatting Context）块格式化上下文 RWD（Responsive Web Design）响应式Web设计 SVG（Scalable Vector Graphics）可缩放的矢量图形 DOM（Document Object Model）文档对象模型 BOM（Browser Object Model）浏览器对象模型 NaN （Not a Number）非数字 MDN（Mozilla Developer Network）Mozilla开发者网络 MVC（Model View Controller）模型-视图-控制器 MVP（Model-View-Presenter）模型-视图-呈现 FAQ（Frequently Asked Questions）常见问题解答 IIS（Internet Information Service）互联网信息服务 ASP（Active Server Pages）动态服务器页面 PHP（Hypertext Preprocessor）超文本预处理器 JSP（Java Server Pages）Java服务器页面 JVM（Java Virtual Machine）Java虚拟机 RPC（Remote Procedure Call）远程过程调用 CDN（Content Dilivery Network）内容分发网络 NTP（Network Time Protocol）网络时间协议 GMT（Greenwich Mean Time）格林尼治标准时间 世界时 UTC（Coordinated Universal Time）协调世界时 PST（Pacific Standard Time）太平洋标准时间 XSS（Cross Site Scripting）跨站脚本攻击 XUL（XML User Interface Language）可扩展标记语言用户界面语言 SPA（Single Page Web Application）单页应用程序 RIA（Rich Internet Application）富互联网程序 WAI（Web Accessibility Initiative）网页易读性倡议 UMD（Universal Module Definition）通用模块定义 CMD（Common Module Definition）公共模块定义 AMD（Asynchronous Module Definition）异步模块定义 UED（User Experience Design）用户体验设计 RSS（Really Simple Syndication）简易信息聚合 CMS（Content Management System）内容管理系统 DBA（Database Administrator）数据库管理员 SEO（Search Engine Optimization）搜索引擎优化 CLI（Command-Line Interface）命令行界面 GUI（Graphical User Interface）图形用户界面 HCI（Human Computer Interaction）人机交互 API（Application Programming Interface） 应用程序编程接口 HSL（Hue Saturation Lightness） 色相、饱和度、亮度 RGB（Red Green Blue）红色 绿色 蓝色 DNS（Domain Name System）域名系统 RFC（Request For Comments）协议或标准的请求注解 DES（Data Encryption Standard）数据加密标准 DPI（Dots Per Inch）每英寸点数 GIF（Graphics Interchange Format）图形交换格式 ISO（International Organization for Standardization）国际标准化组织 ITU（International Telecommunication Union）国际电信联盟 HSLA（Hue Saturation Alpha） 色相、饱和度、亮度 透明度 RGBA（Red Green Blue Alpha） 红色 绿色 蓝色 透明度 SGML（Standard Generalized Markup Language）标准通用标记语言 HTML（HyperText Markup Language）超文本标记语言 SMIL（Synchronized Multimedia Integration Language）同步多媒体集成语言 HTTP（HyperText Transfer Protocol）超文本传输协议 SMTP（Simple Mail Transfer Protocol）简单邮件传输协议 SOAP（Simple Object Access Protocol）简单对象访问协议 IEEE（Institute of Electrical and Electronics Engineers）电气和电子工程师协会 IETF（Internet Engineering Task Force）因特网工程任务组 JPEG（Joint Photographic Experts Group）联合图像专家组 MPEG（Moving Picture Expert Group）运动图像专家组 MMVF（Multi-Media Video File）多媒体视频文件 MIDI（Musical Instrument Digital Interface）乐器数字接口 EDIF（Electronic Design Interchange Format）电子设计交换格式 JSON（JavaScript Object Notation) JS 对象简谱 BSON（Binary JSON) 二进制JSON ODBC（Open Database Connectivity) 开放数据库连接 JDBC（Java DataBase Connectivity) java数据库连接 AJAX（Asynchronous Javascript And XML）异步 JavaScript 和 XML MVVM（Model-View-ViewModel）模型-视图-视图模型 WCAG（Web Content Accessibility Guidelines）web内容无障碍指南 CSRF（Cross Site Request Forgery）跨站请求伪造 CORS（Cross-Origin Resource Sharing）跨域资源共享 HREF（Hypertext Reference）超文本引用 MIME (Multipurpose Internet Mail Extensions) 多用途互联网邮件扩展 REPL（Read-Eval-Print Loop）读取-求值-输出的循环 交互式解释器 ANSI（American National Standards Institute）美国国家标准学会 CNPM（Chinese Node Package Manager）淘宝镜像Node.js包管理器 JSONP（JSON with Padding）填充式JSON或参数式JSON HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）超文本传输安全协议 ASCII（American Standard Code for Information Interchange）美国信息交换标准代码 UTF-8（8-bit Unicode Transformation Format）8位Unicode转换格式 WHATWG（Web Hypertext Application Technology Working Group）网页超文本应用技术工作小组","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"腾讯互娱面试题","slug":"字节飞书面试题_20220119","date":"2022-01-19T01:10:23.000Z","updated":"2022-01-19T02:16:37.411Z","comments":true,"path":"2022/01/19/字节飞书面试题_20220119/","link":"","permalink":"https://1314xulujin.github.io/2022/01/19/%E5%AD%97%E8%8A%82%E9%A3%9E%E4%B9%A6%E9%9D%A2%E8%AF%95%E9%A2%98_20220119/","excerpt":"","text":"通过至少3种实现方式，使用数组原生方法（禁止使用 for 循环），对长度为10的数组移除第三个元素，eg. [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] =&gt; [10, 9, 7, 6, 5, 4, 3, 2, 1] 写一段正则表达式，用于判断以下字符串是否满足一下要求(区号+8位数字，或区号+特殊号码10010/110) 1. 020-12345678 =&gt; true（满足区号 + 8位数字) 2. 020-123456789 =&gt; false （不满足区号 + 8位数字) 3. 020-1234567 =&gt; false （不满足区号 + 8位数字) 4. 020-10010 =&gt; true （满足区号 + 特殊号码) 5. 020-110 =&gt; true （满足区号 + 特殊号码) 实现一个函数，能够将诸如 [5, [[4, 3], 2, 1]] 的数组当作 (5 - ((4 - 3) - 2 - 1)) 进行分组的减法运算，并返回结果。（不能使用 eval） 要在 10 秒后调用 checkState 函数，下列哪些写法是正确的[多选]setTimeout(checkState, 10)setTimeout(checkState(), 10)window.setTimeout(checkState, 10000)window.setTimeout(checkState(), 10000) 关于 JavaScript 的数据类型，以下哪些说法是正确的[多选]通过 const 声明的数组，不能向其中添加元素数组的 filter、map、sort、reverse 方法都会产生新数组任意的对象都能转换为 JSON 字符串Number 可以表达任意大小的数字Map 的 key 可以为任意类型 以下哪些场景是数组类型[多选]document.getElementsByClassName(“a”)Object.keys({a: 1})new Map([[‘a’, 1]]).keys()function fun() { console.log(arguments) } =&gt; arguments 是否为数组function fun(…args) { console.log(args) } =&gt; args 是否为数组 关于浏览器的限制，以下哪些说法是正确的[多选]可以通过 JS 创建 TCP 套接字（Socket）可以通过 JS 读取到用户希望上传的文件内容可以通过 JS 获取用户的操作系统、浏览器版本、屏幕分辨率等信息可以通过 JS 获取用户的收藏夹、历史记录等信息 关于浏览器的存储机制，以下说法哪些是正确的？[多选]服务端可以通过 HTTP 请求头获取用户浏览器中 Cookie 的内容js 可以获取服务端设置的所有 Cookie 内容localStorage 可以存储 Blob 数据Cookie 只能存储字符串数据，因此存储对象之前需要进行序列化除了 Cookie，其他的存储机制都没有跨域限制仅访问页面时服务端可以设置 cookie，ajax 请求不可以 关于网页样式和布局，以下说法哪些是正确的？[多选]CSS 中，vw 和 vh 其中的 v 是 viewport，指的是用户的屏幕尺寸选择器不仅可以选择 HTML 元素，还可以选择 SVG 中的图形关于样式优先级：!import &gt; 内联样式 &gt; CSS 样式 &gt; 浏览器默认样式HTML 元素顺序的优先级比 z-index 的优先级更高 以下关于图片格式的说明哪些是正确的？[多选]JPG 格式的图片支持有损压缩PNG 格式的图片包含图层信息，可以展示矢量图SVG 格式的图片，既可以通过 img 标签使用，也可以直接复制到 HTML 中使用GIF 格式的图片支持透明背景 浏览器的打开网页操作，可能会发生如下哪些事情，且对应描述是正确的？[多选]向 HTTP 默认端口 8080 建立 TCP 连接协商缓存不会向服务器发起请求强缓存不会向服务器发起请求通过 TCP 协议进行 DNS 解析，获取域名的 A 记录向本地硬盘写入 Cookie 和网页缓存等数据调用 GPU 能力对页面进行 2D 绘图","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"修养养成篇","slug":"修养养成篇_v1.0","date":"2021-08-14T10:12:19.000Z","updated":"2021-08-14T11:12:41.330Z","comments":true,"path":"2021/08/14/修养养成篇_v1.0/","link":"","permalink":"https://1314xulujin.github.io/2021/08/14/%E4%BF%AE%E5%85%BB%E5%85%BB%E6%88%90%E7%AF%87_v1.0/","excerpt":"","text":"1.能尊重别人的爱豆，不嘲讽别人的喜好，总是会让人感到舒服。 2.大学食堂，有很多人都会在拨开门帘后用手扶一下，免得门帘打到后面的人。 3.合照修图不仅修自己的，也修闺蜜的。 4.戴着耳机不要跟人说话，说话的时候拿掉耳机。 5.借了别人的充电宝，记得把充电宝充满电后及时归还。 6.在与人交往相处时，从不强调个人特殊的一面，也不有意表现自己的优越感。 7.不要没经过同意就随便看别人手机。 8.有了男朋友以后就不和其他人暧昧。 9.去外面聚餐，夹菜时用碗去接，防止汤汁滴到桌上。 10.关系再铁的异性，一旦对方有了女朋友，自己也应该远离。 11.不要试着用自己的秘密去交换一个朋友。 12.打破别人的喜悦这是一件很没礼貌的事情。 13.对于不喜欢的人会及时拒绝，不会故意吊着对方。 14.在酒桌上与别人碰杯，自己的杯子定要低于对方的，特别是对方是长辈或领导。 15.在有长辈的饭桌上，会等长辈先动筷子，自己才会动手。 16.吃饭的时候不会发出很大的声音，不会用筷子敲碗并敲出很大的声音。 17.别人给你发消息一定要回，就算不想聊也可以告诉他，哪怕是用表情或者标点来委婉的表达，不回消息不是高冷，是没教养。 18.在公共场合戴耳机不开功放是对大家的尊重。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://1314xulujin.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"在安装javaSE碰到的问题","slug":"在安装javaSE碰到的问题","date":"2021-06-23T01:44:20.000Z","updated":"2021-06-23T02:46:04.514Z","comments":true,"path":"2021/06/23/在安装javaSE碰到的问题/","link":"","permalink":"https://1314xulujin.github.io/2021/06/23/%E5%9C%A8%E5%AE%89%E8%A3%85javaSE%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"在运行java程序时出现 Error: could not open c:\\program Files\\Java\\jre6\\lib\\amd64\\jvm.cfg’ 1.场景： JDK原先装在C盘的，现在移动到了D盘，并在环境变量修改了%JAVA_HOME%的新路径，但是CMD中输入java后依然报错。 Error: could not open `C:\\Program Files\\Java\\jre1.8.0_131\\lib\\amd64\\jvm.cfg’ 解决办法： 在环境变量PATH中把下面这段挪到PATH最前面即可。记得要关闭再打开CMD后再输入java检查。 1%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 2.实在不行的话：卸载掉java后，如果还出现这种情况就到C:\\windows\\system32下的： java.exe javaw.exe javaws.exe 三个文件就OK了。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://1314xulujin.github.io/tags/java/"}]},{"title":"为什么vue中的data用return返回","slug":"为什么 vue 中的 data 使用 return 返回","date":"2021-05-20T05:20:07.000Z","updated":"2021-05-20T06:20:11.353Z","comments":true,"path":"2021/05/20/为什么 vue 中的 data 使用 return 返回/","link":"","permalink":"https://1314xulujin.github.io/2021/05/20/%E4%B8%BA%E4%BB%80%E4%B9%88%20vue%20%E4%B8%AD%E7%9A%84%20data%20%E4%BD%BF%E7%94%A8%20return%20%E8%BF%94%E5%9B%9E/","excerpt":"","text":"为什么vue中的data用return返回1、为什么在项目中data需要使用return返回数据呢？ 不使用return包裹的数据会在项目的全局可见，会造成变量污染；使用return包裹后数据中变量只在当前组件中生效，不会影响其他组件。 当一个组件被定义， data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。 2. 123456789101112131415161718// Vue实例中data属性是如下方式展示的：let app = newVue(&#123; el: &quot;#app&quot;, data: &#123; msg: &#x27;&#x27; &#125;, methods: &#123;&#125;&#125;)// 使用组件化的项目中是如下方式展示的:export default&#123; data()&#123; return&#123; showLogin:true, msg:&#x27;&#x27; &#125; &#125;, methods:&#123;&#125;&#125; ————————————————版权声明：本文为CSDN博主「阿扎姆王子」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_45156610/article/details/97154367","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://1314xulujin.github.io/tags/vue/"}]},{"title":"关于后台需要返回怎样的数据结构更加友好","slug":"后台给前端返回的友好数据结构","date":"2021-04-28T06:26:29.000Z","updated":"2021-05-12T11:27:11.505Z","comments":true,"path":"2021/04/28/后台给前端返回的友好数据结构/","link":"","permalink":"https://1314xulujin.github.io/2021/04/28/%E5%90%8E%E5%8F%B0%E7%BB%99%E5%89%8D%E7%AB%AF%E8%BF%94%E5%9B%9E%E7%9A%84%E5%8F%8B%E5%A5%BD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"1.表格: 1.普通的表格： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&gt;// 返回的 tbody 中的数据以数组的形式,如下：&gt;let tableData = [ &#123; field1:&#x27;50&#x27;， field2:&#x27;40&#x27;, &#125;, &#123; field1:&#x27;30&#x27;， field2:&#x27;30&#x27;, &#125;&gt;];&gt;// 需要返回 thead 表头也是以数组的形式,如下:&gt;1.let headerList1 = [&#x27;表头1&#x27;,&#x27;表头2&#x27;];&gt;2.let headerList2 = [ &#123; label:&#x27;表头1&#x27;， // 表头显示的文字 prop:&#x27;field1&#x27;, // 对应 tableData 的字段名 &#125;， &#123; label:&#x27;表头2&#x27;， prop:&#x27;field2&#x27;, &#125; ... // (推荐使用这种格式)， 以此类推，如果有 tableData 中字段名有多少种，headerList 的 length 就为多长&gt;];&gt;// 后台返回例子：&gt;&#123; code: 200, data:[ &#123; field1:&#x27;50&#x27;， field2:&#x27;40&#x27;, &#125;, &#123; field1:&#x27;30&#x27;， field2:&#x27;30&#x27;, &#125; ]&gt;&#125;&gt;或&gt;&#123; code: 200, data:&#123; header:[&#x27;表头1&#x27;,&#x27;表头2&#x27;], list:[ &#123; field1:&#x27;50&#x27;， field2:&#x27;40&#x27;, &#125;, &#123; field1:&#x27;30&#x27;， field2:&#x27;30&#x27;, &#125; ] &#125;&gt;&#125;&gt;或&gt;&#123; code: 200, data:&#123; header:[&#123; label:&#x27;表头1&#x27;， // 表头显示的文字 prop:&#x27;field1&#x27;, // 对应 tableData 的字段名 &#125;， &#123; label:&#x27;表头2&#x27;， prop:&#x27;field2&#x27;, &#125;], list:[ &#123; field1:&#x27;50&#x27;， field2:&#x27;40&#x27;, &#125;, &#123; field1:&#x27;30&#x27;， field2:&#x27;30&#x27;, &#125; ] &#125;&gt;&#125; 2.菜单结构 1234567891011121314151617181920212223242526272829&gt;树型结构示例:&gt;let menuList =[ &#123; menuName:&#x27;集团&#x27;, menuCode:&#x27;集团&#x27;, children:[ &#123; menuName:&#x27;宏观分析类&#x27;, menuCode:&#x27;hgfxl&#x27;, children:[ &#123; menuName:&#x27;定期研究报告&#x27;, menuCode:&#x27;dqyjbg&#x27;, children:[ &#123; menuName:&#x27;定期研究报告&#x27;, menuCode:&#x27;dqyjbg&#x27; &#125; ] &#125;, &#123; menuName:&#x27;定期研究报告&#x27;, menuCode:&#x27;dqyjbg&#x27;, &#125; ] &#125;, ] &#125;&gt;]","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://1314xulujin.github.io/tags/js/"}]},{"title":"vue刷新组件","slug":"刷新组件","date":"2021-04-19T08:56:20.000Z","updated":"2021-04-19T10:00:31.125Z","comments":true,"path":"2021/04/19/刷新组件/","link":"","permalink":"https://1314xulujin.github.io/2021/04/19/%E5%88%B7%E6%96%B0%E7%BB%84%E4%BB%B6/","excerpt":"","text":"vue刷新组件第一种方法：利用v-if控制router-view，在根组件APP.vue中实现一个刷新方法 123456789101112131415161718192021&lt;template&gt;&lt;router-view v-if=&quot;isRouterAlive&quot;/&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; isRouterAlive: true &#125; &#125;, methods: &#123; reload () &#123; this.isRouterAlive = false this.$nextTick(() =&gt; (this.isRouterAlive = true)) &#125; &#125;&#125;&lt;/script&gt;然后其它任何想刷新自己的路由页面，都可以这样：this.reload() 这种方法可以实现任意组件的刷新。 第二种方法：路由替换 123456789101112 // replace another route (with different component or a dead route) at first// 先进入一个空路由vm.$router.replace(&#123; path: &#x27;/_empty&#x27;,&#125;)//then replace your route (with same component)vm.$router.replace(&#123; path: &#x27;/student/report&#x27;, query: &#123; &#x27;paperId&#x27;:paperId &#125;&#125;) 转载自：https://blog.csdn.net/weixin_40054326/article/details/79384433","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://1314xulujin.github.io/tags/vue/"}]},{"title":"2021年规划","slug":"2021年工作规划","date":"2021-02-20T05:24:20.000Z","updated":"2021-02-20T06:53:38.533Z","comments":true,"path":"2021/02/20/2021年工作规划/","link":"","permalink":"https://1314xulujin.github.io/2021/02/20/2021%E5%B9%B4%E5%B7%A5%E4%BD%9C%E8%A7%84%E5%88%92/","excerpt":"","text":"生活1.坚持做40个俯卧撑或俯卧撑（每天）2.偶尔跑步3.坚持吃早餐工作1.解决2020年未解决的问题。 1.nginx配置。 2.ant-design-vue table在列全是负数排序错乱原因 2.学习前端架构经验 （技术选型，组件封装，工具函数优化，具体逻辑代码优化）。3.学习产品化思想来开发 。4.学习后台工作流程，提高工作效率 。5.完成中级前端的进阶。","categories":[],"tags":[{"name":"智扬信达","slug":"智扬信达","permalink":"https://1314xulujin.github.io/tags/%E6%99%BA%E6%89%AC%E4%BF%A1%E8%BE%BE/"}]},{"title":"程序员面试五个陷阱","slug":"程序员面试五大陷阱","date":"2021-02-20T05:24:20.000Z","updated":"2021-02-20T06:56:13.393Z","comments":true,"path":"2021/02/20/程序员面试五大陷阱/","link":"","permalink":"https://1314xulujin.github.io/2021/02/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E4%BA%94%E5%A4%A7%E9%99%B7%E9%98%B1/","excerpt":"","text":"程序员面试时一定要注意这五个陷阱！你记住了吗?程序员面试时一定要注意这五个陷阱！你记住了吗? 前言很多程序员到新公司面试时没有注意到一些小问题，从而导致HR直接将自己pass掉，又或者是沦为了备用的垫底存在，那么这几个导致你被pass的小问题你是否注意过？下面请听我一一道来，希望能对大家有所启发。 一、你为什么离开上家公司？进行社招面试时，这个问题几乎是必问的。其实这个问题主要是想试探一下求职者的核心诉求，并借此预估一下求职者将来在本公司的稳定性。常见的答案也就几种，无非就是对薪酬不满意、工作氛围不够、环境不好、干的不愉快。 但是有部分初次跳槽的求职者回答是：“在原来的公司学不到技术。” 一听到这个，那估计你其他项目准备的在充分也没用了，因为在HR面前也算是报废了，基本没戏再唱，即使你后面说的天花乱坠，HR也会觉得是敷衍。 因为在HR的经验来看，这句话基本出自一个工作时间不满两年的小白说出来的，很大概率会将你定义为一个不会学习不会感恩又特别爱抱怨的人。所以宁愿回答的普通一点，也不要天真的去追逐技术上的高端。 二、说说你最大的缺点这个问题HR一般问到的几率也很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。但绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色。 事实上，在HR眼里，此时的你已经沦为小丑，给他的感觉只剩下做作。HR一般喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者。 三、在五年时间内，你的职业规划是什么？说实话，这应该是大部分求职者最不想被问到的一个问题，但几乎每个人都会被问到。说得难听一点，如果是一个新人，他目前最需要的是一份工作而已，对于企业什么的都还是一知半解，自己都还是懵逼状态的人又谈何规划。但你又不能说不知道，这样或许会导致你失去一些机会。 当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。 如果是老人，职业规划过于简单，难道前任公司满足不了？很容易衍生到究竟是能力不行还是公司不行的问题上。不过一些聪明的老人还是总结出了一些最普通的回答：“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。 四、你还有什么问题要问？这个问题看上去可有可无，但其实也很关键，HR不喜欢说“没有问题”的人，因为想看看求职者的性格与创新能力。但是，他们也不喜欢求职者问一些关于个人福利之类的问题。 最简单的回答就是问一下HR，公司对新入公司的员工有没有什么培训项目，自己能否参加。或者问下公司的晋升机制是怎么样的？一方面表现自己的忠诚度，一方面也表现下自己对学习的热情跟上进心。 五、说说你对行业、技术趋势的看法？HR一般对这个问题很感兴趣，除非你是应届新人，否则只有有备而来的求职者才能过关。可以事先在网站上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。 HR认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。 程序员最核心的竞争力：学习力 互联网时代的技术来得快，去得更快。就像Flash这样曾经雄霸天下多年的技术，都有被人人唾弃的一天。如果没有足够强的学习能力，就无法跟上变化，被淘汰只是迟早的事。想想看，你苦心钻研多年引以为傲的技术，一夜之间就没有用武之地了，难免会有一种「身体被掏空」的感觉。 学习力强的程序员敢大胆地体验尝试新技术，他们的技术栈始终在保持不断地更新。他们能快速把握事物的本质，并判断出它能用来做什么，不能用来做什么。他们拥抱技术升级和革命，因为他们学习并掌握新技术的速度比其他人更快，所以他们永远不用担心失业。 后语如果觉得本文对你有所帮助，欢迎点赞+关注，你的支持就是我持续输出好内容的动力哦！","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"echarts多Y轴显示负数零刻度线对齐","slug":"echarts多Y轴显示负数零刻度线对齐","date":"2020-09-18T02:23:11.000Z","updated":"2020-09-18T03:27:30.839Z","comments":true,"path":"2020/09/18/echarts多Y轴显示负数零刻度线对齐/","link":"","permalink":"https://1314xulujin.github.io/2020/09/18/echarts%E5%A4%9AY%E8%BD%B4%E6%98%BE%E7%A4%BA%E8%B4%9F%E6%95%B0%E9%9B%B6%E5%88%BB%E5%BA%A6%E7%BA%BF%E5%AF%B9%E9%BD%90/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667option = &#123; xAxis: &#123; type: &#x27;category&#x27;, data: [&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;] &#125;, yAxis: [&#123; type: &#x27;value&#x27;, max: function(value) &#123; if(Math.abs(value.max) &gt; Math.abs(value.min))&#123; return (Math.abs(value.max)*1.2).toFixed(2); &#125;else&#123; return (Math.abs(value.min)*1.2).toFixed(2); &#125; &#125;, min: function(value) &#123; if(Math.abs(value.max) &gt; Math.abs(value.min))&#123; return (-Math.abs(value.max) * 1.2).toFixed(2); &#125;else&#123; return (-Math.abs(value.min) * 1.2).toFixed(2); &#125; &#125; &#125;, &#123; type: &#x27;value&#x27;, max: function(value) &#123; if(Math.abs(value.max) &gt; Math.abs(value.min))&#123; return (Math.abs(value.max)*1.2).toFixed(2); &#125;else&#123; return (Math.abs(value.min)*1.2).toFixed(2); &#125; &#125;, min: function(value) &#123; if(Math.abs(value.max) &gt; Math.abs(value.min))&#123; return (-Math.abs(value.max) * 1.2).toFixed(2); &#125;else&#123; return (-Math.abs(value.min) * 1.2).toFixed(2); &#125; &#125; &#125;], series: [&#123; data: [120, 200, -150, 80, 70, -110, 130], type: &#x27;bar&#x27;, yAxisIndex: 1 &#125;, &#123; data: [120, 200, 150, 80, -70, 110, -130], type: &#x27;bar&#x27; &#125;] &#125;// 关键代码max: function(value) &#123; if(Math.abs(value.max) &gt; Math.abs(value.min))&#123; return (Math.abs(value.max)*1.2).toFixed(2); &#125;else&#123; return (Math.abs(value.min)*1.2).toFixed(2); &#125; &#125;, min: function(value) &#123; if(Math.abs(value.max) &gt; Math.abs(value.min))&#123; return (-Math.abs(value.max) * 1.2).toFixed(2); &#125;else&#123; return (-Math.abs(value.min) * 1.2).toFixed(2); &#125; &#125; 具体解决方案可参考 博客 echarts官方文档","categories":[],"tags":[{"name":"冷知识","slug":"冷知识","permalink":"https://1314xulujin.github.io/tags/%E5%86%B7%E7%9F%A5%E8%AF%86/"}]},{"title":"chrome80版本以后，SAMESITE COOKIE验证跨站问题","slug":"CHROME 80版本以后，SAMESITE COOKIE验证跨站问题","date":"2020-08-21T07:33:10.000Z","updated":"2020-08-26T01:14:47.567Z","comments":true,"path":"2020/08/21/CHROME 80版本以后，SAMESITE COOKIE验证跨站问题/","link":"","permalink":"https://1314xulujin.github.io/2020/08/21/CHROME%2080%E7%89%88%E6%9C%AC%E4%BB%A5%E5%90%8E%EF%BC%8CSAMESITE%20COOKIE%E9%AA%8C%E8%AF%81%E8%B7%A8%E7%AB%99%E9%97%AE%E9%A2%98/","excerpt":"","text":"这几天忙着写文档，一直看的线上环境的系统。今天启动本地测试环境，发现登录不成功。排查问题发现登录成功后，之后的请求没有携带cookie。然后我就仔细看了一下登录请求的参数。 发现在chorme header头的cookie里有一个黄色的小叹号，发现问题了。 this set-cookie didn’t specify a “SameSite” attribute，然后变成默认Lax。(不能复制，懒得打英文了) 然后我搜索了一下Samesite定义，有三个值，None, Lax,Strict.这个参数是防止跨站攻击用的，因为测试环境，所以最方便就是跨站调试了。 然后我搜了一下flask源码，发现有这个设置，配置了一下发现不管用。然后放弃了。 找了一下怎么关闭chrome的这个选项，虽然别的网站可能有一点风险。自己调试的时候会方便点。 chrome://flags/#same-site-by-default-cookies chrome://flags/#cookies-without-same-site-must-be-secure 这两项设置为Disabled，并重启浏览器","categories":[],"tags":[{"name":"冷知识","slug":"冷知识","permalink":"https://1314xulujin.github.io/tags/%E5%86%B7%E7%9F%A5%E8%AF%86/"}]},{"title":"js的Object.assign","slug":"js的Object.assign","date":"2020-08-21T07:33:10.000Z","updated":"2021-04-15T07:26:47.397Z","comments":true,"path":"2020/08/21/js的Object.assign/","link":"","permalink":"https://1314xulujin.github.io/2020/08/21/js%E7%9A%84Object.assign/","excerpt":"","text":"现需要在js中，使用一个新的对象的值覆盖旧有对象，js中有一个方法：Object.assign(target,…sources)当target和sources对象中有相同的key时，在target对象中的值会被后面source对象的值覆盖。 1234567891011var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, target对象自身会被修改 如果想要避免o1被改变，需要这样写： 12345var obj = Object.assign(&#123;&#125;,o1,o2,o3);//给一个空对象作为target，这样改变的是空对象console.log(obj);// &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1&#125;","categories":[],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"前端知识结构","slug":"前端知识结构","date":"2020-08-21T07:33:10.000Z","updated":"2022-08-10T11:55:56.945Z","comments":true,"path":"2020/08/21/前端知识结构/","link":"","permalink":"https://1314xulujin.github.io/2020/08/21/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84/","excerpt":"","text":"前端知识结构项目起源还记得@jayli 的这幅前端知识结构图么。 图片的形式具有诸多的不便。缺失源图的我们，无法为此图贡献些什么，随着时间的迁移，或许有些技术点会发生改变，所以有了这个GitHub项目。我们可以通过协作的方式来共同维护这个项目。Git的历史记录也可以见证前端行业的一些变迁。 可视化效果 前端开发知识结构 前端工程师 浏览器 IE6/7/8/9/10/11 (Trident) / Edge (EdgeHTML) Firefox (Gecko) Chrome/Chromium (Blink) Safari (WebKit) Opera (Blink) 编程语言 JavaScript/Node.js CoffeeScript TypeScript 切页面 HTML/HTML5 CSS/CSS3 Sass/LESS/Stylus/postCSS PhotoShop/Paint.net/Fireworks/GIMP/Sketch 开发工具 编辑器和IDE VIM/Sublime Text2 Notepad++/EditPlus WebStorm Emacs EmacsWiki Brackets Atom Lime Text Light Table Codebox TextMate Neovim Komodo IDE / Edit Eclipse Visual Studio Visual Studio Code NetBeans Cloud9 IDE HBuilder Nuclide 调试工具 Firebug/Firecookie YSlow IEDeveloperToolbar/IETester Fiddler Chrome Dev Tools Dragonfly DebugBar Venkman Charles 版本管理 Git/SVN/Mercurial Github/GitLab/Bitbucket/Gitorious/GNU Savannah/Launchpad/SourceForge/TeamForge 代码质量 Coding style JSLint/JSHint/jscs/ESLint CSSLint Markup Validation Service HTML Validators 单元测试 QUnit/Jasmine Mocha/Should/Chai/Expect Unit JS 自动化测试 WebDriver/Protractor/Karma Runner/Sahi phantomjs SourceLabs/BrowserStack 前端库/框架 jQuery/Underscore/Mootools/Prototype.js YUI3/Dojo/ExtJS/KISSY Backbone/KnockoutJS/Emberjs AngularJS Batarang Bootstrap Semantic UI Juice UI Web Atoms Polymer Dhtmlx qooxdoo React Brick vue.js 前端标准/规范 HTTP/1.1: RFCs 7230-7235 HTTP/2 ECMAScript3/5 ECMAScript6 W3C: DOM/BOM/XHTML/XML/JSON/JSONP/… CommonJS Modules/AMD HTML5/CSS3 Semantic Web MicroData RDFa Web Accessibility WCAG Role Attribute WAI-ARIA 性能 JSPerf YSlow 35 rules PageSpeed HTTPWatch DynaTrace’s Ajax 高性能JavaScript SEO 编程知识储备 数据结构 OOP/AOP 原型链/作用域链 闭包 编程范型 设计模式 Javascript Tips 部署流程 压缩合并 YUI Compressor Google Clousure Complier UglifyJS CleanCSS 文档输出 JSDoc Dox/Doxmate/Grunt-Doxmate 项目构建工具 make/Ant GYP Grunt Gulp Yeoman FIS Mod ES6＋ 转换器 Traceur Babel 代码组织 类库模块化 CommonJS/AMD YUI3模块 webpack 业务逻辑模块化 bower/component 文件加载 LABjs SeaJS/Require.js 模块化预处理器 Browserify 安全 CSRF/XSS CSP Same-origin policy ADsafe/Caja/Sandbox 移动Web HTML5/CSS3 响应式网页设计 Zeptojs/iScroll V5/Sencha Touch PhoneGap/Cordova jQuery Mobile W3C Mobile Web Initiative W3C mobileOK Checker Open Mobile Alliance React Native ionic 前沿技术社区/会议 D2/WebRebuild NodeParty/W3CTech/HTML5梦工厂 JSConf/沪JS(JSConf.cn) QCon/Velocity/SDCC JSConf/NodeConf CSSConf YDN/YUIConf HybridApp WHATWG MDN codepen w3cplus CNode 计算机知识储备 编译原理 计算机网络 操作系统 算法原理 软件工程/软件测试原理 Unicode 软技能 知识管理/总结分享 沟通技巧/团队协作 需求管理/PM 交互设计/可用性/可访问性知识 可视化 SVG/Canvas/VML SVG: D3/Raphaël/Snap.svg/DataV Canvas: CreateJS/KineticJS WebGL/Three.JS 后端工程师 编程语言 C/C++/Java/PHP/Ruby/Python/… 网页服务器 Nginx Apache Lighttpd 数据库 SQL MySQL/PostgreSQL/Oracle/DB2 MongoDB/CouchDB 数据缓存 Redis Memcached 文件缓存/代理 Varnish Squid 操作系统 Unix/Linux/OS X/Windows 数据结构 前端书籍推荐★越少越简单,越适合入门,★多的要么是难度比较高,要么是比较适合在后面看,比如讲性能之类的书. CSS Eric Meyer 谈 CSS（卷二）★★★ CSS权威指南 （第3版）★★ 精通CSS★★★ HTML &amp; CSS设计与构建网站★ JavaScript JavaScript &amp; jQuery交互式Web前端开发★ JavaScript DOM编程艺术 （第2版）★ JavaScript高级程序设计（第3版）★★ 锋利的jQuery★★ 高性能JavaScript★★★ JavaScript语言精粹★★★ JavaScript权威指南★★★ 编写可维护的JavaScript★★★ JAVASCRIPT语言精髓与编程实践★★★ Effective Javascript★★★ Secrets of the JavaScript Ninja★★★ JavaScript模式★★★ JavaScript设计模式★★★★ 基于MVC的JavaScript Web富应用开发★★★ 性能实践 高性能网站建设指南★ 高性能网站建设进阶指南★★ Web性能实践日志★★★ Web性能权威指南★★★ 版本控制工具 版本控制之道 (git)★★ Pro Git★★★ Git权威指南★★★★ 后端书籍推荐Linux管理 Linux 系统管理技术手册 鸟哥的 Linux 私房菜 Linux 101 Hacks UNIX Shell Scripting The Linux Command Line Linux Network Administrator’s Guide Linux编程 Linux程序设计 Linux系统编程 Unix环境高级编程 Unix编程艺术 The Linux Programming Interface 程序员的自我修养 深入理解Linux内核 Unix网络编程 TCP/IP高级编程 C/C++ Linux C编程一站式学习 C和指针 C陷阱与缺陷 C专家编程 C语言核心技术 彻底搞定C指针 征服C指针 C++编程思想 高质量程序设计指南—C/C++语言 Inside the C++ Object Model A Tour of C++ The C++ Programming Language The C++ Standard Library - A Tutorial and Reference The C++ Standard (INCITS/ISO/IEC 14882-2011) Overview of the New C++ 前端工作面试 前端工作面试问题 前端开发面试题（中文） 内容贡献者除了感谢Jayli提供了知识结构图的原本来，还感谢以下的内容贡献者们，结果由git-summary生成于2014-01-03： 123456789101112131415161718192021222324252627282930313233project : fksrepo age : 1 year, 3 monthsactive : 53 dayscommits : 108files : 4authors : 56 Jackson Tian 51.9% 9 吴晓兰 8.3% 5 liyinkan 4.6% 3 chriscai 2.8% 3 fengxiaolong 2.8% 3 XiNGRZ 2.8% 2 monkadd 1.9% 2 Johnny 1.9% 2 weiwenqing 1.9% 2 Yinkan Li 1.9% 2 Copypeng 1.9% 2 左岸 1.9% 2 Jakukyo Friel 1.9% 2 Glowin 1.9% 1 李亚川 0.9% 1 Evan You 0.9% 1 Mickey 0.9% 1 Mickey- 0.9% 1 Qi Junyuan 0.9% 1 browsnet 0.9% 1 doabit 0.9% 1 guoxiangyang 0.9% 1 linkgod 0.9% 1 popomore 0.9% 1 vipzhicheng 0.9% 1 zhaqiang 0.9% 1 Colin Luo 0.9%","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"试用期工作总结","slug":"试用期工作总结-徐路金","date":"2020-07-27T01:49:25.000Z","updated":"2020-07-30T10:12:00.355Z","comments":true,"path":"2020/07/27/试用期工作总结-徐路金/","link":"","permalink":"https://1314xulujin.github.io/2020/07/27/%E8%AF%95%E7%94%A8%E6%9C%9F%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E5%BE%90%E8%B7%AF%E9%87%91/","excerpt":"","text":"2020年07081.负责东鹏后台系统的各个页面的局部样式（scss）的修改。 1.比如一些table布局溢出看不到内容。 2.比如控制一处表单一行显示等，主要修改element的样式。 3.遇到element的table布局下面多一条横线，添加如下代码解决 123&gt;.el-table::before &#123; // 解决table-el布局栏多一条线的问题 z-index: inherit;&gt;&#125; 2.在钉钉直播观看胡主管讲关于多租户saas架构设计 定义： ​ SaaS是Software-as-a-service（软件即服务）。SaaS提供商为企业搭建信息化所需要的所有网络基础设施及软件、硬件运作平台，并负责所有前期的实施、后期的维护等一系列服务，企业无需购买软硬件、建设机房、招聘IT人员，即可通过互联网使用信息系统。就像打开自来水龙头就能用水一样，企业根据实际需要，向SaaS提供商租赁软件服务。 我的认识： ​ 对不同的租户提供不同的权限，返回不同的路由表，即显示的页面也不同。 实现的方面： ​ 1.数据库实现 ​ 多个租户可能有多个不同的表或者不同的字段来分开 ​ 2.程序实现 ​ 返回的权限码不同 ​ 3.应用实现 总结： ​ 需要实现一些资料的共享，且还要达到每个租户的数据隔离（自己的数据只有自己看的到） 3.钉钉直播-2020期刊分享-大数据开发部-大数据技术体系初窥 1.分享主题 ​ ①让您了解*大数据前沿技术*，不管在BI领域还是H5领域瞬 间变身专家级Level。 ​ ②让您了解炫酷的数据可视化是怎么做出来的，它的极限在哪 儿？抑或没有极限。 ​ ③从一堆普通的数据，如何经过技术处理变成了生动互操作的 直观图表？这个过程中数仓起了哪些作用？ 2.演讲的同学 ​ 前端：曾诚、李小平 ​ java：王海杏、黄任成 3.关于前端 ​ 从前端三剑客HTML，CSS，JS基础，到前端自动化开发npm，webpack和Vue全家桶，前端的同学们讲的很不错，让我了解到前端开发是包括了日常用的一些技术但不仅限于这些，应验了一句圈子里常说的话：前端入门容易，精通难。但其实又何止前端是这样，其他像java，数据库，运维等等，都是如此。 07241.负责管理中心的 参数管理和租户主表 页面功能的实现。 1.调用新增菜单接口在路由表新增页面，接口为 /menu/insertMenu ，填写相应的路由名称和路由url。 2.参数管理布局和接口基本参照字典管理来编写；租户主表布局参照用户管理，租户主表的租户除了有租户的信息，多了一项租户的属性，目前暂时只显示是否为新窗口打开报表。 3.每个页面对表格的数据操作有 编辑，删除，修改状态，预览，授权，角色绑定，映射，详情，同步，测试，查看，取消收藏；但不是每个路由的表格都有所有的操作，是根据每次切换路由获取到表格数据，判断里面有没有这个操作权限，逐一显示出来；其中说一下删除，后端返回了两种接口，一种是硬删除，一种是软删除(改变其status状态，不算是删除)。 4.碰到问题：对Vue定义的一些方法熟悉，常常碰到500错误与后端协商。 4.问题起因：500错误可能是因为前端带过去的参数不规范导致，也可能是后端没对多个出现的情况进行判断。 2.了解了单点登录的流程。 1.单点登录的定义：​ 单点登录（Single Sign On），简称为 SSO，是比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 2.实现方法：​ server端： ​ “共享Cookie”这个就是上面提到的共享session的方式 SSO-Token方式因为共享session的方式不安全，所以我们不再以session-id作为身份的标识。我们另外生成一种标识，把它取名SSO-Token(或Ticket) ​ 浏览器端: ​ 用户登录成功拿到token(或者是session-id)后怎么让浏览器存储和分享到其它域名下？同域名很简单，把token存在cookie里，把cookie的路径设置成顶级域名下，这样所有子域都能读取cookie中的token。这就是共享cookie的方式（这才叫共享Cookie嘛，上面那个应该叫共享session） 3.前端负责单点登录哪些​ 大部分单点登录逻辑都交给后端进行处理； ​ 前端需判断是否为跳转到loading登录，loading可能有几种登录方式，比如微信登录或者根据地址栏参数登录；地址栏又会传不同的字段过来，比如是code、token或者其他租户规定的字段，再调用后端返回的不同的接口进行验证登录； ​ 也有些租户，比如东鹏，需求是不使用跳转loading页登录，要和系统登陆一样，这时需要根据打开当前页面返回的用户信息的loginType字段判断是系统默认登录方式还是像东鹏这样的租户登录的方式。 3.修改东鹏页面日常的一些bug。 1.调用新增接口新增一段信息后，再次打开表单后表单验证提示不消失。 ​ 起因：是表单域的 el-item-form 的prop属性 与 v-model的值 的名称不一样导致的。 ​ 解决方法：1.可以将 prop属性 与 v-model的值 的名称改成一样的(推荐)；2.使用重置表单验证的方法 this.$refs[formName].resetFields() ，在提交接口之后添加，方法比较粗暴，不建议使用。 2.vue router连续点击多次路由报错解决方法 12345&gt;// 在main.js下添加以下代码：&gt;const originalPush = Router.prototype.push&gt;Router.prototype.push = function push(location) &#123; return originalPush.call(this, location).catch(err =&gt; err)&gt;&#125; 3.角色管理 点击授权按钮，其中没有子集的父属性不会被勾选。 ​ 起因：在实例中定义了一个array_diff方法，里面的逻辑涉及到浅拷贝影响数组的内存地址； ​ 解决：加一个判断，如果这个父属性也被选中了，判断它有没有子集，有子集就剔除，反之… 4. 4.兼容IE9+样式适配。 1.根据东鹏租户的需求，兼容IE9浏览器。 2.IE9 ，IE10， IE11三个版本对一种代码所体现出来的样式都有不同，IE10和IE11大体差别不大，侧重点在IE9，它不支持flex布局，所以之前写的flex不生效，可以使用float浮动来解决(推荐)，也可使用position定位解决，这里我使用了float。 3.对IE9 ，IE10， IE11媒体查询设置样式，媒体查询模板代码参考下面 123456789101112131415161718192021&gt;// 1920px, 1440px, 1366px, IE9+适配媒体查询模板&gt;@media screen and (max-width: 1920px) &#123;&#125;&gt;@media screen and (max-width: 1440px) &#123;&#125;&gt;@media screen and (max-width: 1366px) &#123;&#125;&gt;/* IE Hacks: targets IE 8, 9 and 10 , 需要先设置IE 9 + 才能去设置IE 10 +*/&gt;@media screen\\0 &#123;&#125;&gt;/* IE Hacks: targets IE 10 + , 需要先设置IE 10 + 再去设置IE 11 */&gt;@media screen and (-ms-high-contrast: active),&gt;(-ms-high-contrast: none) &#123; 类名&#123; /* IE 10 + */ &#125; _:-ms-fullscreen, :root, 类名 &#123; /* IE 11 */ &#125; &gt;&#125; 4.IE9也不支持过渡和动画，如果需要做动画，只能使用js，但是考虑到性能，还是不做为好。 07281.东鹏页面增加二级菜单收缩功能。 1.需求详解：在二级菜单里面增加一个按钮，在点击按钮时切换菜单状态(收缩状态还是展开状态)；每个一级菜单的二级菜单都是同步的状态。 2.具体实现：定义初始的状态，在点击按钮后，下一次点击，判断当前的状态，改变二级菜单的宽度即可。 3.遇到的问题：1.IE9中不支持flex布局，需要做另外处理；2.1366px 1440px 1920px各个屏幕会有些不同，1920px出现菜单收缩状态时，它没有被内容区域全部覆盖； 4.解决办法：1.IE9使用的float布局，做另外处理；2.1920px下将内容区域的z-index设置大于二级菜单的z-index。","categories":[],"tags":[{"name":"智扬信达","slug":"智扬信达","permalink":"https://1314xulujin.github.io/tags/%E6%99%BA%E6%89%AC%E4%BF%A1%E8%BE%BE/"}]},{"title":"vscode常用插件在","slug":"vscode插件大全","date":"2020-07-17T05:31:29.000Z","updated":"2021-01-06T09:50:29.555Z","comments":true,"path":"2020/07/17/vscode插件大全/","link":"","permalink":"https://1314xulujin.github.io/2020/07/17/vscode%E6%8F%92%E4%BB%B6%E5%A4%A7%E5%85%A8/","excerpt":"","text":"vsCode 常用插件 shmaur关注 0.1622019.06.20 15:09:31字数 775阅读 23,810 记录一下所用的插件 1. auto close tag​ 自动关闭标签，在开始标记的结束括号中键入后，将自动插入结束标记 2. Auto Comment Blocks​ 自动插入注释行 3. Auto Rename Tag​ 自动重命名配对的HTML / XML标记 4. Auto Complete Tag​ 结合了自动关闭标签与同时修改同步标签 5. Beautify​ 美化代码参考资料 6. Code Runner​ 可以直接运行多种语言的代码片段和文件 7. Code Spell Checker​ 代码拼写检查工具 8. Drat​ 支持 Dart编程语言，并提供有效编辑，重构，运行和重新加载Flutter 移动应用程序和AngularDartWeb应用程序的工具。 9. Debugger for Chrome​ 从VS Code调试在Google Chrome中运行的JavaScript代码。 10. EditorConfig for VS Code​ EditorConfig帮助开发人员定义和维护一致的编码风格在不同的编辑器和IDE。 EditorConfig项目包含一个文件格式定义编码风格和文本编辑器插件的集合。 EditorConfig文件易于阅读并且他们与版本控制器很好地合作。 11. ESLint​ 代码检查工具 12. filesize​ 实时查看当前文件的大小 13. Flutter​ Flutter移动应用程序的支持，以及对Dart编程语言的支持。 14. Git History​ 查看git历史与log，搜索等（包括git log） 15. GitLens — Git supercharged​ GitLens只是帮助您更好地理解代码。快速浏览一下，为什么以及何时更改了行或代码块。跳过历史记录，以获得有关代码演变的方式和原因的进一步见解 16. IntelliSense for CSS class names in HTML​ CSS 类名智能提示，可以在html与css中进行智能提示 17. HTMLHint​ HTML 静态检查规则 18. Image preview​ 在左侧可以预览图片和悬停中显示图片 19. Import Cost​ 在VS代码编辑器中导入的程序包的大小 20. JavaScript (ES6) code snippets​ ES6的代码片段 21. JavaScript Snippet Pack​ JS代码片段补全 22. language-stylus​ Stylus文件添加语法高亮 23. stylelint​ 格式化css代码配置参考https://stylelint.io/user-guide/configuration/ 24. minapp​ 微信小程序标签、属性的智能补全（同时支持原生小程序、mpvue 和 wepy 框架，并提供 snippets） 25. Node.js Modules Intellisense​ 在import语句中自动完成Node.js模块 26. Open in Browser​ 在vscode中打开浏览器访问 27. Path Intellisense​ 自动路径补全 28. Prettier - Code formatter​ 格式化代码 29. Pug (Jade) snippets​ pug语法提示 30. Scss​ 缩进Sass语法高亮 31. TypeScript Importer​ 自动搜索工作空间文件中的TypeScript定义，并将所有已知符号作为完成项提供，以允许代码完成。 32. Vetur​ 代码格式化 33. vscode-element-helper​ 用element的就知道它的好，支持element代码自动补全 34. vscode-icons​ 在vscode显示文件图标 35. vue 2 Snippets​ vue 代码提示 36. Vue/Vuex TypeScript Snippets​ 支持typescript的代码提示与生成片段 37. VueHelper​ vue 代码提示","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"在工作中遇到的问题","slug":"工作中碰到的一些问题","date":"2020-07-17T05:31:29.000Z","updated":"2023-02-22T09:37:33.053Z","comments":true,"path":"2020/07/17/工作中碰到的一些问题/","link":"","permalink":"https://1314xulujin.github.io/2020/07/17/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","excerpt":"","text":"2020东鹏portal07月09日 ​ 1.element-ui的table表格布局多了一条线（已解决） ​ 答：添加样式 123&gt;.el-table::before &#123; // 解决table-el布局栏多一条线的问题z-index: inherit;&gt;&#125; ​ 2.element-ui新增表单提交数据后还出现验证（已解决） ​ 答：请求接口之后重置表单验证 1&gt;this.$refs[formName].resetFields() // 解决提交表单数据后还触发验证的问题 ​ 3.常常碰到与后端对接口的问题（常见）：比如返回的字段少了(分类字段)，比如新增用户过去带的状态(userStatus)是无效的(0),但是更新数据返回过来的还是有效的用户 祥生经营分析11月09日2020年11月06日开会需要提出的问题1.svn账号问题，（因为有多个人同时进行项目协作，用同一个账号在导致冲突之后不能及时的找到根源而浪费时间）2.vpn账号权限问题，vpn账号申请3. 项目 1.关于数据的问题：数据不完整，导致联调时在接口请求方式正确的情况下错误判断为其他问题2.后端接口规范问题： 1.最好不要返回map类型数据 2.在返回数据带上相应的status，code，data，msg等等 3.在传入空字符串后端应判断接收该参数没传而返回相应的msg提示，比如：参数错误400错误 4.在少传了参数之后返回msg：参数缺失，而不是直接报400错误 5.接口文档可以一般用swragger把传的参数的备注model，和返回的参数的意思标注规范，必传可以用粗体列出来require， 3.多人开发协调问题： 1.规定时间上传代码， 2.上传的描述见开发框架的README.md文档 3.规定一个必须的发版时间（在确认所有人上传代码完毕） 11月08日1.关于sessionStorage存入函数的问题 问题描述：1.由于需要页面之间需要sessionStorage来传值，需要将传的值JSON.stringify，但是有些需要传的值有函数，在JSON.stringify之后不会存储。 解决方法：1.首先需要使用toSting()将函数真正的转化为字符串，才可以将他存入到sessionStorage中。 ​ 2.然后接收方需要使用eval函数将字符串执行。 ​ 3.使用eval函数你会碰到Function statements require a function name，这是由于匿名函数直接执行而不知道他是谁的函数 ​ 4.我们需要在这个需要执行的字符串外层加一个括号，然后再使用eval函数执行。 11月13日 1.关于IE不能打开tomcat运行的页面 ​ 问题可能起因：1.本机防火墙问题 ​ 2.IE自身兼容性问题 2.关于tomcat换了端口之后，比如把8443换成8444端口，不能访问 ​ 问题可能起因：1.本机防火墙问题 ​ 解决方法： systemctl stop firewalld 关闭防火墙 systemctl status firewalld 查看防火墙状态 ​ 内外服务器如果比较安全的话，可以把防火墙关了 问题解决结果：完美解决！ 12月02日 ​ 1.经营分析明细表下钻问题： ​ 问题描述：由于后端返回的参数没有统一，返回的规范最好要有areaCode（组织编码），areaType（组织层级），且传的参数在签约，存货，计划页面中有多少个层级就写了多少个参数，这样做很不合理，于是在后面改成了传areaCode和areaType。 12月19日 东鹏portal碰到问题： 问题描述：1.前端本地请求接口不成功，但是打包到服务器没问题 问题起因：问题解决了，因为接口在这里set-cookie的时候，有一个”Secure”属性，但是，我本地启动的时候，是http协议启动的，这里的“Secure”属性会把我拦截掉，因为它觉得这是不安全的协议。后面我本地启动改成，https，就可以正常登录了。然后，我去调小城的本地，因为我们都是http，协议相同，所以可以登录。但是服务器是https的。 问题解决结果：完美解决！ 12月21日 问题描述：1.ant-design-vue 的table组件在企业微信PC端不显示 2.打包后样式不生效了 问题起因：是因为组件的样式在main.js注册时被覆盖了，所以所以导致这两个问题。 解决办法：将注册组件及其样式写到 import App from ‘./App.vue’; 前面就没问题了。 问题解决结果：完美解决！ 202102月03日 项目：祥生经营分析平台 问题描述：关于 ant-design-vue table底部合计栏。 问题起因：因为 ant-design-vue table 插槽的footer的只是一行，而没有表格的功能，但是element有，所以想参照element制作底部合计栏目 ant-design-vue table:https://www.antdv.com/components/table-cn/ element-ui table:https://element.eleme.cn/#/zh-CN/component/table#table-column-scoped-slot 解决办法：1.使用插槽给 ant-table 插进去两个footer 一个是普通footer，一个是用于fixed的footer, html代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&gt;&lt;template v-if=&quot;sumShow == true&quot; slot=&quot;footer&quot;&gt; &lt;table class=&quot;footer-table&quot; :style=&quot;&#x27;width:&#x27; + (this.scrollData.x - 0.5) + &#x27;px&#x27;&quot; &gt; &lt;colgroup&gt; &lt;!-- &lt;col style=&quot;width: 80px; min-width: 80px;&quot; /&gt;--&gt; &lt;col v-for=&quot;(item, index) in headerLists&quot; :key=&quot;index&quot; :style=&quot;colStyle(item)&quot; /&gt; &lt;/colgroup&gt; &lt;tbody class=&quot;ant-table-tbody&quot; style=&quot;position: relative&quot;&gt; &lt;tr v-if=&quot;tableDatas.length &gt; 0&quot;&gt; &lt;td v-for=&quot;(item, index) in headerLists&quot; :key=&quot;index&quot;&gt; &#123;&#123; typeof tableDatas0[item.dataIndex] == &#x27;object&#x27; ? tableDatas0[item.dataIndex].value + tableDatas0[item.dataIndex].unitValue : tableDatas0[item.dataIndex] &#125;&#125; &#123;&#123; tableDatas0[item.dataIndex].unitValue ? &#x27;&#x27; : item.scopedSlots ? item.scopedSlots.customRender : &#x27;&#x27; &#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&gt;&lt;/template&gt;&gt;&lt;template v-if=&quot;sumShow == true&quot; slot=&quot;footer&quot;&gt; &lt;table class=&quot;footer-table1&quot; :style=&quot; &#x27;width:&#x27; + (this.scrollData.x - 0.5) + &#x27;px;height:&#x27; + tableFooterHeight + &#x27;px&#x27; &quot; &gt; &lt;colgroup&gt; &lt;!-- &lt;col style=&quot;width: 80px; min-width: 80px;&quot; /&gt;--&gt; &lt;col v-for=&quot;(item, index) in headerLists&quot; :key=&quot;index&quot; :style=&quot;colStyle(item)&quot; /&gt; &lt;/colgroup&gt; &lt;tbody class=&quot;ant-table-tbody&quot; style=&quot;position: relative&quot;&gt; &lt;tr v-if=&quot;tableDatas.length &gt; 0&quot;&gt; &lt;td v-show=&quot;item.fixed&quot; v-for=&quot;(item, index) in headerLists&quot; :key=&quot;index&quot; style=&quot;background: #fafafa;&quot; &gt; &#123;&#123; typeof tableDatas0[item.dataIndex] == &#x27;object&#x27; ? tableDatas0[item.dataIndex].value + tableDatas0[item.dataIndex].unitValue : tableDatas0[item.dataIndex] &#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&gt;&lt;/template&gt;&gt;也就是和其tbody一样生成一个tfoot ， 其结构相同 2.要做到左右跟着滚动，精髓是 事件onscroll 和窗口属性scrollleft js代码： 123456789101112131415161718&gt;let wrapDiv = document.getElementsByClassName(&#x27;ant-table-body&#x27;)[0]; // 外层盒子div&gt;if (wrapDiv) &#123; wrapDiv.addEventListener(&#x27;scroll&#x27;, () =&gt; &#123; if (wrapDiv.scrollTop &gt; 20) &#123; this.toTopClickActive = true; &#125; else &#123; this.toTopClickActive = false; &#125; &#125;); if (wrapDiv.scrollTop &gt; 20) &#123; this.toTopClickActive = true; &#125; else &#123; this.toTopClickActive = false; &#125;&gt;&#125;&gt;也就是在左右滑动时获取自己的scrollleft赋值给别人 3.要做到fixed列，因为我们做了两个footer，其中一个footer就是用来fixed的，循环其headerList,来判断哪个列是要 fixed 的，需要fixed就显示出来。（我想ant-design-vue也是这一样的原理） 问题处理结果：完美解决！ 02月04日 关于在祥生经营分析平台项目总结： 1.不足： ​ 1.选用前端ui框架不合理，比如应该使用element-ui但是使用了ant-design-vue, ​ 2.echarts封装不合理，刚开始几乎是并没有封装echarts,其封装程度还停留在东鹏手机bi的水平线，所以，在最后时间不是很紧的时候，自己研究了一种更加合理的封装方案（在项目门户的投模页面的symbolicChart.vue组件中），这个封装在我看来还是比较的合理，他拥有了许多的默认配置参数。 ​ 3.与后台初步工作协商没有达成很好的一致性，导致后台返回的数据结构在前端中不能合理的使用。 学到的知识 熟悉了ant-design-vue ui框架的使用，并更加了解他与element-ui的区别，学习如何深度改装ant-design-vue的table组件，自己完成其 合计栏 的封装。 更加熟悉了echarts的封装，对其进行更加高度的封装，在项目中更加快速，高效的开发。 更加了解后台返回的数据结构怎么样才能合理的给前端去使用。 了解了服务器防火墙知识。 学会一些linux命令来上传前端包。 发现了webstorm的新大陆：断点调试，ftp上传，自带的shell命令行。 02月20日 1.问题描述：后台返回一段字符中含有&lt;br&gt;换行标签，前端需要怎么处理才能换行显示。 2.解决办法： ​ ①：将后台返回的 &lt;br&gt; 标签替换成 \\n , 使用 replace(/\\n/g,’&lt;br&gt;’) 替换。 ​ ②：如果是 vue 就使用v-html指令将其显示上去。 3.问题处理结果：完美解决！ 金地集团投资管理平台02月20日 项目：金地投资管理平台 1.关于该项目碰到的一些问题： ​ ①：客户需要用 IE 浏览器来使用采集平台，兼容IE成为一大问题。 ​ ②：文件上传集成功能在IE浏览器无效。 ​ ③：IE浏览器对 px2rem 1px转换单位不能识别。 ​ ④：IE浏览器样式较丑，后期还需要修改。 ​ 解决办法： ​ ①： ​ ②： ​ ③：使用 postcss-plugin-px2rem 插件代替 postcss-px2rem ​ ④： 2.碰到的一些小知识： ​ ①：在 api 请求实例中创建 delete 方法 ，直接创建一个名为 delete 的方法报错，原因是 delete 是关键字。 05月13日 ![](https://pics3.baidu.com/feed/908fa0ec08fa513d9ac7880a6ebb04fcb0fbd9d7.jpeg?token=b6d793ae8142658f0bf6d4030e320f26) 使用 date-fns插件技巧： 1.得到此时的三年前的时间: ​ new Date(String(new Date().getFullYear() - 3) + this.$format(new Date(), ‘-MM’)) ​ 原理是获取当前年减去 3 ，再拼接月份和日期等等； 05月18日 在 IE 浏览器碰到的代码执行顺序的问题； 场景描述： 在请求删除表格数据接口 deleteData（异步操作）之后调用请求当前数据接口 getData ; ​ 在除了 IE 浏览器中可以不在 deleteData 的异步成功回调 then 函数调用 getData,也可以加载数据，但是在 IE 浏览器中，一定需要到 deleteData 的回调函数调用 getData 获取数据才能重新渲染； 得出结论：IE 浏览器对代码执行顺序较为严格，因为 js 是单线程的，要延后一段代码的执行就不能写成并行执行的代码； 06月01日 学到的东西： 最好提前写好全局样式供后期使用； 比如写好一个 layout 全局样式用来布局； 写好一个弹窗样式用来布局； 写好多个主题的 表格 用来使用； 写好时间选择器的样式用来布局（时间选择器可以用组件封装一遍再投入使用，因为很多默认时间会是一样的）； 最好使用全局变量来做 echarts 图的 字体颜色，字体大小，背景颜色配置；这样对后期维护更加友好； 碰到相同的页面可以抽离成组件进行使用，碰到相似的页面可以将 数据data,方法methods 等等抽离成混入 mixin 代码使用； 06月02日 new Date(‘2015-5’)在IE浏览器会转化成 invalida Date , 需要协会曾规范的形式new Date(‘2015-05’)才能正常转化； 06月04日 问题描述： input file 文件上传，在第一次上传文件触发 change 事件之后，下次再 上传文件 将不会触发 change 事件； 解决办法：将这个 input dom元素刷新一遍； 具体方法： 1. 将这个 dom 删除，再克隆一个新的 dom 出来供使用； ​ 2.在 vue 中可以使用 v-if ，将其 show 设置为 false ,再设置为true; 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;input v-if&#x3D;&quot;fileShow&quot; @change&#x3D;&#39;changeFile&#39; &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default&#123; data()&#123; return &#123; fileShow:true &#125; &#125;, methods:&#123; reload()&#123; this.fileShow &#x3D; false; this.$nextTick(()&#x3D;&gt;&#123; this.fileShow &#x3D; true &#125;) &#125;, changeFile()&#123; console.log(&#39;触发change事件&#39;) &#x2F;&#x2F; 做完其他操作刷新该 dom , 这样下次还会触发该change事件 this.reload(); &#125; &#125; &#125;&lt;&#x2F;script&gt; 07月13日 企业微信开启调试模式访问https://work.weixin.qq.com/api/doc/90000/90139/90315#%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1Windows%E7%89%88%E6%9C%AC%E8%B0%83%E8%AF%95 把 devtools_resources.pak 放到企业微信的安装目录下（复制的文件名，要保证为 devtools_resources.pak），注意安装目录带有版本号（4.0.1304.400是浏览器内核的版本号）； 关闭企业微信，重新启动； 按快捷键 ctrl + alt + shift + D，进入调试模式； 即可开启调试模式，关闭操作与开启操作相同； 07月26日 表格在 IE 中使用了 position: relative 会失去边框 09月26日 自定义虚线边框 background: repeating-linear-gradient(90deg, #ccc, #ccc 1.5em, transparent 0, transparent 4em); 90 deg为虚线左右边倾斜度 #ccc 为虚线颜色 1.5rem 为单个虚线长度 4rem 为虚线密度 09月30日 tail -f xxx.log 查看 tomcat 实时日志(找到 /logs 文件夹下面) 智扬云平台产品10月08日 关于使用在 react 中使用 px2rem 自适应插件 步骤： npm install postcss-plugin-px2rem lib-flexible –save-dev 在 config-overrides.js 中引用使用 1234567891011121314151617181920const px2rem = require(&#x27;postcss-plugin-px2rem&#x27;);module.exports = override( (config, env) =&gt; &#123; // 重写postcss rewirePostcss(config, &#123; plugins: () =&gt; [ //关键:设置px2rem px2rem(&#123; rootValue: 192, mediaQuery: false, // （布尔值）允许在媒体查询中转换px。 minPixelValue: 2, // 设置要替换的最小像素值(3px会被转rem)。 默认 0 exclude: /node-modules/ &#125;) ], &#125;); return config &#125;); 在 main.js 入口文件引入 lib-flexible.js 自适应工具类； 10月09日 create-react-app IE11 无法运行 793e9b9739ce关注 2021.03.29 17:24:19字数 111阅读 65 背景项目使用create-react-app、typescript创建，ie11下报‘语法错误’ 解决方案1、安装react-app-polyfill 1&gt;npm install react-app-polyfill 在src/index.tsx的最顶部引入 12&gt;import &#39;react-app-polyfill&#x2F;ie11&#39;;&gt;import &#39;react-app-polyfill&#x2F;stable&#39;; 3、在packge.json文件下 browserlist 添加ie11 1234567891011121314&gt;&quot;browserslist&quot;: &#123; &quot;production&quot;: [ &quot;&gt;0.2%&quot;, &quot;not dead&quot;, &quot;not op_mini all&quot;, &quot;ie 11&quot; ], &quot;development&quot;: [ &quot;last 1 chrome version&quot;, &quot;last 1 firefox version&quot;, &quot;last 1 safari version&quot;, &quot;ie 11&quot; ] &#125; 4、 重启。否则删除node_modules文件夹下的内容重新安装 参考https://github.com/facebook/create-react-app/blob/master/packages/react-app-polyfill/README.md 然而你以为你解决了吗，不!!!!!!!!!!!!!,虽然可以显示了，但是浏览器会直接卡死 这时就不要引入 react-app-polyfill 了（注释掉） 而是下载 babel-ployfill 和上述一样引入，方可解决 10月20日 关于使用 react 做项目： 熟悉其 state 和 生命周期 ： constructor state 定义的数据存放 defaultProps props 默认值 componentDidMountshouldComponentUpdatecomponentWillUnmountcomponentDidCatchgetSnapshotBeforeUpdatecomponentDidUpdatecomponentWillMountUNSAFE_componentWillMountcomponentWillReceivePropsUNSAFE_componentWillReceivePropscomponentWillUpdateUNSAFE_componentWillUpdate render 渲染函数 使用 react 封装一个组件： 12345678910111213141516class WaveLoading extends Component &#123; state = &#123;&#125;; render() &#123; return ( &lt;div className=&quot;waveLoading&quot;&gt; &lt;div className=&quot;sk-wave&quot;&gt; &lt;div className=&quot;sk-wave-rect&quot;&gt;&lt;/div&gt; &lt;div className=&quot;sk-wave-rect&quot;&gt;&lt;/div&gt; &lt;div className=&quot;sk-wave-rect&quot;&gt;&lt;/div&gt; &lt;div className=&quot;sk-wave-rect&quot;&gt;&lt;/div&gt; &lt;div className=&quot;sk-wave-rect&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 组件间传值及方法调用： 通过 props 进行传值 1234567891011121314151617181920212223242526272829class Template extends Component &#123; constructor(props) &#123; // 一定写这个 super(props); // state 可以写在外面 this.state = &#123; trBottomShadow: false, borderColor: &quot;#133653&quot;, &#125;; &#125; state = &#123; trBottomShadow: false, borderColor: &quot;#133653&quot;, &#125; // 子组件通信数据的默认值 static defaultProps = &#123; tableData: [], headerList: [], headerListFather: [], height: &quot;90%&quot;, loading: true, className: &quot;&quot;, &#125;;&#125;&lt;Son tableData=&#123;tableData&#125;&gt;&lt;/Son&gt; 子组件向父组件发送事件 123456789101112131415161718192021222324252627282930313233343536373839// 子组件定义class Button extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; &#125;; &#125; static defaultProps = &#123; clickEvent: (index) =&gt; &#123;&#125;, &#125;; render() &#123; return ( &lt;button onclick=&#123;this.props.clickEvent.bind(null)&#125;&gt;&lt;/button&gt; ) &#125;&#125;// 父组件调用class Father extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; &#125;; &#125; clickEvent = () =&gt; &#123; // 点击事件代码 &#125; render() &#123; return ( &lt;Button rowSelect=&#123;this.clickEvent&#125; &gt;&lt;/Button&gt; ) &#125;&#125; 父组件调用子组件的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 子组件定义class Son extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; &#125;; &#125; drawChart = () =&gt; &#123; // 画图方法 &#125; render() &#123; return ( &lt;button onclick=&#123;this.props.clickEvent.bind(null)&#125;&gt;&lt;/button&gt; ) &#125;&#125;// 父组件调用class Father extends Component &#123; constructor(props) &#123; super(props); if (props.onRef) &#123; //如果父组件传来该方法 则调用方法将子组件this指针传过去 props.onRef(this); &#125; this.state = &#123; &#125;; &#125; componentDidMount() &#123; // 在 this 中可以得到 sonRef 这个 this.sonRef.drawChart(); &#125; clickEvent = () =&gt; &#123; // 点击事件代码 &#125; render() &#123; return ( &lt;Son onRef=&#123;(ref) =&gt; (this.sonRef = ref)&#125;&gt; &lt;/Son&gt; ) &#125;&#125; ​ ​ 11月22日 问题描述：关于复杂二级表头展示成后台返回的第一条数据问题 ![lALPJv8gRRaQjDXM-80GnA_1692_251](D:\\studyData\\2020年\\1202 - hexo博客\\blog1202\\source\\img\\lALPJv8gRRaQjDXM-80GnA_1692_251.png) 解决办法： 表头套表头+设置colspan+render-header 11月23日 问题描述：关于大项目交接给他人会碰到的问题⭐ 问题详细： 1. 客户会问代码怎么运行，比如企业微信内部应用这种。 2. 客户会问你环境怎么搭建，需要哪些环境和编辑器，比如 nodejs ，visual studio code。 3. 客户会问生产发版注意事项。 4. 客户会问发版时的服务器地址和目录。 5. 客户会让你演示一遍权限怎么去配置。 6. 最后，交接文档需要把客户首先要问的写的显眼一点。 12月2日 问题起因：关于证书在移动端无效问题 问题描述： 1. 此证书并非来自可信的授权中心 解决办法： ​ 1.访问网站查询该证书是否有效：https://myssl.com/ssl.html ⭐小知识描述：关于多位数滚动组件封装 ​ 1.思路，准备1-10的标签； ​ 2.竖起来排布，根据传回来的数字设置定位的 top 值； ​ 3.添加 animation 动画； 代码：(React 组件) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&gt;/* eslint-disable */&gt;import React, &#123; Component &#125; from &quot;react&quot;;&gt;import * as echarts from &quot;echarts&quot;;&gt;import &quot;./index.less&quot;;&gt;class CutProgressChart extends Component &#123; constructor(props) &#123; super(props); if (props.onRef) &#123; //如果父组件传来该方法 则调用方法将子组件this指针传过去 props.onRef(this); &#125; &#125; static defaultProps = &#123; bindRefs: &quot;cutProgressChart&quot;, styles: &#123; width: &quot;100%&quot;, height: &quot;10px&quot; &#125;, show: true, progressData: 0, &#125;; state = &#123; myChart: null, oprion: &#123;&#125;, &#125;; componentDidMount = () =&gt; &#123; if (this.refs[this.props.bindRefs]) &#123; this.state.myChart = echarts.init(this.refs[this.props.bindRefs]); &#125; &#125;; drawChart = () =&gt; &#123; const &#123; bindRefs, progressData &#125; = this.props; let &#123; option, myChart &#125; = this.state; if (this.refs[bindRefs]) &#123; option = &#123; xAxis: &#123; splitLine: &#123; show: false, &#125;, axisLabel: &#123; show: false, &#125;, axisTick: &#123; show: false, &#125;, axisLine: &#123; show: false, &#125;, &#125;, grid: &#123; top: 0, left: -9, right: 0, bottom: 0, containLabel: true, &#125;, yAxis: [ &#123; show: false, axisLine: &#123; show: false, &#125;, axisTick: &#123; show: false, &#125;, data: [&quot;&quot;], &#125;, ], series: [ &#123; //内 type: &quot;bar&quot;, barWidth: 18, legendHoverLink: false, symbolRepeat: true, silent: true, itemStyle: &#123; color: &#123; type: &quot;linear&quot;, x: 0, y: 0, x2: 1, y2: 0, colorStops: [ &#123; offset: 0, color: &quot;#B6D9F9&quot;, // 0% 处的颜色 &#125;, &#123; offset: 1, color: &quot;#54BCF9&quot;, // 100% 处的颜色 &#125;, ], &#125;, &#125;, data: [progressData], z: 1, &#125;, &#123; //分隔 type: &quot;pictorialBar&quot;, itemStyle: &#123; color: &quot;#1d2f4f&quot;, &#125;, symbolRepeat: &quot;fixed&quot;, symbolMargin: 2, symbol: &quot;roundRect&quot;, symbolClip: true, symbolSize: [2, 18], symbolPosition: &quot;start&quot;, symbolOffset: [0, 0], data: [100], z: 2, animationEasing: &quot;elasticOut&quot;, &#125;, ], &#125;; myChart.setOption(option); &#125; // echarts图随着窗口的大小变化而变化 window.addEventListener(&quot;resize&quot;, () =&gt; &#123; if (myChart) myChart.resize(); &#125;); &#125;; state = &#123;&#125;; render() &#123; return ( &lt;div className=&quot;cutProgressChart&quot; style=&#123;this.props.styles&#125;&gt; &#123;this.props.show ? ( &lt;div className=&quot;chart-wrap&quot;&gt; &lt;div ref=&#123;this.props.bindRefs&#125; style=&#123;&#123; width: &quot;100%&quot;, height: &quot;100%&quot; &#125;&#125; &gt;&lt;/div&gt; &lt;/div&gt; ) : ( &lt;div className=&quot;no-data&quot;&gt; &lt;a&gt;暂无数据&lt;/a&gt; &lt;/div&gt; )&#125; &lt;/div&gt; ); &#125;&gt;&#125;&gt;export default CutProgressChart; 12月16日 问题描述：element 表格自定义提示框会和表格本身固定列冲突导致表格固定列错位 202003月25日 问题描述：使用 scss 换肤 解决办法： 通过改变 body[data-theme=’variable’]，实现一键切换主题，variable就是主题的名称，比如 body[data-theme=’yuexiu-orange’]。 新建一个theme.scss文件存放主题变量 1234567891011121314151617181920212223242526// 这里我们有三种主题$themes:( yuexiu-orange:( menuText:#fff, menuActiveText:#409EFF, subMenuActiveText:#f4f4f5, // https://github.com/ElemeFE/element/issues/12951 menuBg:#FA8D19, menuHover:#FA8D19, subMenuBg:#fa7e19, subMenuHover:#fa7e19, tagViewBgActive:#fa7e19a8, ), business-black:( menuText:#bfcbd9, menuActiveText:#409EFF, subMenuActiveText:#f4f4f5, // https://github.com/ElemeFE/element/issues/12951 menuBg:#2B2E35, menuHover:#001528, subMenuBg:#151618, subMenuHover:#001528, tagViewBgActive:#4D565F, ), sat-blue:()) 新建一个处理变量的scss处理文件 123456789101112131415// 引入变量@import &#x27;./theme.scss&#x27;;@mixin themeify &#123; @each $theme-name, $theme-map in $themes &#123; $theme-map: $theme-map !global; body[data-theme=#&#123;$theme-name&#125;] &amp; &#123; @content; &#125; &#125;&#125; @function themed($key) &#123; @return map-get($theme-map, $key);&#125; 使用： 手动引入使用： 12345678@import &#x27;~@assets/theme/_themeify.scss&#x27;; .app-home &#123; font-size: 18px; @include themeify &#123; color: themed(&#x27;text-color-primary&#x27;); &#125;&#125; 2. 建议：使用 [sass-resources-loader](https://www.npmjs.com/package/sass-resources-loader) 全局引入（使用该方法后你可以不再每个地方手动引入，更加快捷方便高效） 1234567891011121314151617// vue.config.js中配置const path = require(&#x27;path&#x27;);module.exports = &#123; chainWebpack: (config) =&gt; &#123; const oneOfsMap = config.module.rule(&#x27;scss&#x27;).oneOfs.store; oneOfsMap.forEach(item =&gt; &#123; item .use(&#x27;sass-resources-loader&#x27;) .loader(&#x27;sass-resources-loader&#x27;) .options(&#123; // 也可以选择全局变量路径数组, 如果你有多个文件需要成为全局,就可以采用这种方法 resources: [path.resolve(__dirname, &#x27;src/styles/theme/handler_theme.scss&#x27;)] &#125;) .end() &#125;) &#125;,&#125;; 最后就回到了第一步，给根节点 body 加上 data-theme 属性 body[data-theme=’yuexiu-orange’]，data-theme 这个名字可以自己取，要切换属性不用我多说了吧 document.setAttribute(‘data-theme’, 你的主题名字) 04月13日 问题描述：vue dom渲染树状（嵌套）数组数据 解决办法： 定义一个组件循环这个数组的最外层 在将这个组件在自己的内部使用一次循环第二层达到递归效果，注意自己的组件名字和name要一模一样 123456789101112131415161718192021222324252627282930&gt;&lt;template&gt;&lt;div v-for&#x3D;&quot;(item,index) in list&quot; :key&#x3D;&quot;String(index)&quot;&gt; &lt;!--自己内部调用一次--&gt; &lt;nest&#x2F;&gt; &lt;&#x2F;div&gt;&gt;&lt;&#x2F;template&gt;&gt;&lt;script&gt; export default &#123; name:&#39;nest&#39; data()&#123; return &#123; list:[ &#123; label:&quot;第一层&quot;, children:[ &#123; label:&#39;第二层&#39;, children:[ &#123; label:&#39;第三层&#39; &#125; ] &#125; ] &#125; ] &#125; &#125; &#125;&gt;&lt;&#x2F;script&gt; 04月21日 问题描述：门户master-v2,0分支代码在ie浏览器空白问题 问题起因： swiper@8版本过高，换成了 swiper@3 和vue-awesome-swiper@3 代替其使用 12&gt;import &#x27;swiper/dist/css/swiper.css&#x27;;&gt;import &#123; swiper, swiperSlide &#125; from &#x27;vue-awesome-swiper&#x27;; @antv-x6需要做配置操作来兼容IE浏览器,配置如下： 该选项默认值是 []，说明会忽略掉所有掉 nodemodules 文件，不会对 nodemodules 里面对文件做 Babel。我们需要做的就是把我们希望 Babel 的文件加入即可，代码如下。需要注意的是我们加入的依赖不需要包含 node_modules ，用包名 @antv/g6即可，因为 @vue/cli 会自动添加前缀 nodemodules 。还需要注意 @antv/g6 必须和 package.json 里面的一致。安装依赖的时候首选 npm ，如果你用 yarn、cnpm 等安装，需要确保 nodemodules 里面的包名没有被更改。 123module.exports = &#123; transpileDependencies: [&#x27;@antv/g6&#x27;],&#125;; ​ 2.最开始的那个报错解决了，但出现了新问题。先用 Chrome 浏览器看看，发现问题是一样的。添加完 transpileDependencies 兼容性问题是没有了，但出了个新错误。再次查看官网，并没有相关文章，那就直接移步 issue 吧。经过一番查找，我们找到如下解决方案，在 babel.config.js 里面添加上 sourceType: &quot;unambiguous&quot; ，具体含义可以官网查阅。 1234&gt;module.exports = &#123; sourceType: &#x27;unambiguous&#x27;, presets: [&#x27;@vue/cli-plugin-babel/preset&#x27;],&gt;&#125;; 06月16日 问题描述：node-sass在 node-v16版本 报错兼容性差（将node-sass换成dart-sass） 问题起因：因为sass官方在nide-v14版本以后使用dart-sass代替了node-sass,node-sass要依靠电脑底层C++语言进行编译，兼容性较差，sass官方便使用了dart-sass以虚拟的sass形式最后编译成css文件，这样不仅兼容性好且性能高 解决办法： 将nodejs版本换到16以上 卸载node-sass sass-loader sass (npm uninstall node-sass sass-loader sass) 再安装新的 sass-loader sass (npm install sass-loader sass -D) 注意sass-loader要下载^10.1.1这一步才能成功，不然会报错 this.getOption is not a function错误 更新vue.config.js文件 12345678910// vue.config.jsmodule.exports = &#123; css: &#123; loaderOptions: &#123; sass: &#123; implementation: require(&#x27;sass&#x27;), // This line must in sass option &#125;, &#125;, &#125;&#125; 重启项目，如果node-gyp报错就全局安装更新 (npm install node-gyp -g) 如果报Rule can only have one resource source (provided resource and test + include + exclude) in，就安装 (npm install webpack@^4.0.0 –save-dev)注意sass-loader要下载^10.1.1这一步才能成功，不然会报错 this.getOption is not a function错误 如果 vue.config中的 sass prependData报错 1 就修改 原来的 1234567css: &#123; loaderOptions: &#123; sass: &#123; prependData: `@import &quot;~@/styles/variables.scss&quot;;` &#125; &#125; &#125; 修改后的 1234567css: &#123; loaderOptions: &#123; sass: &#123; additionalData: `@import &quot;~@/styles/variables.scss&quot;;` &#125; &#125; &#125; 如果 sass /deep/ 报错 就把 /deep/ 换成 ::v-deep 不出意外就可以正常运行了 2022华星光电06月16日 问题描述：axios 请求地址带上了路由的地址导致请求失败 问题起因：是因为baseUrl地址的协议 ip 端口没写会自动加上路由的地址 问题解决：axios 的拦截器baseUrl加上协议 ip 端口 解决办法不合理，会导致ipv4地址不能注册到axios中 06月30日 问题描述：input添加输入框记忆功能 问题解决：input 加上autocomplete=’on’ 和 name=’name’(每个输入框的name都不一样才能识别)","categories":[],"tags":[{"name":"智扬信达","slug":"智扬信达","permalink":"https://1314xulujin.github.io/tags/%E6%99%BA%E6%89%AC%E4%BF%A1%E8%BE%BE/"}]},{"title":"廖哥哥在工作中遇到的问题","slug":"廖哥哥工作中遇到的问题","date":"2020-07-17T05:31:29.000Z","updated":"2021-08-20T07:21:25.521Z","comments":true,"path":"2020/07/17/廖哥哥工作中遇到的问题/","link":"","permalink":"https://1314xulujin.github.io/2020/07/17/%E5%BB%96%E5%93%A5%E5%93%A5%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"常用方法：1. 手动上传文件整个校验过程(带进度条)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135 &lt;el-upload ref=&quot;refs&quot; class=&quot;upload-demo&quot; action=&quot;UploadUrl()&quot; :on-change=&quot;increaseHandleChange&quot; :before-remove=&quot;increaseHandleRemove&quot; :limit=&quot;limitNum&quot; :fileList=&quot;increaseStauts.incrsessionStorageeaseFileList&quot; :auto-upload=&quot;false&quot; :on-exceed=&quot;increaseExceedFile&quot; :on-success=&quot;increaseHandleSuccess&quot; :on-error=&quot;increaseHandleError&quot; &gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot; :disabled=&quot;increaseStauts.isDisabled&quot; &gt;导入Excel&lt;/el-button &gt; &lt;el-button type=&quot;text&quot; @click=&quot;increaseDownloadFile&quot; &gt;下载模板&lt;/el-button &gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传后缀为.xslx的文件&lt;/div&gt; &lt;/el-upload&gt; &lt;div v-if=&quot;progressSeen&quot;&gt; &lt;el-progress :percentage=&quot;progress&quot;&gt;&lt;/el-progress&gt; &lt;/div&gt;data()&#123; return&#123; progress: 0, // 进度条百分比 progressSeen: false, // 是否显示进度条 &#125;&#125;// 文件改变时的校验 increaseHandleChange(file, fileList) &#123; this.emptyData(); this.increaseStauts.increaseFileList.push(file.raw); // 上传文件之前做前端校验 let extension = file.name.substring(file.name.lastIndexOf(&quot;.&quot;) + 1); if (extension !== &quot;xlsx&quot;) &#123; this.increaseStauts.increaseFileList = []; this.$message.error(&quot;只能上传后缀是.xlsx的文件&quot;); &#125; &#125;, // 文件超出个数限制时的钩子 increaseExceedFile(files, fileList) &#123; this.$message.error( `只能选择 $&#123;this.limitNum&#125; 个文件，当前共选择了 $&#123; files.length + fileList.length &#125; 个` ); &#125;, // 文件列表移除文件时的钩子 increaseHandleRemove(file, fileList) &#123; return this.$confirm(`确定移除 $&#123;file.name&#125;？`) .then(() =&gt; &#123; this.$message(&#123; type: &quot;success&quot;, message: &quot;删除成功!&quot;, &#125;); this.increaseStauts.increaseFileList = []; this.progress = 0; this.progressSeen = false; &#125;) .catch(() =&gt; &#123; this.$message(&#123; type: &quot;info&quot;, message: &quot;已取消删除!&quot;, &#125;); reject(false); &#125;); &#125;, // 文件上传失败时的钩子 increaseHandleError(err, file, fileList) &#123; this.$message.error(&quot;文件上传失败!&quot;); &#125;, // 文件上传成功时的钩子 increaseHandleSuccess(res, file, fileList) &#123; this.$message.success(&quot;文件上传成功!&quot;); &#125;, // 点击保存上传文件 increaseUploadFile() &#123; if (this.increaseStauts.increaseFileList.length === 0) &#123; this.$message.error(&quot;请导入Excel上传文件!&quot;); &#125; else &#123; //显示进度 this.progressSeen = true; let form = new FormData(); // 创建对象 form.append(&quot;file&quot;, this.increaseStauts.increaseFileList[0]); // 添加值 // form.append(&quot;file&quot;, this.increaseStauts.increaseFileList[1]); // 可继续添加单个传送 // form.append(&quot;data&quot;, JSON.stringify(this.increaseStauts.increaseFileList[3])); // 也转成对象 this.$axios(&#123; method: &quot;post&quot;, url: `$&#123;baseUrl&#125;/pos/usage/uploadExcel`, headers: &#123; &quot;Content-type&quot;: &quot;multipart/form-data&quot;, &#125;, data: form, onUploadProgress: (progressEvent) =&gt; &#123; var complete = ((progressEvent.loaded / progressEvent.total) * 100) | 0; this.progress = complete; &#125;, &#125;).then( (res) =&gt; &#123; this.increaseHandleSuccess(); console.log(&quot;文件上传成功!&quot;, res); let resdata = res.data.data; this.increaseStauts.increase_a = true; this.increaseStauts.successCount = resdata.successCount; if (resdata.failCount &gt;= 1) &#123; this.increaseStauts.failCount = resdata.failCount; this.increaseStauts.msg = resdata.message; this.increaseStauts.data = resdata.data; this.increaseStauts.increase_b = true; &#125; &#125;, (err) =&gt; &#123; this.increaseHandleError(); this.increaseStauts.increase_b = true; this.increaseStauts.comeFileList.push(err); &#125; ); &#125; &#125;, // 因为action参数是必填项，二次确认进行文件上传时，直接填上传文件的url会因为没有参数导致api报404，所以这里将action设置为一个返回为空的方法就行，避免抛错 UploadUrl: function () &#123; return &quot;&quot;; &#125;, // 重新上传 handleChange(file, fileList) &#123; this.increaseHandleChange(file, fileList); &#125;, 2. 下载模板1. 寻常下载123可用windown.open(&quot;接口名称&quot;?=&quot;可带参数&quot;);window.open(`$&#123;process.env.VUE_APP_BASE_API&#125;/quote/export?$&#123;qs.stringify(params)&#125;`); 2. 创建a标签下载后端返回的2进制流1234567891011121314151617181920212223242526272829303132333435363738394041424344 // 下载失败清单 export function downloadList(params) &#123; let uri = baseUrl + `/pos/usage/downloadFailTemplate`; return fetch2(&#123; url: uri, method: &#x27;post&#x27;, data: params, responseType: &quot;blob&quot; &#125;) &#125; api.downloadList(params).then((res) =&gt; &#123; const blob = new Blob([res], &#123; type: &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8&quot;, &#125;); let aParts = document.createElement(&quot;a&quot;); aParts.href = window.URL.createObjectURL(blob); aParts.download = &quot;失败清单.xlsx&quot;; aParts.click(); window.URL.revokeObjectURL(aParts.href); &#125;);// 自用封装 inventoryDownloadRemove(url, params, name) &#123; this.$axios(&#123; url: baseUrl + url, method: &quot;post&quot;, data: params, responseType: &quot;blob&quot;, headers: &#123; &quot;X-Token&quot;: &quot;&quot; &#125;, // 每个接口带的token &#125;).then(res =&gt;&#123; console.log(res.data); const blob = new Blob([res.data], &#123; type: &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8&quot;, &#125;); let aParts = document.createElement(&quot;a&quot;); aParts.href = window.URL.createObjectURL(blob); aParts.download = `$&#123; name &#125;.xlsx`; aParts.click(); window.URL.revokeObjectURL(aParts.href); &#125;) &#125; 3. 自用封装前后时间对比方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;el-form-item label=&quot;导入日期：&quot;&gt; &lt;el-col :span=&quot;11&quot;&gt; &lt;el-date-picker type=&quot;date&quot; placeholder=&quot;选择日期&quot; v-model=&quot;form.starttime&quot; @change=&quot;taskStartChange&quot; value-format=&quot;yyyy-MM-dd&quot; style=&quot;width: 100%;&quot; &gt;&lt;/el-date-picker&gt; &lt;/el-col&gt; &lt;el-col class=&quot;line flex-row-center-center&quot; :span=&quot;2&quot;&gt;至&lt;/el-col&gt; &lt;el-col :span=&quot;11&quot;&gt; &lt;el-date-picker type=&quot;date&quot; placeholder=&quot;选择日期&quot; v-model=&quot;form.endtime&quot; @change=&quot;taskEndChange&quot; value-format=&quot;yyyy-MM-dd&quot; style=&quot;width: 100%;&quot; &gt;&lt;/el-date-picker&gt; &lt;/el-col&gt; &lt;/el-form-item&gt;// 封装element时间前后选择对比 isStartGreaterEnd(start, end) &#123; let _this = this; if (start &amp;&amp; end) &#123; let starDate = new Date(start); let endDate = new Date(end); // 有三种方式获取 if (starDate.getTime() - endDate.getTime() &gt; 0) &#123; _this.$message(&#123; message: &quot;开始时间不能大于结束时间&quot;, type: &quot;error&quot;, &#125;); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125;, taskStartChange(val) &#123; if (this.isStartGreaterEnd(this.form.starttime, this.form.endtime)) &#123; this.form.starttime = &quot;&quot;; &#125; &#125;, taskEndChange(val) &#123; if (this.isStartGreaterEnd(this.form.starttime, this.form.endtime)) &#123; this.form.endtime = &quot;&quot;; &#125; &#125;, 4. 基于element穿梭框1234567891011121314151617181920212223242526272829303132333435 &lt;el-transfer filterable filter-placeholder=&quot;请输入姓名或者人员代码&quot; v-model=&quot;increaseData&quot; :data=&quot;icData&quot; :props=&quot;&#123; key: &#x27;userId&#x27;, label: &#x27;userName&#x27; &#125;&quot; :titles=&quot;[&#x27;人员列表&#x27;, &#x27;已选人员列表&#x27;]&quot; :button-texts=&quot;[&#x27;移除&#x27;, &#x27;添加&#x27;]&quot; @change=&quot;handleChange&quot; v-loading=&quot;increaseDataisloading&quot; &gt;&lt;/el-transfer&gt;// 左右数据互动handleChange(value, direction, movedKeys) &#123; if (direction === &quot;right&quot;) &#123; for (var j in movedKeys) &#123; console.log(movedKeys[j]); this.icData.forEach((item, index) =&gt; &#123; if (item.userId == movedKeys[j]) &#123; this.userId.push(item); &#125; &#125;); &#125; &#125; if (direction === &quot;left&quot;) &#123; for (var i in movedKeys) &#123; console.log(movedKeys[i]); this.userId.forEach((item, index) =&gt; &#123; if (item.userId == movedKeys[i]) &#123; this.userId.splice(index, 1); &#125; &#125;); &#125; &#125; &#125;, 5. 对象全空判断1234567891011121314151617181920212223242526272829303132333435// 有一项有值就为true let arr = 0; for (const key in this.form) &#123; if (this.form[key] != &quot;&quot;) &#123; arr++; &#125; &#125; if(arr)&#123; // 不为空 &#125;esle&#123; // 为空 &#125;// 封装的判断对象里面某个值是否为空whetherFreeValue(params) &#123; let flag = true; for (var key in params) &#123; if (params[key] != &quot;0&quot; &amp;&amp; !params[key]) &#123; return false; // 终止程序 &#125; &#125; return flag; &#125;// 判断全空 有一项为空就返回for(let i in this.conditions) &#123; if(!this.conditions[i]) &#123; this.$message.error(&#x27;请填写完整信息！&#x27;); return; &#125; &#125; 6. 自定义权重排序12345678910111213let statusRank = &#123; 1: 1, 2: 2, 3: 4, 4: 3, &#125;;// res.data.list.sort((a, b) =&gt; (b.submitflag &gt; a.submitflag ? -1 : 1)); // 双重排序 另外一个值也需要排序res.data.list.forEach((item) =&gt; &#123; item.statusRank = statusRank[item.status]; &#125;);res.data.list.sort((a, b) =&gt; (b.statusRank &gt; a.statusRank ? -1 : 1 )); // 降序// res.data.list.sort((a, b) =&gt; b.statusRank - a.statusRank); // 升序 7. 根据状态改变单元格样式1234567891011// 根据状态改变单元格字体样式 addClass(&#123; row, column, rowIndex, columnIndex &#125;) &#123; if (columnIndex === 9) &#123; if (row.status == &quot;待扣罚&quot; || row.status == &quot;1&quot;) &#123; return &quot;cell-red&quot;; &#125; if (row.status == &quot;待返还&quot; || row.status == &quot;3&quot;) &#123; return &quot;cell-grey&quot;; &#125; &#125; &#125;, 8. 抄袭一段别人封装的WebSoket方法（目前还没弄懂）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168import store from &#x27;../store&#x27;import &#123; get &#125; from &#x27;tinymce&#x27;;var websock = null;var global_callback = null; var countTime=2*60*1000; //访问时间间隔var sendcurrCount=0; var sendCount=5; //重连总次数var closeCurrCount=0; //当前重连的次数var closeCount=5; var cTotalCount=0;var totalCount=2; var reconnectTime=10*60*1000; //重连时间段// var intelvalTime=5*1000; //重连间隔时间（s）// var cycleTime=1*60*1000; //时间周期const getWebIP=()=&gt;&#123; let protocol=&#x27;ws://&#x27;; if(window.location.protocol.indexOf(&#x27;https&#x27;)==0)&#123; protocol=&#x27;wss://&#x27;; &#125; return protocol+window.location.host //return &quot;ws://58.1.39.62:8080&quot;&#125;//连接weosocket并初始化const initWebSocket=()=&gt;&#123; if (&quot;WebSocket&quot; in window)&#123; if(websock!=null)&#123; websock.close(1000,&#x27;正常关闭&#x27;); &#125; //ws地址 //var wsurl = `$&#123;getWebIP()&#125;/picc-stfinance/ws?PICC-Authorization=374837483748348`; var wsurl = `$&#123;getWebIP()&#125;/picc-stfinance/ws?PICC-Authorization=$&#123;store.getters.token&#125;`; websock = new WebSocket(wsurl); websock.onmessage = function(e) &#123; // 上一次接收消息的时间 //upTime=new Date().getTime(); websocketonmessage(e); &#125; websock.onclose = function(e) &#123; websocketclose(e); &#125; websock.onopen = function() &#123; websocketOpen(); &#125; //连接发生错误的回调方法 websock.onerror = function() &#123; console.log(&quot;WebSocket连接发生错误&quot;); &#125; &#125;else&#123; alert(&quot;您的浏览器不支持WebSocket!&quot;); &#125; &#125;// websocket心跳机制，防止连接断开const heartbeat=()=&gt;&#123; if(window.timer)&#123; //console.log(&#x27;window.timer=====2&#x27;); &#125;else&#123; //console.log(&#x27;window.timer=====1&#x27;); window.timer = window.setInterval(sendSock, countTime); &#125;&#125; // 实际调用的方法(数据发送)const sendSock=(agentData=&#x27;&#x27;,callback=null)=&gt;&#123; global_callback = callback; if (websock.readyState === websock.OPEN) &#123; //若是ws开启状态 console.log(&#x27;close-------1&#x27;); websocketsend(agentData); &#125;else if (websock.readyState === websock.CONNECTING) &#123; // 若是 正在开启状态，则等待1s后重新调用 console.log(&#x27;close-------2&#x27;); setTimeout(function () &#123; sendSock(agentData,callback); &#125;, 5000); &#125;else &#123; console.log(&#x27;close-------3&#x27;); if(sendcurrCount&lt;sendCount)&#123; sendcurrCount++; initWebSocket(); // 若未开启 ，则等待1s后重新调用 setTimeout(function () &#123; sendSock(agentData,callback); &#125;, 5000); &#125; &#125;&#125;//主动关闭web Socketconst closeSock=()=&gt;&#123; // if(window.timer)&#123; // window.clearInterval(window.timer); // &#125; if(websock)&#123; websock.close(1000,&#x27;正常关闭&#x27;); &#125;&#125; //数据接收const websocketonmessage=(e)=&gt;&#123; console.log(&#x27;websocketonmessage-------&#x27;); console.log(JSON.parse(e.data)); let data=JSON.parse(e.data); if(data.type==&#x27;stfinance.sys.messagebox&#x27;)&#123; store.commit(&#x27;setBoxMessage&#x27;, data.data); &#125; if(data.type==&#x27;stfinance.sys.token&#x27;)&#123; store.commit(&#x27;setToken&#x27;, data.data); &#125; //if(data.type==&#x27;close_client&#x27;)&#123; //closeSock(); //&#125; // if(global_callback&amp;&amp;global_callback instanceof Function)&#123; // console.log(&#x27;websocketonmessage+++++++&#x27;); // global_callback(JSON.parse(e.data)); // &#125;&#125; //数据发送const websocketsend=(agentData)=&gt;&#123; websock.send(agentData); //websock.send(JSON.stringify(agentData));&#125; //关闭const websocketclose=(e)=&gt;&#123; console.log(&quot;connection closed (&quot; + e.code + &quot;)&quot;); if(e.code!=&#x27;1000&#x27;)&#123; if(closeCurrCount&lt;closeCount&amp;&amp;cTotalCount&lt;totalCount)&#123; setTimeout(() =&gt; &#123; closeCurrCount++; initWebSocket(); &#125;, 5000); &#125;else if(closeCurrCount&gt;=closeCount&amp;&amp;cTotalCount&lt;totalCount)&#123; cTotalCount++; setTimeout(() =&gt; &#123; closeCurrCount=0; initWebSocket(); &#125;, reconnectTime); &#125;else&#123; closeSock(); &#125; &#125;&#125; const websocketOpen=(e)=&gt;&#123; console.log(&quot;WebSocket连接成功&quot;,e); closeCurrCount=0; cTotalCount=0; //heartbeat();&#125;export &#123; initWebSocket, heartbeat, sendSock, closeSock &#125; 9. 获取当前链接参数12345678910//获取当前链接参数 getQueryVariable(variable) &#123; var query = window.location.search.substring(1); var vars = query.split(&quot;&amp;&quot;); for (var i = 0; i &lt; vars.length; i++) &#123; var pair = vars[i].split(&quot;=&quot;); if (pair[0] == variable) &#123; return pair[1]; &#125; &#125; return (false); &#125; 10. 关于时间的多种方法1. 封装获取日期方法1234567891011121314151617181920212223242526272829303132// 封装时间处理 dateFormatDay(timestamp) &#123; let date = new Date(timestamp); //时间戳为10位需*1000，时间戳为13位的话不需乘1000 let Y = date.getFullYear() + &#x27;/&#x27;; let M = (date.getMonth() + 1 &lt; 10 ? &#x27;0&#x27; + (date.getMonth() + 1) : date.getMonth() + 1) + &#x27;/&#x27;; let D = (date.getDate() &lt; 10 ? &#x27;0&#x27;+date.getDate() : date.getDate()) + &#x27; &#x27;; let h = (date.getHours() &lt; 10 ? &#x27;0&#x27;+date.getHours() : date.getHours()) + &#x27;:&#x27;; let m = (date.getMinutes() &lt; 10 ? &#x27;0&#x27;+date.getMinutes() : date.getMinutes()) + &#x27;:&#x27;; let s = (date.getSeconds() &lt; 10 ? &#x27;0&#x27;+date.getSeconds() : date.getSeconds()); return Y + M + D ; &#125;, // 调用 forDetails(num) &#123; console.log(num); let startTime = new Date(new Date().setHours(0, 0, 0, 0)); // 获取当前凌晨的时间 let SevenDayAgo; if(num == 1) &#123; // 昨天 SevenDayAgo = startTime - 86400 * 1 * 1000; &#125;else if(num == 2)&#123; // 7天前 SevenDayAgo = startTime - 86400 * 7 * 1000; &#125;else if(num == 3) &#123; // 30天前 SevenDayAgo = startTime - 86400 * 30 * 1000; &#125;else if(num == 4) &#123; // 一年前 SevenDayAgo = startTime - 86400 * 365 * 1000; &#125; SevenDayAgo = this.dateFormatDay(SevenDayAgo); &#125;, 2. 获取当前日期123456789101112131415function getNowFormatDate() &#123; var date = new Date(); var seperator1 = &quot;-&quot;; var year = date.getFullYear(); var month = date.getMonth() + 1; var strDate = date.getDate(); if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123; month = &quot;0&quot; + month; &#125; if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123; strDate = &quot;0&quot; + strDate; &#125; var currentdate = year + seperator1 + month + seperator1 + strDate; return currentdate; &#125; 3. 获取当前日期时间12345678910111213141516171819202122232425262728293031323334353637383940414243444546//获取当前日期时间 function curentTime() &#123; var now = new Date(); var year = now.getFullYear(); //年 vild var day = now.getDate(); //日 var hh = now.getHours(); //时 var mm = now.getMinutes(); //分 var ss = now.getSeconds(); //分 var clock = year + &quot;-&quot;; if(month &lt; 10) clock += &quot;0&quot;; clock += month + &quot;-&quot;; if(day &lt; 10) clock += &quot;0&quot;; clock += day + &quot; &quot;; if(hh &lt; 10) clock += &quot;0&quot;; clock += hh + &quot;:&quot;; if (mm &lt; 10) clock += &#x27;0&#x27;; clock += mm + &quot;:&quot;; if (ss &lt; 10) clock += &#x27;0&#x27;; clock += ss; return clock; &#125; //定时执行setTime setInterval(&quot;setTime()&quot;,1000); //将id为currentTime的div更新为最新时间 function setTime()&#123; $(&#x27;#currentTime&#x27;).html(curentTime()); &#125; 4.根据年月获取当月第一天和最后一天1234567891011121314151617181920//根据年月获取当月第一天日期 function getStartDate(yearmonthstr)&#123; if(/^\\d&#123;4&#125;-\\d&#123;2&#125;$/.test(yearmonthstr))&#123; //判断是否满足yyyy-mm条件 var year = /\\d&#123;4&#125;/.exec(yearmonthstr)[0]; //获取年份 var month = /\\d&#123;2&#125;$/.exec(yearmonthstr)[0]; //获取月份 var d = new Date(year, month, 0); var day = d.getDate(); //获取月的天数 return yearmonthstr+&#x27;-01&#x27;; &#125; &#125; //根据年月获取当月最后一天日期 function getEndDate(yearmonthstr)&#123; if(/^\\d&#123;4&#125;-\\d&#123;2&#125;$/.test(yearmonthstr))&#123; //判断是否满足yyyy-mm条件 var year = /\\d&#123;4&#125;/.exec(yearmonthstr)[0]; //获取年份 var month = /\\d&#123;2&#125;$/.exec(yearmonthstr)[0]; //获取月份 var d = new Date(year, month, 0); var day = d.getDate(); //获取月的天数 return yearmonthstr+&#x27;-&#x27;+day; &#125; &#125; 5. 转换时间戳12345678910getLocalTime(nS) &#123; let date = new Date(nS); //时间戳为10位需*1000，时间戳为13位的话不需乘1000 let Y = date.getFullYear() + &#x27;-&#x27;; let M = ((date.getMonth() + 1) &lt; 10)? (&#x27;0&#x27; + (date.getMonth() + 1) + &#x27;-&#x27; ):((date.getMonth() + 1) + &#x27;-&#x27;); let D = (date.getDate() &lt; 10) ? (&#x27;0&#x27; + date.getDate() + &#x27; &#x27;) : (date.getDate() + &#x27; &#x27;); let h = (date.getHours() &lt; 10) ? (&#x27;0&#x27; + date.getHours() + &#x27;:&#x27;) : (date.getHours() + &#x27;:&#x27;); let m = (date.getMinutes() &lt; 10) ? (&#x27;0&#x27; + date.getMinutes() + &#x27;:&#x27;) : (date.getMinutes() + &#x27;:&#x27;); let s = (date.getSeconds() &lt; 10) ? (&#x27;0&#x27; + date.getSeconds()) : (date.getSeconds()); return Y + M + D + h + m + s; &#125;, 6. 获取时间戳1var timestamp = Date.parse(new Date()); 11. 获取当前URL路径1234567891011121314151617181920212223//获取当前窗口的Urlvar url = window.location.href;//结果：http://localhost:61768/Home/Index?id=2&amp;age=18//获取当前窗口的主机名var host = window.location.host;//结果：localhost:61768//获取当前窗口的端口var port = window.location.port;//结果：61768//获取当前窗口的路径var pathname = window.location.pathname;//结果：/Home/Index//获取当前文档的Urlvar URL = document.URL;//结果：http://localhost:61768/Home/Index?id=2&amp;age=18//获取参数var search = window.location.search;//结果：?id=2&amp;age=18 分隔URL中的参数 123456789101112131415161718var search = window.location.search;var age = getSearchString(&#x27;age&#x27;, search); //结果：18var id = getSearchString(&#x27;id&#x27;, search); //结果：2//key(需要检索的键） url（传入的需要分割的url地址，例：?id=2&amp;age=18）function getSearchString(key, Url) &#123; var str = Url; str = str.substring(1, str.length); // 获取URL中?之后的字符（去掉第一位的问号） // 以&amp;分隔字符串，获得类似name=xiaoli这样的元素数组 var arr = str.split(&quot;&amp;&quot;); var obj = new Object(); // 将每一个数组元素以=分隔并赋给obj对象 for (var i = 0; i &lt; arr.length; i++) &#123; var tmp_arr = arr[i].split(&quot;=&quot;); obj[decodeURIComponent(tmp_arr[0])] = decodeURIComponent(tmp_arr[1]); &#125; return obj[key];&#125; 12. 两个路由间传值1. 在main.js中 全局注册：1window.eventBus = new Vue(); 2. 用emit发送：1window.eventBus.$emit(&quot;data&quot;,this.multipleSelection); 3. 用$on接受：123window.eventBus.$on(&quot;data&quot;, (val)=&gt;&#123; console.log(val); &#125;); 4. 销毁123beforeDestroy() &#123; window.eventBus.$off(&#x27;data&#x27;); &#125; 13. Storage用法1234567891011121314151617存： var obj = &#123;&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:&quot;16&quot;&#125; // sessionStorage localStorage sessionStorage.setItem(&quot;userInfo&quot;,JSON.stringify(obj));取： var user = JSON.parse(sessionStorage.getItem(&quot;userInfo&quot;))删除： sessionStorage.removeItem(&quot;userInfo);清空： sessionStorage.clear(); 14. 判断字符串是否为空1item.chauffeur != null &amp;&amp; item.chauffeur.length != 0 // 先判断类型，后判断长度 15. 返回上一次选择的check1234567891011121314let nowVal; if (this.arr.length &gt; val.length) &#123; let ids = val.map(item =&gt; item.kindcode); nowVal = this.arr.filter(item =&gt; !ids.includes(item.kindcode)); this.tableData.find( item =&gt; item.kindcode == nowVal[0].kindcode ).checked = false; &#125; else &#123; let ids = this.arr.map(item =&gt; item.kindcode); nowVal = val.filter(item =&gt; !ids.includes(item.kindcode)); nowVal[0].checked = true; &#125; 16. 判断一个值是否是is not fined(未申明)1234567891011try &#123; // 已声明 if (form.fullPath == &quot;/detailsSheet&quot;) &#123; next(vm =&gt; (vm.isData = true)); &#125; else &#123; next(vm =&gt; (vm.isData = false)); &#125; &#125; catch (err) &#123; // 未声明 next(vm =&gt; (vm.isData = false)) &#125; 17. 冒泡排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 冒泡排序函数 * arr 需要排序的数组 * mode 排序的模式(positive正序，reverse倒序) * according 如果数组里面的元素是对象，该参数传根据对象中的哪个元素进行排序(可不传递) */function bubbleSort(arr, mode, according) &#123; if (according) &#123; if (mode == &#x27;positive&#x27;) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j][according] &gt; arr[j + 1][according]) &#123; var tmp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = tmp &#125; &#125; arr[i][&#x27;ranking&#x27;] = i + 1 &#125; &#125; else if (mode == &#x27;reverse&#x27;) &#123; for (var i = 0; i &lt; arr.length - 1; i++) &#123; for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j][according] &lt; arr[j + 1][according]) &#123; var tmp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = tmp &#125; &#125; arr[i][&#x27;ranking&#x27;] = i &#125; &#125; &#125; else &#123; if (mode == &#x27;positive&#x27;) &#123; for (var i = 0; i &lt; arr.length - 1; i++) &#123; for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; var tmp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = tmp &#125; &#125; &#125; &#125; else if (mode == &#x27;reverse&#x27;) &#123; for (var i = 0; i &lt; arr.length - 1; i++) &#123; for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &lt; arr[j + 1]) &#123; var tmp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = tmp &#125; &#125; &#125; &#125; &#125; return arr;&#125;export &#123; bubbleSort&#125; 18. 累计reduce()12345678910111213141516xxx.forEach(item =&gt;&#123; let func = (...numbers) =&gt; &#123; return numbers.reduce( (count, item) =&gt; (count += Number(item)), 0 ); &#125;; item.totalNumber = func( item.picc, item.pa, item.tb, item.gs, item.other ); &#125;); &#125;) 19. 使用some方法判断是否有满足条件的元素12345let arr = [1, 3, 5, 7]let isHasNum = n =&gt; arr.some(num =&gt; num === n)let arr = [1, 3, 5, 7]let isHasNum = (n, arr) =&gt; arr.some(num =&gt; num === n) 20. 使用filter方法过滤原数组，形成新数组12let arr = [1, 3, 5, 7]let newArr = arr.filter(n =&gt; n &gt; 4) // [5, 7] 21. 使用map对数组中所有元素批量处理，形成新数组12let arr = [1, 3, 5, 7]let newArr = arr.map(n =&gt; n + 1) // [2, 4, 6, 8] 22. 使用Object.values快速获取对象键值12345let obj = &#123; a: 1, b: 2&#125;let values = Object.values(obj) // [1, 2] 23. 使用Object.keys快速获取对象键名12345let obj = &#123; a: 1, b: 2&#125;let keys = Object.keys(obj) // [&#x27;a&#x27;, &#x27;b&#x27;] 24. 解构数组进行变量值的替换12let a&#x3D;1,b&#x3D;2,[b,a] &#x3D; [a,b] 26. 解构对象1234setForm (&#123;name, age&#125;) &#123; this.name = name this.age = age &#125; 27. 解构时重命名简化命名有的后端返回的键名特别长，你可以这样干 1234567891011// goodsetForm (&#123;aaa_bbb_ccc_ddd, eee_fff_ggg&#125;) &#123; this.one = aaa_bbb_ccc_ddd this.two = eee_fff_ggg&#125;// bestsetForm (&#123;aaa_bbb_ccc_ddd: one, eee_fff_ggg: two&#125;) &#123; this.one = one this.two = two&#125; 28. 解构时设置默认值1234setForm (&#123;name, age = 16&#125;) &#123; this.name = name this.age = age &#125; 29. &amp;&amp;短路符判断依赖的键是否存在防止报错’xxx of undfined’123456789let person = &#123; name: &#x27;张三&#x27;, age: 38, children: &#123; name: &#x27;张小三&#x27; &#125;&#125;let childrenName = person.children &amp;&amp; person.childre.name 30. 函数参数校验1234let checkoutType = () =&gt; &#123; throw new Error(&#x27;参数不能为空&#x27;)&#125;let findStudentByAge = (arr, age = checkoutType()) =&gt; arr.filter(num =&gt; num === age) 31. this.$set(obj, key, value) &amp;&amp; vue.set(obj, key, value)vue2.0 给data对象新增属性，并触发视图更新 12345678data () &#123; return &#123; student: &#123; name: &#x27;&#x27;, sex: &#x27;&#x27; &#125; &#125;&#125; 众所周知，直接给student赋值操作，虽然可以新增属性，但是不会触发视图更新 123mounted () &#123; this.student.age = 24&#125; 原因是：受 ES5 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的。 要处理这种情况，我们可以使用**$set()**方法，既可以新增属性,又可以触发视图更新。 1234567891011121314151617mounted () &#123; this.$set(this.student,&quot;age&quot;, 24)&#125;// 下面是自用实例 api.monthLossRatioStatistics(params).then(res =&gt; &#123; res.list.forEach((item, index) =&gt; &#123; let obj = &#123; rate: (item.rate * 100).toFixed(1), date: item.tjmonth.split(&quot;-&quot;)[1] &#125;; this.$set(this.compensate.rows, index, obj); &#125;); this.presentationData[0].number = this.compensate.rows[ this.compensate.rows.length - 1 ].rate; &#125;); 32. Object.assign()给对象添加少量属性可以用上面的this.$set() ，如果需要大量的修改 则可以用这个属性；创建一个新的对象，合并原来对象和混入对象的属性；用法如下： 1this.someObject = Object.assign(&#123;&#125;, this.someObject,&#123;newProperty1: 1, newProperty2: 2 ...&#125;) 33. 发送短信60s处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647codeClick() &#123; let count = 60; let reg = /^1[0123456789]\\d&#123;9&#125;$/; let bool = reg.test(this.userPhone); let timer; let func = ()=&gt;&#123; if(count &lt;= 60 &amp;&amp; count &gt; 0) &#123; this.authenticationCode = count-- + &#x27; &#x27; + &#x27;S&#x27;; this.isColor = &#x27;#888888&#x27;; &#125;else if(count &lt;= 60)&#123; // 秒数走完 ，清除定时器 clearInterval(timer); this.authenticationCode = &#x27;获取验证码&#x27;; this.isColor = &#x27;#ee0a24&#x27;; this.isDisabled = false; count = 60; &#125; &#125; if(bool)&#123; if(this.userPhone == this.retUserPhone) &#123; this.$toast(&#123; message: &quot;新手机号码与原手机号码相同！&quot;, icon: &quot;close&quot; &#125;); &#125;else &#123; // 执行成功操作 this.isDisabled = true; timer = setInterval(func, 1000) func(); let params = &#123; openid: this.openid, mobile: this.userPhone.trim() &#125;; api.SendPhoneMsg(params); &#125; &#125;else &#123; this.$toast(&#123; message: &quot;手机号码格式有误！&quot;, icon: &quot;close&quot; &#125;); &#125; // 组件销毁时 清除定时器 this.$once(&quot;beforeDestroy&quot;, () =&gt; &#123; clearInterval(timer); &#125;); &#125;, 34. 策略模式策略模式的使用，避免过多的if else判断，也可以替代简单逻辑的switch 1234567891011121314151617181920const formatDemandItemType = (value) =&gt; &#123; switch (value) &#123; case 1: return &#x27;基础&#x27; case 2: return &#x27;高级&#x27; case 3: return &#x27;VIP&#x27; &#125;&#125;// 策略模式const formatDemandItemType2 = (value) =&gt; &#123; const obj = &#123; 1: &#x27;基础&#x27;, 2: &#x27;高级&#x27;, 3: &#x27;VIP&#x27;, &#125; return obj[value]&#125; 35. 执行浏览器复制到粘贴板1234infantCopyLink(e) &#123; e.currentTarget.previousElementSibling.select(); // 选择对象 document.execCommand(&quot;Copy&quot;); // 执行浏览器复制命令&#125;, 36. once1234567// 执行一次 用于销毁组件，定时器等。// 组件销毁时 清除定时器timer = setInterval(func, 1000);this.$once(&quot;beforeDestroy&quot;, () =&gt; &#123; clearInterval(timer);&#125;); 37. every()和some() 判断一个数组对象中的所有数据或某个值都满足条件every() 只要有一个不符合条件就为 false (一假即假) some() 只要有一个符合条件就位 true (一真即真) 1234567891011var arr = [66, 34, 643, 774, 64, 834 ];console.log( arr.every((a)=&gt; a&gt;=100) ) // falseconsole.log( arr.some((a)=&gt; a&gt;=40 ) ) // truevar arrObj = [ &#123; status:0, id:1 &#125;, &#123; status:1, id:2 &#125;, &#123; status:0, id:3 &#125;,]console.log( arrObj.every( (val) =&gt; val.status===0) );// falseconsole.log( arrObj.some( (val) =&gt; val.id===2) );// true 38. 接收后端返回二进制图片1window.URL.createObjectURL(res); 39. Vue过滤器的用法123456789101112131415161718192021222324252627282930313233&lt;el-table-column prop=&quot;overstatus&quot; label=&quot;修改状态&quot; fixed=&quot;right&quot; width=&quot;110&quot;&gt; &lt;template slot-scope=&quot;&#123; row &#125;&quot;&gt; &#123;&#123; row.overstatus | statusFilter &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt;data: &#123; reutrn &#123;&#125;&#125;,filters: &#123; // 转换修改状态 statusFilter(val) &#123; switch(val) &#123; case &#x27;0&#x27;: return &#x27;未修改&#x27;; case &#x27;2&#x27;: return &#x27;修改不一致&#x27;; case &#x27;3&#x27;: return &#x27;已修改一致&#x27;; case &#x27;4&#x27;: return &#x27;已分配未修改&#x27;; case &#x27;未修改&#x27;: return &#x27;0&#x27;; case &#x27;修改不一致&#x27;: return &#x27;2&#x27;; case &#x27;已修改一致&#x27;: return &#x27;3&#x27;; case &#x27;已分配未修改&#x27;: return &#x27;4&#x27;; default: return &#x27;&#x27;; &#125; &#125; &#125;, 40. 隐藏手机中间位数12345var tel = &quot;13122223333&quot;;var reg = /^(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)$/;tel = tel.replace(reg, &quot;$1****$2&quot;); 41. 上传图片增加水印12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 上传图片后的回调/*** 此处是用的vant的上传组件。* 原生请用input change属性回调* file.file的格式 请找对此格式在调用方法* lastModified: 1247549551674* lastModifiedDate: Tue Jul 14 2009 13:32:31 GMT+0800 (中国标准时间) &#123;&#125;* name: &quot;Lighthouse.jpg&quot;* size: 561276* type: &quot;image/jpeg&quot;* webkitRelativePath: &quot;&quot;*/async afterRead(file) &#123; let img = await this.blobToImg(file.file) let canvas = await this.imgToCanvas(img) let blob = await this.watermark(canvas, &#x27;测试水印&#x27;) // 此处将Blob读取到img标签，并在dom内渲染出来；如果是上传文件，可以将blob添加到FormData中 let newImage = await this.blobToImg(blob) // 此处是直接替换掉上传的图片 用作回显 file.content = newImage.src; // 什么需求看用什么 // 此处是把newImage标签插入到DOM节点中 // this.newImageData = newImage; // document.getElementById(&#x27;contentImg&#x27;).appendChild(newImage);&#125;, // 读取图像文件渲染到img标签lobToImg (blob) &#123; return new Promise((resolve, reject) =&gt; &#123; let reader = new FileReader() reader.addEventListener(&#x27;load&#x27;, () =&gt; &#123; let img = new Image() img.src = reader.result img.addEventListener(&#x27;load&#x27;, () =&gt; resolve(img)) &#125;) reader.readAsDataURL(blob) &#125;)&#125;, // 将img标签内容绘制到canvas画布imgToCanvas (img) &#123; let canvas = document.createElement(&#x27;canvas&#x27;) canvas.width = img.width canvas.height = img.height let ctx = canvas.getContext(&#x27;2d&#x27;) ctx.drawImage(img, 0, 0) return canvas&#125;, // canvas画布上绘制水印并转换为Blob对象watermark (canvas, text) &#123; return new Promise((resolve, reject) =&gt; &#123; let ctx = canvas.getContext(&#x27;2d&#x27;) // 设置填充字号和字体，样式 ctx.font = &quot;99px 宋体&quot; ctx.fillStyle = &quot;#000&quot; // 设置右对齐 ctx.textAlign = &#x27;right&#x27; // 在指定位置绘制文字，这里指定距离右下角20坐标的地方 ctx.fillText(text, canvas.width - 20, canvas.height - 20) canvas.toBlob(blob =&gt; resolve(blob)) &#125;)&#125;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"深度优先遍历和广度优先遍历","slug":"深度优先遍历和广度优先遍历","date":"2020-07-17T05:31:29.000Z","updated":"2020-07-28T02:55:57.240Z","comments":true,"path":"2020/07/17/深度优先遍历和广度优先遍历/","link":"","permalink":"https://1314xulujin.github.io/2020/07/17/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/","excerpt":"","text":"深度优先遍历和广度优先遍历第五题问的是深度优先遍历和广度优先遍历，我是从dom节点的遍历来理解这个问题的 html代码 我将用深度优先遍历和广度优先遍历对这个dom树进行查找 深度优先遍历 深度优先遍历DFS 与树的先序遍历比较类似。假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*深度优先遍历三种方式*/let deepTraversal1 = (node, nodeList = []) =&gt; &#123; if (node !== null) &#123; nodeList.push(node) let children = node.children for (let i = 0; i &lt; children.length; i++) &#123; deepTraversal1(children[i], nodeList) &#125; &#125; return nodeList&#125;let deepTraversal2 = (node) =&gt; &#123; let nodes = [] if (node !== null) &#123; nodes.push(node) let children = node.children for (let i = 0; i &lt; children.length; i++) &#123; nodes = nodes.concat(deepTraversal2(children[i])) &#125; &#125; return nodes &#125;// 非递归let deepTraversal3 = (node) =&gt; &#123; let stack = [] let nodes = [] if (node) &#123; // 推入当前处理的node stack.push(node) while (stack.length) &#123; let item = stack.pop() let children = item.children nodes.push(item) // node = [] stack = [parent] // node = [parent] stack = [child3,child2,child1] // node = [parent, child1] stack = [child3,child2,child1-2,child1-1] // node = [parent, child1-1] stack = [child3,child2,child1-2] for (let i = children.length - 1; i &gt;= 0; i--) &#123; stack.push(children[i]) &#125; &#125; &#125; return nodes&#125; 输出结果 广度优先遍历 广度优先遍历 BFS从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。 如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 123456789101112131415161718192021let widthTraversal2 = (node) =&gt; &#123; let nodes = [] let stack = [] if (node) &#123; stack.push(node) while (stack.length) &#123; let item = stack.shift() let children = item.children nodes.push(item) // 队列，先进先出 // nodes = [] stack = [parent] // nodes = [parent] stack = [child1,child2,child3] // nodes = [parent, child1] stack = [child2,child3,child1-1,child1-2] // nodes = [parent,child1,child2] for (let i = 0; i &lt; children.length; i++) &#123; stack.push(children[i]) &#125; &#125; &#125; return nodes&#125; 输出结果 ps仅个人理解，如果有错欢迎大家指出批评，一起进步","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"李深面试经验题目","slug":"李深面试经验题目","date":"2020-07-16T05:50:20.000Z","updated":"2020-12-02T08:09:20.107Z","comments":true,"path":"2020/07/16/李深面试经验题目/","link":"","permalink":"https://1314xulujin.github.io/2020/07/16/%E6%9D%8E%E6%B7%B1%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E9%A2%98%E7%9B%AE/","excerpt":"","text":"面试时长40分钟第一部分:自我介绍-介绍一下项目-开发过程中遇到最难的问题。第二部分:vue1.vue双向绑定原理 2.vue中v-if与v-show的区别以及使用场景 3.vue的响应式原理是什么 4.你是如何理解MVVM，原理 5.vue的transition组件实现原理 6.socket-io与http请求的区别? 7.最新的HTML5标准中的API 8.canvas与svg的区别 第三部分场景题1.直播过程中，用户声源没有，站在前端角度如何处理 2.直播过程中，用户画面没有了，站在前端角度如何处理","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"侯倩倩中科科软面试题","slug":"侯倩倩中科科软面试题","date":"2020-07-02T06:53:09.000Z","updated":"2020-07-03T10:43:32.500Z","comments":true,"path":"2020/07/02/侯倩倩中科科软面试题/","link":"","permalink":"https://1314xulujin.github.io/2020/07/02/%E4%BE%AF%E5%80%A9%E5%80%A9%E4%B8%AD%E7%A7%91%E7%A7%91%E8%BD%AF%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1.数据类型有哪些（因为我还回答了symbol,所以他会问symbol是干嘛的） ​ 答： ​ 基本类型(String, Number, Boolean, Undefined, Null, Symbol ES6新增) ​ 引用类型(Object, Array, Function, Data) 2.造场景（转换数据类型如：检测一个数字类型需要转换成字符串，还有呢？隐式转换呢？） ​ 答： ​ 1.value.toString() ​ 2.””+value 使用一个空字符串拼接一个任意需要转换为字符串的值也可以 ​ 3.String(value) ​ 4.value.toFixed(0) 3.变量提升？ ​ 答： ​ 变量提升的意思就是声明提升到它所在的作用域的顶端去执行，到我们代码所在的位置来赋值。 ​ 典型的var a = 10;就会使变量提升 12console.log(a)var a = 10; // undefined 4.异步操作的使用场景，用过promise吗？ ​ 答： ​ 1.使用异步封装ajax请求数据，避免出现回调地狱的情况; ​ 2.异步加载输出的值，防止出现输出值为undefined的情况(在vuex的actions中使用) 5.vue的双向绑定 ​ 答： Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据 ​ vue的双向绑定涉及到Object.definedProperty()数据劫持，发布订阅模式等，大致有四个阶段 ​ 1.实现一个监听器Observer：对数据对象进行遍历， 包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 ​ 2.实现一个解析器Compile：解析Vue模板指令，将模板中的变量都变成数据，然后初始化渲染到页面视图上面，并对每个对应的节点绑定新的函数，也就是添加了订阅者，数据一旦变化，就会收到通知，调用更新函数进行数据更新。 ​ 3.实现一个订阅者Watcher：Watcher订阅者使Observer和Compile之间通信的桥梁，主要的任务使，主要是订阅Observer中的属性变化的消息，当收到属性值变化时，会及时触发Compile中对应的更新函数。 ​ 4.实现一个订阅器Dep：订阅器才用发布订阅的模式，用来收集Watcher订阅者，对Oberver监听器和Compile解析器进行统一管理 6.vuex ​ 答： ​ vue生态系统中的状态管理系统 ​ 属性： ​ 1.state ​ 2.getters ​ 3.mutations ​ 4.actions 7.vue的路由模式有哪些 ​ 答： ​ 1.hash(常用) ​ 基于window.location.hash，在地址栏设置一个#加上后面的参数，页面不会刷新跳转。 ​ 2.history ​ 基于H5新的API历史记录，需要后端配合做到和hash一样的效果，优点是地址栏没有#，更加美观。 ​ 3.abstract(不常用) 8.微信小程序页面间跳转？他们之间的区别？ ​ 答： ​ 1.wx.navigateTo() 跳转一个新的页面 ​ 2.wx.navigateBack() 返回上一个页面 可以通过getCurrentPage()获得前的页面栈，决定要返回到第几层。 ​ 3.wx.redirectTo() 跳转当前打开，重定向 9.微信小程序的绑定事件的方法 ​ 答： ​ 1.bind绑定 ​ 2.catch绑定（可以阻止事件冒泡） 10，webpack常用的配置你用过哪些？ ​ 答： ​ context：执行的基本路径 ​ entry：入口设置(有入口文件的路径) ​ output：输出设置(有输出的路径) ​ rules：解析一些文件的规则，loader就是在里面配置 ​ plugins：其他插件（压缩js，html-webpack-plugin，分割文件的插件，加快打包速度的插件等等） 11.你遇到过的性能问题，如何解决？ ​ 答： ​ 1.vue打包的速度问题 ​ 使用 webpack-bundle-analyzer 来查看构建出来的项目具体情况 ​ webpack-jarvis 12.es6转es5你用的框架是？ ​ 答： ​ babel 13.wxss与css的区别？ ​ 答： ​ 1.wxss支持新的大小新单位rpx ​ 2.wxss具有css大部分的特性，并在css的基础上做了一些扩展和修改 ​ 3.wxss提供了全局样式和局部样式 ​ 4.有些css的选择器wxss不支持（wxss没有伪类中的 :hover建议用 :active） 14.如果一个盒子里面有两个盒子，flex布局，如何让里面的子元素，一个位置在头部，一个位置在底部 ​ 答： ​ 15.请谈谈WXSS和CSS的异同？ 答： ​ 相同点： ​ 都是用来描述页面的样子； ​ 不同点： ​ WXSS 具有 CSS 大部分的特性，也做了一些扩充和修改；​ WXSS新增了尺寸单位，WXSS 在底层支持新的尺寸单位 rpx；​ WXSS 仅支持部分 CSS 选择器；​ WXSS 提供全局样式与局部样式 https://www.cnblogs.com/teahouse/p/11504361.html这个你可以参考，上面有一些微信小程序的面试题 16.还有一个vue中的data在哪个生命周期可以获取到？你知道有哪些生命周期吗？ ​ 答： ​ 1.vue中的data首先在created阶段可以获取的到，created时data完成了为data数据的初始化 ​ 2. ​ beforeCreate data和el并未初始化 ​ created data的数据已经初始化 ​ beforeMount el初始化之前 ​ mounted el初始化，此时可以获取的到el ​ beforeUpdate ​ updated ​ beforeDestroy ​ destroyed 17.还问了一个移动端布局 ​ 答： ​ 18.微信小程序的双向绑定和Vue的区别 ​ 答： ​ ​ 19.你用过基于vue的脚手架吗？或者自己有做过脚手架吗？ ​ 答： ​ 1.wepack， webpack-simple(没有vue-router的中间件) ​ 2.有做过， ​ ①配置过基本的入口和输出路径，开发模式和生产模式， ​ ②配置一些他的rules中的loader，比如style-loader, css-loader, less-loader, ​ ③ 一些plugins，比如html-webpack-plugin, http-server, js和css的压缩插件等","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"js继承","slug":"js继承","date":"2020-06-11T08:04:40.000Z","updated":"2020-06-21T13:10:21.276Z","comments":true,"path":"2020/06/11/js继承/","link":"","permalink":"https://1314xulujin.github.io/2020/06/11/js%E7%BB%A7%E6%89%BF/","excerpt":"","text":"js继承1.概念​ 通过一种方式让一个对象访问到另一个对象中的属性和方法，我们把这种方式称之为继承。 2.继承的几种方式1.原型继承​ 原理： ​ 将原对象的实例对象一个对象的prototype,继承的属性和方法，会存在新对象的_proto_中，而新对象自己 ​ 的属性还是会在第一层。 123456789101112131415161718192021222324252627282930function Animal (name, type, age) &#123; this.name = name this.type = type this.age = age &#125; var animal = new Animal(&quot;藏獒&quot;, &quot;蓝色&quot;, &quot;飞哥&quot;) // console.log(animal) function Dog (nick) &#123; this.nick = nick this.CatchMouse = function () &#123; console.log(&quot;我会抓老鼠&quot;) &#125; &#125; Dog.prototype = animal var dog1 = new Dog(&quot;笑哈哈&quot;) console.log(dog1) // Cat &#123;nick: &quot;笑哈哈&quot;, CatchMouse: ƒ&#125;// CatchMouse: ƒ ()// nick: &quot;笑哈哈&quot;// __proto__: Animal// age: &quot;飞哥&quot;// name: &quot;藏獒&quot;// type: &quot;蓝色&quot;// __proto__: Object 2.借用构造函数继承​ 原理： ​ 在新对象使用call方法传参，且改变this的指向，这样原对象中的参数属性和方法会绑定给新对象，且不是在_proto_中而是在对象的第一层。 12345678910111213141516171819202122232425function Animal (name, type, age) &#123; this.name = name this.type = type this.age = age &#125; // var animal = new Animal(&quot;藏獒&quot;, &quot;蓝色&quot;, &quot;飞哥&quot;) // console.log(animal) function Dog (name, type, age) &#123; Animal.call(this, name, type, age) this.CatchMouse = function () &#123; console.log(&quot;我会抓老鼠&quot;) &#125; &#125; var dog1 = new Dog(&quot;藏獒&quot;, &quot;蓝色&quot;, &quot;飞哥&quot;) console.log(dog1) // Dog &#123;name: &quot;藏獒&quot;, type: &quot;蓝色&quot;, age: &quot;飞哥&quot;, CatchMouse: ƒ&#125; // CatchMouse: ƒ () // age: &quot;飞哥&quot; // name: &quot;藏獒&quot; // type: &quot;蓝色&quot; // __proto__: Object 3.原型式继承​ 原理：其实和原型继承原理一样，只不过是将原型继承的逻辑写在了一个函数后返回值 1234567891011121314151617181920212223242526272829303132function Animal (name, type, age) &#123; this.name = name this.type = type this.age = age &#125; var animal = new Animal(&quot;藏獒&quot;, &quot;蓝色&quot;, &quot;飞哥&quot;) // console.log(animal) function Dog () &#123; this.CatchMouse = function () &#123; console.log(&quot;我会抓老鼠&quot;) &#125; &#125; function CreateObj (Sub, parent) &#123; Sub.prototype = parent return new Sub() &#125; // var dog1 = new Dog(&quot;藏獒&quot;, &quot;蓝色&quot;, &quot;飞哥&quot;) var dog1 = CreateObj (Dog, animal) console.log(dog1)// Cat &#123;nick: &quot;笑哈哈&quot;, CatchMouse: ƒ&#125;// CatchMouse: ƒ ()// nick: &quot;笑哈哈&quot;// __proto__: Animal// age: &quot;飞哥&quot;// name: &quot;藏獒&quot;// type: &quot;蓝色&quot;// __proto__: Object 4.组合继承","categories":[],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"js new一个对象做了什么","slug":"js-new一个对象做了什么","date":"2020-06-11T07:41:43.000Z","updated":"2020-06-21T13:10:21.271Z","comments":true,"path":"2020/06/11/js-new一个对象做了什么/","link":"","permalink":"https://1314xulujin.github.io/2020/06/11/js-new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"","text":"js new一个对象做了什么12345678910function Person () &#123; this.name = name; this.age = age; this.job = job; this.sayName = function () &#123; return this.name; &#125; &#125; var person = new Person(&quot;tom&quot;, 21, &quot;WEB&quot;); console.log(person.name) 1.我的理解做了以下五个步骤 1.创建一个新的对象 , 比如 var person = {}。 2.将新对象的proto属性指向构造函数的原型对象。 3.将构造函数的作用域赋值给新对象。（所以this对象指向新对象） 4.执行构造函数中的代码，将属性添加给person中的this对象。 5.返回这个新对象。 通过new关键字创建某构造函数的新实例对象，就是将原型链与实例的this联系起来，this指向这个新对象，同时也指向这个构造函数，并且this对象还是这个构造函数的实例。如果没有使用new操作符，直接用构造函数创建新实例对象，那么this对象就指向了window对象，不会指向这个新对象的，不管给这个新对象添加什么属性，都没有用，是直接添加到了window对象上了。 2.代码解析123456789101112 var person = &#123;&#125;; person._proto_ = Person.prototype;//引用构造函数的原型对象 Person.call(person);//将构造函数的作用域给person,即：this值指向person Function.methos(&quot;new&quot;, function () &#123; //新创建一个对象，它继承了构造器的原型对象。 var that = Object.create(this.prototype); //此时，this是指向Function构造器的。 //调用构造器，绑定this对象到新对象that上 var other = this.apply(that, argument); //此时，this对象指向that对象。 //如果它的返回值不是一个对象，就返回新的对象。 return (typeof other === &quot;object&quot; &amp;&amp; other) || that; &#125;);","categories":[],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"markdown在typora的基本使用","slug":"markdown基本使用","date":"2020-06-11T07:41:43.000Z","updated":"2020-12-02T08:12:48.864Z","comments":true,"path":"2020/06/11/markdown基本使用/","link":"","permalink":"https://1314xulujin.github.io/2020/06/11/markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"#####markdown的使用 下载地址,提取码：ukil在字符的最后尽量用空格把符号和字分开，并且在英文状态下输入 设置一些显示自动保存等可以在 文件—偏好设置 里进行调整，重启后生效 去掉格式成为普通段落:ctrl + 0 ctrl + \\ 各级标题：ctrl+数字键 或者加相应级别数的* 下划线：ctrl + u 删除线：alt + shift + 5或者前后加~~ 代码(红色底纹字)：反引号 输入内容 反引号（反引号键为tab键上方） 或者前后加 高亮：在 格式 中 或者 左边== 然后输入内容== 字体加粗：ctrl + b或则前后加** 字体倾斜：ctrl + i或者前后加* 上角标： 要变成上角标的部分前后加^， 效果2x 下角标：要变成下角标的部分前后加波浪线~， 效果x2 行内数学公式：美元符号中间写直接函数x^2，效果x 2 x2x2 转义：特殊符号前加\\ 无序标题 ：减号，加号，乘号 之后加空格都可以，嵌套的话，tap键，想要跳出嵌套直接enter多次即可 有序标题：英文格式下1. 后面直接空格 表格：ctrl + t ctrl+回车 直接加行 分割线：输入输入***或---在空行上按下enter将绘制一条水平线 引用：直接 大于号 后面输入空格 或者 ctrl + shift + q，还可以引用嵌套 引用 嵌套 插入链接：ctrl + k 插入图片：拖拉或者ctrl + shift + i，为了使得图片在拷贝到别的地方依然存在，可以将图片路径修改为相对路径，具体参考 插入数学公式：两个美元符号 回车 代码块：三个~ 文章跳转：ctrl + home 跳转至文章开头，ctrl + end 跳转至文章末尾 选中当前词：ctrl + d 选中当前行：ctrl + L 文本以左，文本以右选中：ctrl + shift + 左箭头或者右箭头 跳转到光标处：ctrl + J 搜索：ctrl + f 替换：ctrl + h 快速打开文件：ctrl + p 可以看到以前输入的文件 快速生成目录:输入[toc] 后直接按 回车 这是一处锚点 锚点 表情：冒号 后输入英文 或者 ctrl + shift + b 新建文件：ctrl + n 定义脚注：文字 输入 [ ^数字] 然后放在数字那里会提示输入脚注解释的地址，点击之后，填写脚注名称,填写脚注内容 内部跳转链接： 12345# titleA# titleB- [toA](#titleA)- [toB](#titleB)1234 参考链接： 1234567This is [参考名][id] reference-style link.文章[id]: http:&#x2F;&#x2F;example.com&#x2F; &quot;Optional Title Here&quot;123456 本文其他用法可以参考来进一步学习typora参考手册","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"https://1314xulujin.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"赋值、浅拷贝和深拷贝","slug":"浅拷贝和深拷贝","date":"2020-06-10T03:40:11.000Z","updated":"2023-06-18T10:44:28.008Z","comments":true,"path":"2020/06/10/浅拷贝和深拷贝/","link":"","permalink":"https://1314xulujin.github.io/2020/06/10/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"赋值、浅拷贝和深拷贝一、赋值（Copy） 赋值是将某一数值或对象赋给某个变量的过程，分为： 1、基本数据类型：赋值，赋值之后两个变量互不影响 2、引用数据类型：赋址，两个变量具有相同的引用，指向同一个对象，相互之间有影响 对基本类型进行赋值操作，两个变量互不影响。 123456789&gt;// saucxs&gt;let a = &quot;saucxs&quot;;&gt;let b = a;&gt;console.log(b); // saucxs&gt;a = &quot;change&quot;;&gt;console.log(a); // change&gt;console.log(b); // saucxs 对引用类型进行赋址操作，两个变量指向同一个对象，改变变量 a 之后会影响变量 b，哪怕改变的只是对象 a 中的基本类型数据。 12345678910111213141516171819202122232425262728&gt;// saucxs&gt;let a = &#123; name: &quot;saucxs&quot;, book: &#123; title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot; &#125;&gt;&#125;&gt;let b = a;&gt;console.log(b);&gt;// &#123;&gt;// name: &quot;saucxs&quot;,&gt;// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;&gt;// &#125; &gt;a.name = &quot;change&quot;;&gt;a.book.price = &quot;55&quot;;&gt;console.log(a);&gt;// &#123;&gt;// name: &quot;change&quot;,&gt;// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;&gt;// &#125; &gt;console.log(b);&gt;// &#123;&gt;// name: &quot;change&quot;,&gt;// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;&gt;// &#125; 通常在开发中并不希望改变变量 a 之后会影响到变量 b，这时就需要用到浅拷贝和深拷贝。 二、浅拷贝（Shallow Copy） 1、什么是浅拷贝 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 上图中，SourceObject 是原对象，其中包含基本类型属性 field1 和引用类型属性 refObj。浅拷贝之后基本类型数据 field2 和 filed1 是不同属性，互不影响。但引用类型 refObj 仍然是同一个，改变之后会对另一个对象产生影响。 简单来说可以理解为浅拷贝只解决了第一层的问题，拷贝第一层的基本类型值，以及第一层的引用类型地址。 2、浅拷贝使用场景 2.1 Object.assign() Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 有些文章说Object.assign() 是深拷贝，其实这是不正确的。 12345678910111213141516171819202122232425262728&gt;// saucxs&gt;let a = &#123; name: &quot;saucxs&quot;, book: &#123; title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot; &#125;&gt;&#125;&gt;let b = Object.assign(&#123;&#125;, a);&gt;console.log(b);&gt;// &#123;&gt;// name: &quot;saucxs&quot;,&gt;// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;&gt;// &#125; &gt;a.name = &quot;change&quot;;&gt;a.book.price = &quot;55&quot;;&gt;console.log(a);&gt;// &#123;&gt;// name: &quot;change&quot;,&gt;// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;&gt;// &#125; &gt;console.log(b);&gt;// &#123;&gt;// name: &quot;saucxs&quot;,&gt;// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;&gt;// &#125; 上面代码改变对象 a 之后，对象 b 的基本属性保持不变。但是当改变对象 a 中的对象 book 时，对象 b 相应的位置也发生了变化。 2.2 展开语法 Spread 12345678910111213141516171819202122232425262728&gt;// saucxs&gt;let a = &#123; name: &quot;saucxs&quot;, book: &#123; title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot; &#125;&gt;&#125;&gt;let b = &#123;...a&#125;;&gt;console.log(b);&gt;// &#123;&gt;// name: &quot;saucxs&quot;,&gt;// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;&gt;// &#125; &gt;a.name = &quot;change&quot;;&gt;a.book.price = &quot;55&quot;;&gt;console.log(a);&gt;// &#123;&gt;// name: &quot;change&quot;,&gt;// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;&gt;// &#125; &gt;console.log(b);&gt;// &#123;&gt;// name: &quot;saucxs&quot;,&gt;// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;&gt;// &#125; 2.3 Array.prototype.slice方法 slice不会改变原数组，slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。 12345678910111213&gt;// saucxs&gt;let a = [0, &quot;1&quot;, [2, 3]];&gt;let b = a.slice(1);&gt;console.log(b);&gt;// [&quot;1&quot;, [2, 3]]&gt;a[1] = &quot;99&quot;;&gt;a[2][0] = 4;&gt;console.log(a);&gt;// [0, &quot;99&quot;, [4, 3]]&gt;console.log(b);&gt;// [&quot;1&quot;, [4, 3]] 可以看出，改变 a[1] 之后 b[0] 的值并没有发生变化，但改变 a[2][0] 之后，相应的 b[1][0] 的值也发生变化。 说明 slice() 方法是浅拷贝，相应的还有concat等，在工作中面对复杂数组结构要额外注意。 三、深拷贝的方法 1.JSON转换12&gt;var targetObj = JSON.parse(JSON.stringify(copyObj))&gt;let arr4 = JSON.parse(JSON.stringify(arr)) 缺点： （1）如果对象里有函数,函数无法被拷贝下来 （2）无法拷贝copyObj对象原型链上的属性和方法 （3）当数据的层次很深，会栈溢出 2.普通递归函数123456789101112131415161718&gt;function deepCopy( source ) &#123;&gt;if (!isObject(source)) return source; //如果不是对象的话直接返回 let target = Array.isArray( source ) ? [] : &#123;&#125; //数组兼容 for ( var k in source ) &#123; if (source.hasOwnProperty(k)) &#123; if ( typeof source[ k ] === &#x27;object&#x27; ) &#123; target[ k ] = deepCopy( source[ k ] ) &#125; else &#123; target[ k ] = source[ k ] &#125; &#125; &#125; return target&gt;&#125;&gt;function isObject(obj) &#123; return typeof obj === &#x27;object&#x27; &amp;&amp; obj !== null&gt;&#125; 缺点： （1）无法保持引用 （2）当数据的层次很深，会栈溢出 3.防栈溢出函数12345678910111213141516171819202122232425262728293031323334353637383940414243&gt;function cloneLoop(x) &#123; const root = &#123;&#125;; // 栈 const loopList = [ &#123; parent: root, key: undefined, data: x, &#125; ]; while(loopList.length) &#123; // 深度优先 const node = loopList.pop(); const parent = node.parent; const key = node.key; const data = node.data; // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素 let res = parent; if (typeof key !== &#x27;undefined&#x27;) &#123; res = parent[key] = &#123;&#125;; &#125; for(let k in data) &#123; if (data.hasOwnProperty(k)) &#123; if (typeof data[k] === &#x27;object&#x27;) &#123; // 下一次循环 loopList.push(&#123; parent: res, key: k, data: data[k], &#125;); &#125; else &#123; res[k] = data[k]; &#125; &#125; &#125; &#125; return root;&gt;&#125; 优点： （1）不会栈溢出 （2）支持很多层级的数据","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"080901计算科学与技术考试科目","slug":"080901计算机科学与技术考试科目","date":"2020-06-07T02:39:01.000Z","updated":"2021-11-03T08:46:17.709Z","comments":true,"path":"2020/06/07/080901计算机科学与技术考试科目/","link":"","permalink":"https://1314xulujin.github.io/2020/06/07/080901%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF%E8%80%83%E8%AF%95%E7%A7%91%E7%9B%AE/","excerpt":"","text":"专业代码：080901 专业名称：计算机科学与技术 主考学校：华南师范大学★、深圳大学★、暨南大学 专业层次：本科 专业类别：工学 类型序号 课程代码 课程名称 学分 类型 考试方式 备注 001 03708 中国近现代史纲要 2 必考 笔试 002 03709 马克思主义基本原理概论 4 必考 笔试 003 00015 英语(二) 14 必考 笔试 004 02628 管理经济学 5 必考 笔试 005 00910 网络经济与企业管理 6 必考 笔试 006 02375 运筹学基础 4 必考 笔试 007 02323 操作系统概论 4 必考 笔试 008 02142 数据结构导论 4 必考 笔试 009 04735 数据库系统原理 4 必考 笔试 010 04741 计算机网络原理 4 必考 笔试 011 04737 C++程序设计 3 必考 笔试 012 03173 软件开发工具 5 必考 笔试 013 04757 信息系统开发与管理 5 必考 笔试 014 02378 信息资源管理 4 必考 笔试 015 11393 计算机信息管理课程实验 5 必考 实践考核 016 07999 毕业设计 不计学分 必考 实践考核 201 02382 管理信息系统 4 加考 笔试 201 02383 管理信息系统 1 加考 实践考核 202 02384 计算机原理 4 加考 笔试 231 00024 普通逻辑 4 加考 笔试 232 05679 宪法学 4 加c考 笔试 课程设置：必考课16门73学分，加考课4门17学分。 说明： 1.015课程含009、011课程实验各2学分，012课程实验1学分。 2.计算机信息管理专业专科毕业生可直接报考本专业；工科与工程管理类专科（或以上）毕业生报考本专业，须加考201课程；其他专业专科（或以上）毕业生，须加考201、202两门课程，已取得相同名称课程考试成绩合格者可申请免考。 3.港澳台考生可不考001、002两门课程，但须加考231、232两门课程。 4.本专业仅接受国民教育序列的专科（或以上）毕业生申办毕业。 相关信息： 1）专业调整：本专业原代码：B082208，原专业名称：计算机信息管理；现专业代码：080901，现专业名称：计算机科学与技术。具体查看：关于广东省高等教育自学考试专业调整有关事项的通知 2）本专业新增主考院校：暨南大学，具体可以查看：自考生看过来！53个专业增加主考学校了 3）专业教材：本专业自考教材购买：进入自考书店 4）学校名称后有“★”为专业建设主考学校 广东自考网声明：（一） 由于各方面情况的调整与变化，本网所提供的考试信息仅供参考，敬请以权威部门公布的正式信息为准。（二） 本网注明来源为其他媒体的稿件均为转载稿，免费转载出于非商业性学习目的，版权归原作者所有。如有内容、版权等问题请与本网联系。联系方式：邮件 &#50;&#50;&#57;&#51;&#x34;&#50;&#57;&#50;&#48;&#55;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109; 2020年8月考试安排 [8月1日上午] [8月1日下午] [8月2日上午] [8月2日下午] 00024 普通逻辑 00910 网络经济与企业管理 02142 数据结构导论 02375 运筹学基础 02378 信息资源管理 03708 中国近现代史纲要 05679 宪法学 02384 计算机原理 03709 马克思主义基本原理概论04735 数据库系统原理 02628 管理经济学 03173 软件开发工具 04737 C++程序设计 00015 英语(二)02323 操作系统概论 02382 管理信息系统 04741 计算机网络原理 04757 信息系统开发与管理","categories":[],"tags":[{"name":"本科考试科目","slug":"本科考试科目","permalink":"https://1314xulujin.github.io/tags/%E6%9C%AC%E7%A7%91%E8%80%83%E8%AF%95%E7%A7%91%E7%9B%AE/"}]},{"title":"腾讯一年经验页面重构工程师面试题","slug":"腾讯一年经验页面重构工程师面试题","date":"2020-06-07T02:39:01.000Z","updated":"2020-06-21T13:10:21.386Z","comments":true,"path":"2020/06/07/腾讯一年经验页面重构工程师面试题/","link":"","permalink":"https://1314xulujin.github.io/2020/06/07/%E8%85%BE%E8%AE%AF%E4%B8%80%E5%B9%B4%E7%BB%8F%E9%AA%8C%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%9E%84%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"腾讯一年经验页面重构工程师面试题备注：以下均为笔试题，技术面不唯一，面试官是根据你的描述来带题(主要为移动端问题)1.列举清除浮动的五种方式&gt;#### **1、父级div定义overflow:hidden** &gt; &gt;123456789&gt;&lt;style type=&quot;text/css&quot;&gt; .div1&#123;background:#000080;border:1px solid red;width:98%;overflow:hidden&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; &gt;&lt;/style&gt; &gt;&lt;div class=&quot;div1&quot;&gt; &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt; &gt;&lt;/div&gt; &gt; &gt;原理：使用overflow:hidden时，浏览器会自动检查浮动区域的高度。 &gt;优点：简单，代码少，浏览器支持好。 &gt;缺点：必须定义width或zoom:1，不能和position配合使用，因为超出的尺寸的会被隐藏。 &gt;建议：只推荐没有使用position或对overflow:hidden理解的朋友使用。 &gt; &gt;#### **3、父级div定义height** &gt; &gt;123456789&gt;&lt;style type=&quot;text/css&quot;&gt; .div1&#123;background:#000080;border:1px solid red;height:200px;&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; &gt;&lt;/style&gt; &gt;&lt;div class=&quot;div1&quot;&gt; &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt; &gt;&lt;/div&gt; &gt; &gt;#### **2、结尾处加空div标签clear:both** &gt; &gt;12345678910&gt;&lt;style type=&quot;text/css&quot;&gt; .clear-box&#123; clear: both &#125;&gt;&lt;/style&gt; &gt;&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;child-1&quot;&gt;child-1&lt;/div&gt; &lt;div class=&quot;child-2&quot;&gt;child-2&lt;/div&gt; &lt;div class=&quot;clear-box&quot;&gt;&lt;/div&gt; &gt;&lt;/div&gt; &gt; &gt;#### **4、父级div定义overflow:auto** &gt; &gt;1&gt;.div1&#123;background:#000080;border:1px solid red;width:98%;overflow:auto&#125; &gt; &gt;#### **5、父级div定义伪类:after和zoom** &gt; &gt;12345678910&gt;&lt;style type=&quot;text/css&quot;&gt;.div1&#123;background:#000080;border:1px solid red;&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; .clearfloat:after&#123;display:block;clear:both;content:&quot;&quot;;visibility:hidden;height:0&#125; .clearfloat&#123;zoom:1&#125;&gt;&lt;/style&gt; &lt;div class=&quot;div1 clearfloat&quot;&gt; &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;&gt;&lt;/div&gt; &gt; &gt; 2.使用css实现首字下沉 使用css的伪类选择器：例如div::first-letter 12345678&lt;style&gt; div::first-letter&#123; font-size: 50px; float: left; &#125; &lt;/style&gt; &lt;div&gt;我是牛吧带坏覆盖一贯的风格给igig给给 还不换个iyyg 刚刚更应该有更应该一个预估于关于给呼滑uihui辉煌ui呼和我是牛吧带坏覆盖一贯的风格给igig给给 还不换个iyyg 刚刚更应该有更应该一个预估于关于给呼滑uihui辉煌ui呼和我是牛吧带坏覆盖一贯的风格给igig给给 还不换个iyyg 刚刚更应该有更应该一个预估于关于给呼滑uihui辉煌ui呼和我是牛吧带坏覆盖一贯的风格给igig给给 还不换个iyyg 刚刚更应该有更应该一个预估于关于给呼滑uihui辉煌ui呼和我是牛吧带坏覆盖一贯的风格给igig给给 还不换个iyyg 刚刚更应该有更应该一个预估于关于给呼滑uihui辉煌ui呼和我是牛吧带坏覆盖一贯的风格给igig给给 还不换个iyyg 刚刚更应该有更应该一个预估于关于给呼滑uihui辉煌ui呼和我是牛吧带坏覆盖一贯的风格给igig给给 还不换个iyyg 刚刚更应该有更应该一个预估于关于给呼滑uihui辉煌ui呼和&lt;/div&gt; 3.列举使用rem作单位的优缺点1.优点 相对于其他大小单位，比较好控制，只需要给根节点HTML设置一个比如为100px的字体大小，其根节点下面所有的元素以rem为单位是根据跟根节点HTML的字体大小来变化的，比如根节点HTML为100px，字体设置为0.1rem就是10px 2.缺点 1.兼容性：IE里面需要IE9及以上才能兼容 2.数据量比较大：后面每次都需要给盒子，图片，字体设置需要准确的大小值，rem还是做移动端比较好一点 4.使用三种以上方法只通过一个div标签实现红’十’字1.设置两个盒子，为长方形，在定位到相应的位置上面 2.定义一个父级盒子，将其background设置为红色，里面定义四个子盒子，分别挡住四个角就可以了 3.利用盒子的border来生成 5.display:flex布局 与 display:grid 布局差异6.请编写formatNum函数，将数字转换为千分位格式，每三位数加入逗号​ 例如：var a =1234567; var b=a.formatNum(); // b=”1,234,567” 12345678910111213141516171819202122&lt;script&gt; var a = &#x27;652165455156165456&#x27; // 向String对象注册一个全局的方法 String.prototype.formatNumber = function (fn) &#123; console.log(this) for( var i=0;i&lt;this.length;i++ )&#123; var arr = this.split(&#x27;&#x27;) &#125; arr.reverse() for( var i=1;i&lt;arr.length;i++ )&#123; if( i%3 == 0 )&#123; arr[i] = arr[i]+&#x27;,&#x27; &#125; &#125; console.log(arr.reverse().join(&quot;&quot;)) fn() &#125; // 之后就可以调用了 a.formatNumber(function ()&#123; console.log(&#x27;我是参数函数&#x27;) &#125;) &lt;/script&gt;","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"深圳科蓝软件面试题","slug":"深圳科蓝软件面试题","date":"2020-06-06T06:32:31.000Z","updated":"2020-06-21T13:10:21.381Z","comments":true,"path":"2020/06/06/深圳科蓝软件面试题/","link":"","permalink":"https://1314xulujin.github.io/2020/06/06/%E6%B7%B1%E5%9C%B3%E7%A7%91%E8%93%9D%E8%BD%AF%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"深圳科蓝软件面试题一.单项选择题1.下面符合一个有效的JavaScript变量定义规则的是?（） A. _$te$t2B. withC. a bcD. 2a 2.下面有关JavaScript中call和apply的描述，错误的是？（） A. call与apply都属于Function.prototype的一个方法，所以function实例都有call、apply属性B. 两者传递的参数不同，call函数第一个参数都是要传入给当前对象的对象，apply不是C. apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入D. call传入的则是直接的参数列表，call方法可将一个函数的对象上下文从初始的上下文改编为由thisObj指定的新对象。 3.程序输出：（） 1234567891011function Foo() &#123; var i = 0 return function () &#123; console.log(i++) &#125;&#125;var f1 = Foo() f2 = Foo()f1();f1();f2(); A. 0 1 0B. 0 1 2C. 0 0 0D. 0 0 2 4.下面哪些语句可以在js里判断一个对象oStringObject 是否为String （B） A. oStringObject instanceof StringB. typeof oStringObject == ‘string’C. oStringObject is StringD. 以上答案都不正确 5.result = stri.replace(/*\\s+|\\s+$/, ‘’), 以下str和result能匹配的是 （） A. str = ‘ a b c ‘ , result = ‘a b c’B. str = ‘ a b c ‘ , result = ‘abc’C. str = ‘ a b c ‘ , result = ‘a b c ‘D. str = ‘ a b c ‘ , result = ‘ a b c’ 6.下列哪个样式定义后，内联（非块状）元素可以定义宽度和高度（C） A. display:inlineB. display:noneC. display:blockD. display:inherit 7.下述有关css属性position的属性值的描述，说法错误的是？（B） A. static：没有定位，元素出现在正常的流中B. fixed：生成绝对定位的元素，相对于父元素进行定位C. relative：生成相对定位的元素，相对于元素本身正常位置进行定位D. absolute：生成绝对定位的元素，相对于static定位以外的第一个祖先元素的定位。 8.以下关于Array数组对象的说法不正确的是（） A. 对数组里数据的排序可以用sort函数，如果排序效果非预期，可以给sort函数添加一个排序的参数B. reverse用于对数组数据的倒序排序C. 向数组的最后位置加一个新元素，可以用push方法D. unshift方法用于向数组删除第一个元素 9.声明一个对象，给他加上name属性和show方法显示其name值，以下代码中正确的是（） A. var obj = [ name : “zhangsan” , show : function () {alert (name) } ]B. var obj = { name : “zhangsan” , show : “ alert (this.name) “ }C. var obj = { name : “zhangsan” , show : function () { alert (name) } }D. var obj = { name : “zhangsan” , show : function () { alert (this.name) } } 10.下面不属于关键字let的特点的是：（） A. 只在let命令所在的代码块内有效B. 会产生变量提升现象C. 同一个作用域，不能重复声明一个变量D. 不能在函数内部重新声明参数 11.下列语句不符合ES6规范的是：（） A. var str = `${‘Hello’} world`B. var boolean = false ?? trueC. var chars = { …’Hello world’ }D. var func = (a = 1, b = 1) =&gt; a+b 12.关于模板字符串，下列说法不正确的是:(这道题目没有拍照完整) A. 使用反引号标识B. 插入变量的时候使用$C. 所有的空格和缩进都会被保留。。。 13.关于Promise对象的状态，下列说法错误的是（） A. 三种状态分别是：pending初始状态，fulfilled成功，rejected失败B. pending初始状态可以转变成fulfilled成功C. rejected失败不可以变成pending初始状态D. rejected失败可以转变成fulfilled成功 14.关于箭头函数的，错误的是：（D） A. 使用箭头函数 =&gt; 定义B. 参数超过1个的话，需要小括号（）括起来C. 函数体语句超过1条的时候，需要大括号{}括起来，用return语句返回值D. 函数体内的this对象，绑定使用时所在的对象 15.在类的继承中，关于super的说法错误的是：（） A. 在子类的构造函数，必须先调用super()B. super相当于子类的引用C. 先调用super()，才可以使用thisD. super()相当于父类构造函数的调用 16.module模块中，对下列语句的描述，错误的是：（D） A. export 导出B. import 导入C. export default 默认导出D. import from 重命名 17.关于Iterator遍历器的说法，错误的是：（B） A. next()方法是Iterator遍历器的核心B. 当next()返回对象的done属性为false，遍历结束C. 具有Iterator接口的对象视为可遍历对象D. 可以自定义一个可遍历对象和其遍历行为 18.关于Set结构的实例方法，下面说法错位的是：（） A. set方法用用户添加成员B. clear方法用于清除所有成员C. entries方法返回成员的位置索引值的遍历器D. values方法返回成员值的遍历器 19.关于对象的扩展，错误的是：（） A. ES6的对象的表示法更加简洁B. 对象的属性名可以是表达式C. 对象的方法名不可以是表达式D. 当属性名为表达式的时候，需要使用{}标识 20.关于Promise的描述，错误的是：（） A. 在Promise的then方法中，可以接收两个函数，一个是resolve成功的函数一个是用于reject失败的函数B. Promise在生命周期内有状态一旦改变，就不能再次改变C. Promise对象用于延迟（deferred）计算和异步（asynchronous）计算，一个Promise对象代表一个还未完成，但预期将来会完成的操作D. Promise构造函数是异步执行的，promise.then中的函数也是异步执行的","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"杭州某大厂应届生面试题","slug":"杭州某大厂应届生面试题","date":"2020-06-04T05:49:30.000Z","updated":"2020-06-21T13:10:21.376Z","comments":true,"path":"2020/06/04/杭州某大厂应届生面试题/","link":"","permalink":"https://1314xulujin.github.io/2020/06/04/%E6%9D%AD%E5%B7%9E%E6%9F%90%E5%A4%A7%E5%8E%82%E5%BA%94%E5%B1%8A%E7%94%9F%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"杭州某大厂应届生面试题1.大文件上传方案2.手写防抖、节流(本质就是异步队列+定时器，丢弃任务和安排任务的轮回过程)3.一个页面不分页，每屏显示30张图片，有上千万张图片，你会如何处理业务需求？4.实现一个oop中的类似java的私有属性5.高并发JSONP的实现和优化6.数组扁平化，根据要求扁平化的结果不能有字符串，函数其他类型，碰到数组递归扁平化问题7.正则替换一句话中出现的三个如果中的最后一个如果，改成不如果8.实现5.add(1).add(2,3)9.实现ES3的bind的polyfill10.手写快排、堆排、冒泡、插排其中两个11.爬楼梯问题的解决与优化12.EventLoop，宏任务，微任务考察13.partial函数14.用多种方式写不定宽高盒子的水平垂直居中15.一张图片的水平垂直居中的尽可能多种方法16.for of的实现原理17.说下跨域的几种解决方案，proxy跨域的原理和jsonp的安全性问题18.尽可能详细说明输入一条url到解析页面全过程(关键词url重构建，DNS解析，TCP三次握手，缓存查找，http请求构建，DOM树类似括号匹配的构建，布局分层，绘制列表，光栅化等)19.结合浏览器渲染原理说下web性能优化20.webpack了解吗？(有专门学过，核心概念理解使用过)21.Generator和协程熟悉吗？说下你对协程的理解22.浏览器图层合并用到了什么规则知道吗？23.Node读取一个任务和执行任务回调你认为是在一个进程中完成还是两个？为什么？24.GPU加速原理了解过吗？25..移动端响应式方案有哪些？26.vw了解吗？用过吗？(嗯)27.Grid如何布局的？28.说下你是如何封装axios异步请求的29.Vue的mixin用过吗？(没)30.你是如何做登录鉴权的？token和cookie的区别是什么？浏览器缓存知道吗？31.Vuex用过吗？说说你对Vuex理解(分层思想，类似ISO七层模型的思想)32.说下适配器模式的思想(实现和使用隔离，不用管我干什么，你照着安排用就好)33.Vue的双向绑定知道吗？写一个简单的双向绑定34.说下React的具体执行过程35.你在项目中遇到过什么难点，都是如何解决的？给你设计一个购物车，你会如何设计？36.TS使用过吗？(用过，很像java，拿来重构过axios库）","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Vue中created和mounted的区别","slug":"Vue中created和mounted的区别","date":"2020-06-03T07:43:31.000Z","updated":"2020-06-21T13:10:21.258Z","comments":true,"path":"2020/06/03/Vue中created和mounted的区别/","link":"","permalink":"https://1314xulujin.github.io/2020/06/03/Vue%E4%B8%ADcreated%E5%92%8Cmounted%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Vue中created和mounted的区别Created该函数在组件创建完成后被立即调用，在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。 但是还未渲染成HTML模板，组件中的data对象已经存在，可以对data进行操作了，即可以访问数据，发请求，ref依旧是undefined，挂载阶段还没开始，$el 属性目前尚不可用。 一般我们可以将对数据的初始化和初始化页面的请求放到里面，结束loading。 Mounted该函数是页面完成挂载之后执行的，这时 el 被新创建的 vm.$el 替换了，就可以操作 ref 了，一般会用于将组件初始时请求数据的方法放到这里面，filter 也是在这里生效。 如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。 可以拿到数据和节点，实例被挂载后调用。 注意 ：mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick： mounted: function () {this.$nextTick(function () {// Code that will run only after the// entire view has been rendered })} 该钩子在服务器端渲染期间不被调用。 区别从上面两个生命周期的定义看，最大的区别就是在到了mounted的时候$el会被替换了，我们就可以使用$ref来操作DOM了。","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"MVC和MVVM","slug":"MVC和MVVM","date":"2020-06-02T00:30:20.000Z","updated":"2020-06-21T13:10:21.251Z","comments":true,"path":"2020/06/02/MVC和MVVM/","link":"","permalink":"https://1314xulujin.github.io/2020/06/02/MVC%E5%92%8CMVVM/","excerpt":"","text":"MVC和MVVM详情：MVC：MVC开始是存在于桌面程序中的，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。比如一批统计数据可以分别用柱状图、饼图来表示。C存在的目的则是确保M和V的同步，一旦M改变，V应该同步更新。 模型－视图－控制器（MVC）是[Xerox PARC](https://baike.baidu.com/item/Xerox PARC)在二十世纪八十年代为编程语言Smalltalk－80发明的一种软件设计模式，已被广泛使用。后来被推荐为Oracle旗下Sun公司[Java EE](https://baike.baidu.com/item/Java EE)平台的设计模式，并且受到越来越多的使用ColdFusion和PHP的开发者的欢迎。模型－视图－控制器模式是一个有用的工具箱，它有很多好处，但也有一些缺点。 MVVM：**(优点)**MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点 1. 低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 2. 可重用性：你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 3. 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。 4. 可测试：界面素来是比较难于测试的，测试可以针对ViewModel来写。 定义：MVC：​ MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 MVVM：​ MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。微软的WPF带来了新的技术体验，如Silverlight、音频、视频、3D、动画……，这导致了软件UI层更加细节化、可定制化。同时，在技术层面，WPF也带来了 诸如Binding、Dependency Property、Routed Events、Command、DataTemplate、ControlTemplate等新特性。MVVM（Model-View-ViewModel）框架的由来便是MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架。它立足于原有MVP框架并且把WPF的新特性糅合进去，以应对客户日益复杂的需求变化。 区别：&gt;MVC的缺点： &gt; &gt;1.所有业务逻辑都在Controller里操作，逻辑复杂且不利于维护， &gt;2.大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 &gt;3.当 Model 频繁发生变化，需要主动更新到View ；当用户的操作导致Model发生变化，同样需要将变化的数据同步到Model中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。 由于MVC模式的缺陷，所以衍生出来MVC的变种模式MVVM模式 MVVM的核心是提供了View 和 ViewModel的数据双向绑定，View 和 model之间并没有直接的联系，而是通过了ViewModel联系了起来，而且数据双向绑定将View 和 Model之间的同步工作自动化，不需要人为干涉，所以我们开发者只需要关注业务逻辑即可，所以像Vue，React这样的框架我们是不需要直接的去操作DOM的，其复杂的数据维护状态都交给了MVVM来统一管理。 框架和设计模式的区别MVC是一种设计模式。框架、设计模式这两个概念总容易被混淆，其实它们之间还是有区别的。框架通常是代码重用，而设计模式是设计重用，架构则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。在软件生产中有三种级别的重用：内部重用，即在同一应用中能公共使用的抽象块;代码重用，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用；应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。 框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。可以说，框架是软件，而设计模式是软件的知识。 框架模式有哪些？ MVC、MTV、MVP、CBD、ORM等等；","categories":[],"tags":[{"name":"软件设计模式","slug":"软件设计模式","permalink":"https://1314xulujin.github.io/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"杰哥面试经验题目","slug":"杰哥面试经验题目","date":"2020-06-01T09:47:56.000Z","updated":"2020-06-21T13:10:21.377Z","comments":true,"path":"2020/06/01/杰哥面试经验题目/","link":"","permalink":"https://1314xulujin.github.io/2020/06/01/%E6%9D%B0%E5%93%A5%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E9%A2%98%E7%9B%AE/","excerpt":"","text":"1.一个flex布局.2.promise原理3.组件通信的方法4.路由守卫有哪些5.vuex的通信原理6.如何使用webpack实现构建优化7.你过去项目遇到过哪些困难问题，如何解决的8.继承类型9.一个数据类型如何判断","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"中软推到步步高的第一轮面面试","slug":"中软推到步步高的第一轮面面试","date":"2020-06-01T07:02:48.000Z","updated":"2020-06-21T13:10:21.333Z","comments":true,"path":"2020/06/01/中软推到步步高的第一轮面面试/","link":"","permalink":"https://1314xulujin.github.io/2020/06/01/%E4%B8%AD%E8%BD%AF%E6%8E%A8%E5%88%B0%E6%AD%A5%E6%AD%A5%E9%AB%98%E7%9A%84%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%9D%A2%E9%9D%A2%E8%AF%95/","excerpt":"","text":"中软推到步步高小天才的第一轮面面试(电话)主要问到的难点： 1.vue自定义指令。 ​ 答： ​ 首先，使用模块化划分自定义指令的文件夹，命名为directives，其中index.js导出一个Vue的install自定义插件的方法，可以在里面注册需要注册指令名字，例如 1234567&lt;!--template里面--&gt;&lt;template&gt; &lt;div&gt; &lt;input v-focus /&gt; 点击 &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617// 注册一个全局自定义指令// directives/index.jsimport Permission from &#x27;./permission&#x27;export default &#123; install (Vue, options) &#123; Vue.directives(&#x27;focus&#x27;, Permission) &#125;&#125;// directives/permission.jsexport default &#123; inserted (el, binding) &#123; // el是指令所绑定的元素，可以用来直接操作 DOM，binding是一个对象，包含指令名，指令绑定的值，arg传给指令的参数。 // 可以在这里写指令对DOM的一些逻辑操作等等(会用于按钮鉴权) el.focus() &#125;&#125; 123456789// 如果想注册局部指令，组件中也接受一个 directives 的选项directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 2.vue动态路由。 ​ 答： ​ 定义：动态路由是指路由器能够自己创建自己的路由表，并且能够根据实际情况进行变化实时的对路由进行调整，实际代码中动态路径匹配的参数后面会接冒号，具体代码如下: 12345678910const router = new VueRouter (&#123; routes: [ &#123; path: &#x27;/user/:id&#x27;, component: User &#125; ]&#125;) 具体涉及到动态路由传参参考本博客文章:https://1314xulujin.github.io/2020/05/27/vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82/ ​ 3.深拷贝浅拷贝是什么，区别，代码实现。 ​ 答： ​ 1.区别： 其实深拷贝和浅拷贝的主要区别就是其在内存中的存储类型不同，堆和栈都是内存中划分出来用来存储的区域。 ​ 深拷贝会将一个对象的子属性也拷贝进去，且会生成一个另外的存储区域，浅拷贝不会。 ​ 2.代码实现： ​ 浅拷贝 1 ​ 深拷贝 1 提问速度较快，建议回答的时候慢一点，别卡壳","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"vue路由传参","slug":"vue路由传参","date":"2020-05-27T00:56:47.000Z","updated":"2020-06-21T13:10:21.300Z","comments":true,"path":"2020/05/27/vue路由传参/","link":"","permalink":"https://1314xulujin.github.io/2020/05/27/vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82/","excerpt":"","text":"vue路由传参1.传过去的参数为一个对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 let VideoGx = &#123; data()&#123; return &#123; list:[ &#123; id:202004280001, title:&#x27;惊雷，赵日天爆出惊人秘密...&#x27; &#125;, &#123; id:202004280002, title:&#x27;今天天气情况啊啊 啊 &#x27; &#125;, &#123; id:202004280003, title:&#x27;撒的撒打算打算的撒是的撒的飒飒&#x27; &#125;, &#123; id:202004280004, title:&#x27;今日基金大涨，A股用户赚翻！！！&#x27; &#125; ] &#125; &#125;, template: ` &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;item&quot; v-for=&quot;(v,k) in list&quot; :key=&quot;v.id&quot;&gt; &lt;div class=&quot;thumb&quot;&gt;&#123;&#123;v.id&#125;&#125;&lt;/div&gt; &lt;router-link :to=&quot;&#123;path:&#x27;/video/play/&#x27;+v.id&#125;&quot;&gt;&#123;&#123;v.title&#125;&#125;&lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; ` &#125; let routes = [ &#123;//配置一个首页的路由 path: &quot;/home&quot;, component: Home &#125;, &#123; path: &quot;/video&quot;, component: Video, redirect:&quot;/video/gx&quot;,//配置默认显示的重定向路由 children: [//配置子路由 &#123; path: &quot;/video/gx&quot;, component: VideoGx &#125;, &#123; path: &quot;/video/ty&quot;, component: VideoTy &#125;, &#123; path: &quot;/video/kj&quot;, component: VideoKj &#125;, &#123; path:&quot;/video/play/:id?&quot;, //1.设置接收的参数为id ,?就是正则中的可有可没有的作用，写了? 没有传id也能匹配到当前路由 component:VideoPlay &#125; ] &#125;, &#123; path: &quot;/music&quot;, component: Music, redirect:&quot;/music/rap&quot;, children: [//配置子路由 &#123; path: &quot;/music/gd&quot;, component: MusicGd, &#125;, &#123; path: &quot;/music/top&quot;, component: MusicTop &#125;, &#123; path: &quot;/music/rap&quot;, component: MusicRap &#125; ] &#125;, &#123; // 会匹配以 `/user-` 开头的任意路径 path: &quot;/user-*&quot;, component: Home &#125; , &#123; path:&quot;/&quot;, redirect:&quot;/home&quot; &#125;, &#123;//配置任意匹配路由，404处理，一定要注意：在路由的最后添加（匹配顺序就是从上往下） path: &quot;*&quot;, component: ErrorPage &#125; ];// 在地址栏获取 2.参数有name和一个params对象（参数会消失） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788let VideoGx = &#123; data()&#123; return &#123; list:[ &#123; id:202004280001, title:&#x27;惊雷，赵日天爆出惊人秘密...&#x27; &#125;, &#123; id:202004280002, title:&#x27;今天天气情况啊啊 啊 &#x27; &#125;, &#123; id:202004280003, title:&#x27;撒的撒打算打算的撒是的撒的飒飒&#x27; &#125;, &#123; id:202004280004, title:&#x27;今日基金大涨，A股用户赚翻！！！&#x27; &#125; ] &#125; &#125;, template: ` &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;item&quot; v-for=&quot;(v,k) in list&quot; :key=&quot;v.id&quot;&gt; &lt;div class=&quot;thumb&quot;&gt;&#123;&#123;v.id&#125;&#125;&lt;/div&gt; &lt;router-link :to=&quot;&#123;name:&#x27;video-play&#x27;,params:&#123;id:v.id,hh:[&#x27;1124321&#x27;,&#x27;fffsff&#x27;]&#125;&#125;&quot;&gt;&#123;&#123;v.title&#125;&#125;&lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; ` &#125; let routes = [ &#123;//配置一个首页的路由 path: &quot;/home&quot;, component: Home &#125;, &#123; path: &quot;/video&quot;, component: Video, redirect:&quot;/video/gx&quot;,//配置默认显示的重定向路由 children: [//配置子路由 &#123; path: &quot;/video/gx&quot;, component: VideoGx &#125;, &#123; path: &quot;/video/ty&quot;, component: VideoTy &#125;, &#123; path: &quot;/video/kj&quot;, component: VideoKj &#125;, &#123; path:&quot;/video/play&quot;, name:&#x27;video-play&#x27;, component:VideoPlay &#125; ] &#125;, &#123; path: &quot;/music&quot;, component: Music, redirect:&quot;/music/rap&quot;, children: [//配置子路由 &#123; path: &quot;/music/gd&quot;, component: MusicGd, &#125;, &#123; path: &quot;/music/top&quot;, component: MusicTop &#125;, &#123; path: &quot;/music/rap&quot;, component: MusicRap &#125; ] &#125;, &#123; // 会匹配以 `/user-` 开头的任意路径 path: &quot;/user-*&quot;, component: Home &#125; , &#123; path:&quot;/&quot;, redirect:&quot;/home&quot; &#125;, &#123;//配置任意匹配路由，404处理，一定要注意：在路由的最后添加（匹配顺序就是从上往下） path: &quot;*&quot;, component: ErrorPage &#125; ];// 在地址栏看不到 3.参数有name和一个键名为query的对象（刷新页面参数不会消失） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 //添加视频的子路由页面组件 let VideoGx = &#123; data()&#123; return &#123; list:[ &#123; id:202004280001, title:&#x27;惊雷，赵日天爆出惊人秘密...&#x27; &#125;, &#123; id:202004280002, title:&#x27;今天天气情况啊啊 啊 &#x27; &#125;, &#123; id:202004280003, title:&#x27;撒的撒打算打算的撒是的撒的飒飒&#x27; &#125;, &#123; id:202004280004, title:&#x27;今日基金大涨，A股用户赚翻！！！&#x27; &#125; ] &#125; &#125;, template: ` &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;item&quot; v-for=&quot;(v,k) in list&quot; :key=&quot;v.id&quot;&gt; &lt;div class=&quot;thumb&quot;&gt;&#123;&#123;v.id&#125;&#125;&lt;/div&gt; &lt;router-link :to=&quot;&#123;name:&#x27;video-play&#x27;,query:&#123;id:v.id,type:&#x27;gx&#x27;&#125;&#125;&quot;&gt;&#123;&#123;v.title&#125;&#125;&lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; ` &#125; let routes = [ &#123;//配置一个首页的路由 path: &quot;/home&quot;, component: Home &#125;, &#123; path: &quot;/video&quot;, component: Video, redirect:&quot;/video/gx&quot;,//配置默认显示的重定向路由 children: [//配置子路由 &#123; path: &quot;/video/gx&quot;, component: VideoGx &#125;, &#123; path: &quot;/video/ty&quot;, component: VideoTy &#125;, &#123; path: &quot;/video/kj&quot;, component: VideoKj &#125;, &#123; path:&quot;/video/play&quot;, name:&#x27;video-play&#x27;, component:VideoPlay &#125; ] &#125;, &#123; path: &quot;/music&quot;, component: Music, redirect:&quot;/music/rap&quot;, children: [//配置子路由 &#123; path: &quot;/music/gd&quot;, component: MusicGd, &#125;, &#123; path: &quot;/music/top&quot;, component: MusicTop &#125;, &#123; path: &quot;/music/rap&quot;, component: MusicRap &#125; ] &#125;, &#123; // 会匹配以 `/user-` 开头的任意路径 path: &quot;/user-*&quot;, component: Home &#125; , &#123; path:&quot;/&quot;, redirect:&quot;/home&quot; &#125;, &#123;//配置任意匹配路由，404处理，一定要注意：在路由的最后添加（匹配顺序就是从上往下） path: &quot;*&quot;, component: ErrorPage &#125; ];// 参数不会显示在地址栏","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://1314xulujin.github.io/tags/vue/"}]},{"title":"原生jsonp跨域","slug":"原生jsonp跨域","date":"2020-05-27T00:56:47.000Z","updated":"2020-06-21T13:10:21.366Z","comments":true,"path":"2020/05/27/原生jsonp跨域/","link":"","permalink":"https://1314xulujin.github.io/2020/05/27/%E5%8E%9F%E7%94%9Fjsonp%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"原生jsonp跨域123456789101112131415161718192021222324252627282930313233343536373839// 封装一个jsonp跨域的方法function jsonp (obj) &#123; // 首先全局回调 window[callback] = function (object) &#123; obj.success.(json.parse(object)) &#125; // 请求的地址 var requestSrc = obj.url for( key in obj.data )&#123; requestSrc += &#x27;&amp;&#x27;+key+&#x27;=&#x27;+obj.data[key] &#125; requestSrc = requestSrc.slice(1) requestSrc += &#x27;&amp;callback=&#x27;+&#x27;jsonp&#x27;+Date.now() var script = document.createElement(&#x27;script&#x27;) script.src = requestSrc document.body.appendChild(script) // 在脚本加载完成后立即销毁 script.onload = function () &#123; document.body.removeChild(this) &#125;&#125;// 调用jsonp(&#123; url: &#x27;https://www.baidu.com&#x27;， data: &#123; id: 1, nickname: &#x27;张三&#x27; &#125;， success:function (res) &#123; console.log(res) &#125; &#125;)","categories":[],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://1314xulujin.github.io/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"vue组件通信全揭秘_共7章","slug":"vue组件通信全揭秘-共7章-掘金社区","date":"2020-05-24T23:44:37.000Z","updated":"2020-06-21T13:10:21.295Z","comments":true,"path":"2020/05/25/vue组件通信全揭秘-共7章-掘金社区/","link":"","permalink":"https://1314xulujin.github.io/2020/05/25/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%85%A8%E6%8F%AD%E7%A7%98-%E5%85%B17%E7%AB%A0-%E6%8E%98%E9%87%91%E7%A4%BE%E5%8C%BA/","excerpt":"","text":"vue组件通信全揭秘(共7章)这文章在一年前已经写出来了。今天还是决定放出来供所有人学习。为什么我会写vue组件通信全揭秘，因为无论任何组件模式的框架。组件是核心，只有把组件写组件之间能理顺了。项目也就自然顺了。内容非常多，而且一年后我觉得组件的通信部分的没有任何变化。没有任何一点过时。希望对大家有帮助 第01课：给你一个不学 Vue 的理由什么是 VueVue 是尤雨溪一个人的项目，是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。 Vue 通过 Api 来进行统一性的管理，可以让整个团队的代码都用统一的风格和方法标准去运作，而且对组件系统也有强大的支持，在封装组件时通过 Props 和 Event 两个标准性的原则去调用，可以让开发更加得心应手。 请给一个不学 Vue 的理由如果非要让我说一个不学 Vue 的理由，可能是它的写法太方便了……你也可能觉得它借鉴的太多，没有亮眼的地方，那我只能说同样实现的东西就是那么方便，简洁的教程和 Api 文档接入整个开发体系，相当符合中国市场的开发——业务变动大、版本要求上线快、需求改动频繁、学习成本低……相比之下，同样有着高效的功能，集成了组件系统和 Virtual DOM。 阅读这一系列课程你可以学到什么？掌握 Vue 主要就是正确理解教程和深入掌握 Api 的用法，不但要会用，更重要的是学会对症下药，在任何一种场景下使用最简洁、最正确、最合理的代码才是关键。只有对 Api 和教程有了一定程度的项目实战和组件库实战经验才能把它用的游刃有余。 在 Vue2.0 起步的时候我在掘金上进行了 Vue 课程的一系列套课的讲解，从基础到 Vuex，最后到组件库的实战都进行了简单的讲解。期间也经过大量的项目实战和组件库的实践，通过一步步总结，对 Api 文档的深入理解和测试性模拟，总结了一些真实场景的正确用法和常用案例需求，让你在开发中少走弯路，少刨坑。 除了 Vue 还能学到什么在 Vue 开发中，我们不但要准确的运用 Api，还要结合 es6 的新语法，用更深更强大的新特性来组织代码，这同样也是下一代 Javascript 的标准： let 和 const 命令 变量的解构赋值 字符串的扩展 函数的扩展 数组的扩展 对象的扩展 Promise 对象 async 函数 在此次教程中将会展示 es6 大量的新语法进行，只有不断的进行尝试，才能有不同的成效。 本课程的优势如果你想快速上手进行一个特别面向 C 端的 Mobile 产品开发，甚至是一个中大型的项目开发，如果你能完全阅读完所有课程，并且跟着一步步实践，那么你同样也能给自己的C端产品设计一套属于自己的组件库，毕竟通用型的组件库仍然具备面对市场竞争需求的独特性。 本课程分享的内容是 Vue 的最新版本，可以说这是一套独一无二的教程，不但会结合官方教程和 Api，最主要的是告诉大家在什么场景用什么方式组织代码，避开不必要的坑。 数据驱动架构体系永远离不开组件模式。在这里我会给大家分享级别组件的划分内部原则性，在自己打造组件库的同时，也大量借鉴了各大厂商团队的优秀组件写法，进行比对优缺点，总结相应的理论。 课程大纲如下 01 开启 Vue 之旅 02 灵活的 data，死板的 props 03 $on ， $emit ， v-on 三者关系 04 .sync 王者回归，v-model 使命将至 05 $attrs ， $listeners 深组件通信 06 智能组件与木偶组件的正确通信 07 你不知道的中央事件通信 本课设计想法当我在掘金写下第一篇文章的时候，虽然只是很基础的部分，但文章在两天内获得了大量关注，这充分显示出了中国市场的开发者们对 Vue 的渴望程度。与此同时，我也收集到了一些批评意见，对于读者的反馈能及时做出响应才更能体现出一个课程的价值。 不是能写出源码的教程就是对你有帮助，也并不是写的很基础就对你没有帮助。不是每个人都能当大上牛、进入大公司的研发团队，大多数程序员都是面对业务层面的开发。因此如何在市场上有立足之地，能快速接手项目，这才是大部分人应该最需要发力的地方。 学习本课程你需要做些什么？学习本课程的同学需要对 Html 和 JavaScript 的基础知识有一定了解，理解 es6 基础新特性，了解 npm 和 node 的基本用法。 推荐： 阮一峰老师的es6入门 别浪费时间看别的了，如果你能静下来看完整本书，比任何 es6 其它书籍都好，为什么呢？平民化，就像 Vue 一样，很容易让人理解。 同时在学习本教程的时候，尽量跑一遍 Vue 中文官网结合 Api 你能看懂的示例。 cn.vuejs.org/ 可能有些 Api 或者教程只有一个简单的解释，还特别官方话，没关系，跟着我一步一步敲遍所有的 Demo。 开启 Vue 之旅在整理好心情开始旅程之时，我们往往都会带上许多必备工具，同样 Vue 在面向开源之时，周边的身态也向其靠拢。 vue-devtool 以往 Dom 操作的时候，我们都是通过 dubger 断点来进行错点查找和基础数据驱动，dubger 已经派不上什么用场了，只有通过观察数据的变化，才能准确的定位到错识变化的数据和是否执行了需要的事件。 就用商店输入vue自行安装 ![img](data:image/svg+xml; utf8, ) vue-cli Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目： 进入 Node.js 官网，下载 Node.js 安装包； 为了下载安装包快速一点，走淘宝源进入 cli 终端； 1234567891011运行npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 全局安装 vue-cli$ npm install --global vue-cli 创建一个基于 webpack 模板的新项目$ vue init webpack my-project 安装依赖，走你$ cd my-project$ npm install$ npm run dev复制代码 打开文件夹，本次教程的示例全部通过 Components 文件夹来定义单个组件，进行 SPA 的应用开发，用单 .vue 文件也更加直观，一个文夹可能是一个 Page，也可能是一个 Component；在开启 Vue 的旅程之时，拿 todo-list 尝试一下它的神奇魔法，通过 Vue 实例和模板进行数据与行为的交互绑定；实例的每个选项如何与定义的模板值进行一一对应，通过数据驱动、事件绑定，来轻松高效的实现一个 todoList 应用。相比 Juqery 这种操作 Dom 的冷兵器时代，给开发者的感觉是完全变了一种模式，延续着 Html 写法的友好性和适应度，同样还提供了 JSX 语法，Vue 官网说是一个渐进式框加，写法也同样是渐近式，让开发者以不畏惧的心态使用，而且 Vue 的数据驱动模式提供了大量的 Api，每个 Api 无论是实例选项还是实例属性都负责着自己的职责，它们就像五金店的零件一样，只有正确的使用每个 Api 特性并且作用到恰当的地方，Vue 工程代码组织结构和后续的维护才会显得易如反掌。在组件化工程化没到来的时候，业务的实现复杂度并不是最难的，反而令人头疼的是对代码后续的版本迭代、重构、复用等一系列问题，希望通过简单的 todo-list 应用，可以对前端开发革命有新的认识！ 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;input type&#x3D;&quot;text&quot; v-model.trim&#x3D;&quot;msg&quot; @keyup.enter&#x3D;&quot;push&quot;&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;(item,index) in list&quot; :key&#x3D;&quot;index&quot; @click&#x3D;&quot;deleteItem(index)&quot;&gt; &#123;% raw %&#125;&#123;&#123;index&#125;&#125;&#123;% endraw %&#125; &#123;% raw %&#125;&#123;&#123;item.name&#125;&#125;&#123;% endraw %&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &#39;todo-list&#39;, data () &#123; return &#123; msg: &quot;&quot;, list: [] &#125; &#125;, methods: &#123; push () &#123; this.list.push(&#123;name:this.msg&#125;) this.msg &#x3D; &quot;&quot; &#125;, deleteItem (index) &#123; this.list.splice(index,1) &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 本章通过这个示例 Demo 表现 Vue 数据驱动式框架运作是如何简单到令人窒息。 一个 todo-list 应用集成了两个事件，两条 data 数据就完成了！ 通过 Template 里的 Html 模版能清楚的观察到绑定信息，数据联动和时时改动： v-model 里的 msg 和实列 data 里存放的数据进行了绑定 @keyup.enter=”push” 对键盘事件 keyup 进行监听，同时用 enter 修饰符进行 enter 按键进行监听，当触行 methods 里的 push 函数，向整个 list 列表里添加一条 object 数据 通过 v-for 指令循环出整个 list 里的数据，循环出相对应的节点数 点击每个节点的时候执行 deleteItem 事件，删除对应的节点 对于往时操作dom写法和当前的数据驱动有什么区别？ 数据渲染，我们会通过第三方的模版引擎，比如 artTemplate，Jade 等等，渲染完毕之后再 append 到根元素中。 Vue 只是通过一个 v-for 指令循环所有对应的节点，先前只要在 Html 中写好循环模板。 执行事件，需要获取 DOM 元素，对 DOM 元素 addEventlistener 事件，再进行函数。 Vue 直接通过你的 Template 集成的模版在需要发生事件的元素上直接绑定事件，只要执行一个 v-on 结合你需要绑定的事件，所有原生的事件都支持。 需要存储数据时，我们需要定一堆变量，有局部变量和全局变量，导致后续的变量难以维护，甚至可能会导致变量名冲突，作用域调用错误，无法准确定位到正确的数据源。 Vue 通过 data 选项，用每个属性去保存渲染的数据和临时过度的数据，用统一 data 选项去保存，让使用者一目了然。 所有执行的函数，无论是事件所需要执行的，还是封装所需要调用的函数，通过函数式声明在 script 标签内写入，代码量大了，也会存在变量名冲突，和无法准确的定位方法。 Vue 通过 Methods 选项专门为事件所执行的函数和所封装需要调用的函数，就像垃圾桶一样，有一个准确的、可投放的位置，需要找到执行和所需调用的函数，直接可以准确定位到 Methods 选项。 平时我们要对有些数据进行一些处理，比方说去除有后空格，按键的定位，都要通过 js 去过滤或者判断。 Vue 提供了大量的修饰符封装了这些过滤和判断，让开发者少写代码，把时间都投入的业务、逻辑上，只需要通过一个. 修饰符去调用。 以上只是一个简单 todo-list Demo 总结出来的例子，文中所提到的也只是部分功能优势，还有很多功能可以让开发路径更加快速。重点在于数据驱动的模式，只要把组件与组件之间的通信掌握了，也就相当于你就手握大半江山，因为一切的一切都是基于组件通信模式和结构用法来的。 下篇课程导读： 数据驱动一切都是一数据，只有灵活把控对数据的理解，才能自如的运用，在 Vue 里灵活的 data，死板的 props，是存放数据的和传递数据的基点。 第02课：灵活的 data，死板的 props事件驱动在前端来说数据驱动式框架，必然离不开事件驱动，事件驱动一定程度上弥补了数据驱动的不足，在 dom操作 的时代通常都是这样操作： 通过特定的选择器查找到需要操作的节点 -&gt; 给节点添加相应的事件监听 响应用户操作，效果是这样： 用户执行某事件（点击，输入，后退等等） -&gt; 调用 JavaScript 来修改节点 这种模式对业务来说是没有什么问题，但是从开发成本和效率来说会比较力不从心，在业务系统越来越庞大的时候，就显得复杂了。另一方面，找节点和修改节点这件事，效率本身就很低，因此出现了数据驱动模式。 数据驱动 读取模板，同时获得数据，并建立 VM( view-model ) 的抽象层 -&gt; 在页面进行填充 要注意的是， MVVM 对应了三个层， M - Model ，可以简单的理解为数据层； V - View ，可以理解为视图，或者网页界面； VM - ViewModel ，一个抽象层，简单来说可以认为是 V 层中抽象出的数据对象，并且可以与 V 和 M 双向互动 （一般实现是基于双向绑定，双向绑定的处理方式在不同框架中不尽相同）。 用户执行某个操作 -&gt; 反馈到 VM 处理（可以导致 Model 变动） -&gt; VM 层改变，通过绑定关系直接更新页面对应位置的数据 可以简单地理解：数据驱动不是操作节点的，而是通过虚拟的抽象数据层来直接更新页面。主要就是因为这一点，数据驱动框架才得以有较快的运行速度（因为不需要去折腾节点），并且可以应用到大型项目。 Vue 模式Vue 通过 {{}}` 绑定文本节点， `data` 里动态数据与 `Props` 静态数据进行一个映射关系，当 `data` 中的属性或者 `props` 中的属性有变动，以上两者里的每个数据都是行为操作需要的数据或者模板 view 需要渲染的数据，一旦其中一个属性发生变化，则所有关联的行为操作和数据渲染的模板上的数据同一时间进行同步变化，这种基于数据驱动的模式更简便于大型应用开发。只要合理的组织数据和代码，就不会显得后续皮软。 ### 何为动态数据 data，何为静态数据 props #### 相同点 两者选项里都可以存放各种类型的数据，当行为操作改变时，所有行为操作所用到和模板所渲染的数据同时都会发生同步变化。 #### 不同点 Data 被称之为动态数据的原因，在各自实例中，在任何情况下，我们都可以随意改变它的数据类型和数据结构，不会被任何环境所影响。 Props 被称之为静态数据的原因，在各自实例中，一旦在初始化被定义好类型时，基于 Vue 是单向数据流，在数据传递时始终不能改变它的数据类型。 更为关键地是，对数据单向流的理解， `props` 的数据都是通过父组件或者更高层级的组件数据或者字面量的方式进行传递的，不允许直接操作改变各自实例中的 `props` 数据，而是需要通过别的手段，改变传递源中的数据。 ### data 选项 当一个实例创建的时候， `Vue` 会将其响应系统的数据放在 `data选项中` ，当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。初始定行的行为代码也都会随着响应系统进行一个映射。 而 data 选项中的数据在实例中可以任意改变，不受任何影响，前提必须数据要跟逻辑相辅相成。 ### 初始化映射 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;p v-if&#x3D;&#39;boolean&#39;&gt;true&lt;&#x2F;p&gt; &lt;p v-for&#x3D;&#39;value in obj&#39;&gt;&#123;% raw %&#125;&#123;&#123;value&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;p v-for&#x3D;&#39;item in list&#39;&gt;&#123;% raw %&#125;&#123;&#123;item&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;StringMsg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;NumberMsg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; obj : &#123;a:&#39;1&#39;,b:&#39;2&#39;,c:&#39;3&#39;&#125;, list:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;], boolean : true, StringMsg : &#39;hello vue&#39;, NumberMsg : 2.4, &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 运行代码时，在 `data选项` 里定义了五种数据类型，通过指令和 `{{}} 进行渲染，证实了 data选项 里可以 定义任何数据类型 。 视图与数据映射123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;StringMsg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;NumberMsg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&#39;changeData&#39;&gt;改变数据&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; StringMsg : &#39;hello vue&#39;, NumberMsg : 2.4 &#125; &#125;, methods: &#123; changeData () &#123; this.StringMsg &#x3D; 2.4; this. NumberMsg &#x3D; &#39;hello vue&#39; &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 每个.vue 的文件则就是一个实例，在 data 中定义了两种数据： String 类型 Number 类型 同时还定义了一个 changeData 事件。 在运行代码时候， data选项 已经进入了 Vue的响应系统 里， model层 (数据层)与 view层 (视图层)进行了对应的映射，任何数据类型都可以定义。 当用户发生点击操作的时候，同时可以把 StringMsg， NumberMsg 的数据对调，充分说明了， 无论值和类形都可以进行随意转换 。 行为与数据的映射1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;StringMsg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;NumberMsg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&#39;changeData&#39;&gt;改变数据&lt;&#x2F;button&gt; &lt;button @click&#x3D;&#39;findData&#39;&gt;查看数据&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; StringMsg : &#39;hello vue&#39;, NumberMsg : 2.4 &#125; &#125;, methods: &#123; changeData () &#123; this.StringMsg &#x3D; 2.4; this.NumberMsg &#x3D; &#39;hello vue&#39; &#125;, findData () &#123; console.log( &#96;StringMsg: $&#123;this.StringMsg&#125;&#96; ) console.log( &#96;NumberMsg: $&#123;this.NumberMsg&#125;&#96; ) &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 改变数据以后，通过点击 findData 事件来进行验证，虽然在初始化定义好了行为数据的检测代码，但是当数据在执行 findData 之前先执行 changeData，一旦改变 data 选项里的数据时，findData 里对应的数据同时也会进行相应的映射。 this. StringMsg //=&gt; 2.4 this. NumberMsg //=&gt;’hello vue’ 总结： data 选项里的数据是灵活的 可以定义任何数据类型 也可以改变成任何数据类型 当数据变化时，视图和行为绑定的数据都会同步改变 props使用 props 传递数据作用域是孤立的，它是父组件通过模板传递而来，想接收到父组件传来的数据，需要通过 props选项 来进行接收。 子组件需要显示的声明接收父组件传递来的数据的 数量 ， 类型 ， 初始值 。 简单的接收可以通过数组的形式来进行接收。 父组件1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;demo :msg&#x3D;&#39;msgData&#39; :math &#x3D; &#39;mathData&#39; &gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; data () &#123; return &#123; msgData:&#39;从父组件接收来的数据&#39;, mathData : 2 &#125; &#125;, components : &#123; Demo &#125; &#125;&lt;&#x2F;script&gt;复制代码 子组件1234567891011121314&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;msg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;math&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, props: [ &#39;msg&#39; , &#39;math&#39;],&#125;&lt;&#x2F;script&gt;复制代码 在子组件中需要通过显示定义好需要从父组件中接收那些数据。 同样的在父组件中在子组件模板中过 v-bind 来传递子组件中需要显示接收的数据。 语法： ：== v-bind(是封装的语法糖) ：msg = msgData msg 第一个参数必须要与子组件的 props 同名 msgData 则是父组件中需要向子组传递的数据 props 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。 父组件12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;demo :fn &#x3D; &#39;myFunction&#39; &gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; components : &#123; Demo &#125;, methods: &#123; myFunction () &#123; console.log(&#39;vue&#39;) &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 子组件12345678910111213&lt;template&gt; &lt;div&gt; &lt;button @click&#x3D;&#39;fn&#39;&gt;按钮&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, props: [ &#39;fn&#39; ],&#125;&lt;&#x2F;script&gt;复制代码 同样，在父组件中也可以向子组件中传递一个 function ，在子组件同样也可以执行父组件传递过来的 myFunction 这个函数。 字面量语法和动态语法对于字面量语法和动态语法，初学者在父组件模板中向子组件中传递数据时加和不加 v-bind 有什么区别，同时会引起什么错语等问题会感觉迷惑。 在子组件模板上传递数据时加 v-bind 意味着什么 ？v-bind:msg = &#39;msg&#39; 通过 v-bind 进行传递数据并且传递的数据并不是一个字面量，双引号里的解析的是 一个表达式 ，同样也可以是实例上定义的数据和方法(其实就是引用一个变量）”。 msg=&#39;11111&#39; 没有 v-bind 的模式下只能传递一个字面量，这个字面量只限于 String 类量，字符串类型。 注意： 虽然通过字面量模式下，传任何类型都会被转成字符串类型，但是在子件接收的时候可以通过 typeof 去进行类型检测。 字面量写法除了 String 类型想通过字面量进行数据传递时，如果想传递 非String类型 ，必须 props 名前要加上 v-bind ，内部通过实例寻找，如果实例方没有此属性和方法， 则默认为对应的数据类型 。 :msg=&#39;11111&#39; //number :msg=&#39;true&#39; //bootlean :msg=&#39;()=&gt;&#123;console.log(1)&#125; //function :msg=&#39;&#123;a:1&#125; //object 子组件模板 props 定义问题1.0版本时HTML 特性是不区分大小写的，所以当使用的不是字符串模板，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名。 注意由于文档上仍然有这句话，经过测试后，无论是不是字符串模板，camelCased (驼峰式) 和 kebab-case (短横线隔开式) 两者都可以。 建议为了直观性，规范性还是推荐 kebab-case (短横线隔开式)。 对象传递简写props 原子化可以让整体代码逻辑和向外暴露需要传递数据的接口非常清晰，但是同样可以把子组件需要接收的 props 在父组件中以一个对象进行传递。 当传递的数量一旦多到已经让原子化不再结构清晰的时候，通过一个对象传递显得更为简洁明了。 父组件12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;demo v-bind&#x3D; &#39;msg&#39; &gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; components : &#123; Demo &#125;, data () &#123; return &#123; msg : &#123;a:1,b:2&#125; &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 子组件1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;button&gt;按钮&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, props: [&#39;a&#39;,&#39;b&#39;], created () &#123; console.log(this.a) console.log(this.b) &#125;,&#125;&lt;&#x2F;script&gt;复制代码 `` 内部发生了什么？在子组件模板内部对其 进行了一个封装 ，把其展开则跟 props 原子化原理是一个原理 `` 通常情况下建议使用第二种，props 原子化。 不可变的 props在 data 选项中，当前实例（当前组件中改动）可以 任意改变data选项里的数据 ， Vue 传递数据时是基于 数据单向流动 ，子组件不能改变当前实例中的 props 任何属性，需要通知父组件改变相应的值，重新改变。 直接改变 props 数据123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;button @click&#x3D;&#39;changeProps&#39;&gt;按钮&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, props: [&#39;msg&#39;], methods: &#123; changeProps () &#123; this.msg &#x3D; &#39;new msg&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 直接改变 props 时会发生一个警告报错 [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “msg” 防止数据的 不可控性 ，不能显示的直接改变，父组件的传递来的数据和子组接 props 接收的数据也是同步响应的，一旦父组件向下传递的数据改变时，prop 接收的数据值也会同样发生变化。 单向数据流的原因也是如此，就像河流一样，水只会从高向低流，想让水的质量改变，只有从源头改变。 父组件改动1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;demo :msg &#x3D; &#39;msg&#39; &gt;&lt;&#x2F;demo&gt; &lt;button @click&#x3D;&#39;msg &#x3D; &quot;new vue&quot;&#39;&gt;按钮&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; components : &#123; Demo &#125;, data () &#123; return &#123; msg : &#39;vue&#39; &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 在父组件中初始化传递过后，想要改变子组件的数据，可以通过再次改变向子组件传递的 msg 数据，子组件渲染的视图同样会跟着同步改动。 一次性传递，过渡改动虽然 props 是不可改动的，上面的 case 是父组件进行改变自身实例的的数据，这个实现很简单，有时经过一次数据传递，不需用父组件再次传递，因为一些需求需要改动 props 数据，可以用过渡的方法，让其转换为一个可变的数据。 过渡到 data 选项中12345props: [&#39;msg&#39;],data: function () &#123; return &#123; myMsg: this.msg &#125;&#125;复制代码 在 data 选项里通过 myMsg 接收 props msg 数据，相当于对 myMsg = msg 进行一个赋值操作，不仅拿到了 myMsg 的数据，而且也可以改变 myMsg 数据。 this.myMsg = ‘new Vue’ myMsg 会发生相应的改变。 一次性传递，过滤处理依然是通过 props 一次性接收，想对接收的 prop 进行一些过滤操作再次进行视图渲染，可以在一些计算属性中进行操作，可以 computed 监听 props 里的数据变化，经过过滤操作返回一个需要的值。 1234567props:[&#39;msg&#39;]computed : &#123; computedMsg () &#123; return this.msg + 1 &#125;&#125;复制代码 注意： 在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。不要对父组件传递来的引用类型数据进行过滤。 下篇导读 本章对 props 和 data 的用法理解已经进行了全面的讲解，通过再次改变传递数据时是在父组件的实例里进行实施的。往往特定的需求和一些组件封装触发传递的命令并不能直接在父组件执行，需要子组件通知上层组件。 再近一步说，子组件改变不了父组件传递的数据，但是子组件可以用通信的方式，通知子组件改动，因此 $on ， $emit ，v-on 深入理解这三者关系尤为重要！ 第03课： emit，v-on 三者关系 用家庭来描述 $emit ， $on 的关系每个 Vue 实例都实现了事件接口： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 如果把 Vue 看成一个家庭（相当于一个单独的 components )，女主人一直在家里指派 ($emit) 男人做事，而男人则一直监听 ($on) 着女士的指派 ($emit)里eventName 所触发的事件消息，一旦 $emit 事件一触发， $on 则监听到 $emit 所派发的事件，派发出的命令和执行派执命令所要做的事都是一一对应的。 Api 中的解释： 1vm.$emit( event, […args] ) 参数： &#123;string&#125; event [...args] 触发当前实例上的事件。附加参数都会传给监听器回调。 1vm.$on( event, callback ) 参数： 1&#123;string | Array&#125; &#96; event (数组只在 &#96; 2.2.0+ &#96; 中支持) &#96; &#123;Function&#125; callback 用法： 监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;p @click&#x3D;&#39;emit&#39;&gt;&#123;% raw %&#125;&#123;&#123;msg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, data () &#123; return &#123; msg : &#39;点击后女人派发事件&#39; &#125; &#125;, created () &#123; this.$on(&#39;wash_Goods&#39;,(arg)&#x3D;&gt; &#123; console.log(arg) &#125;) &#125;, methods : &#123; emit () &#123; this.$emit(&#39;wash_Goods&#39;,[&#39;fish&#39;,true,&#123;name:&#39;vue&#39;,verison:&#39;2.4&#39;&#125;]) &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 以上案例说了什么呢？在文章开始的时候说了 $emit 的（eventName）是与 $on(eventName) 是一一对应的，再结合以上两人在组成家庭的之前，女人会给男人列一个手册，告诉男人我会派发 $(emit) 那些事情，男人则会在家庭组成之前 $on(eventName) 后应该如何做那些事情。 通过以上说明我来进一步解释一下官方 Api 的意思。 1vm.$emit( event, […args] ) 参数： &#123;string&#125; event 第一个参数则是所要派发的事件名，必须是 String 类型的。 故事中就是要告诉男人所需要执行的事情。 [...args] 第二个参数是一个任何数据类型，如果我们需要传入多个不同的数据类型，则可以写入数组中，像这样[object, Boolean, function, string, …]，只要传一个参数，我们则可以直接写入 12 this.$emit(&#39;wash_Goods&#39;,&#39;fish&#39;)复制代码 故事中就是给男人的一个手册，告诉男人东西放在哪里，会需要到什么工具等等。 1vm.$on( event, callback ) 参数： &#123;string | Array&#125; event (数组只在 2.2.0+ 中支持) 第一个参数是相对于 $emit (eventName) 一一对应的 $on (eventName) ，两者是并存的、必须是 String 类型的。 (数组只在 2.2.0+ 中支持) 或者是 Array 数组中必须包含的是 String 项，后面再具体说。 故事中就是男人在组件一个家庭 (components) 的时候所监听的事件名。 &#123;Function&#125; callback 第二个参数则是一个 function，同样也被叫作之前回调函数，里面可以接收到由 $emit 触发时所传入的参数（如果是单个参数）。 故事中是男人在接收到女人派发的事情该去做那些事情。 {string | Array} event (数组只在 2.2.0+ 中支持) 在2.2中新增这个 Api 牵扯了另一种方式，也存在这其它的独特用法。 继续延续故事，当女人派发的事情多了，我相信作为男人也会觉得很烦，一旦听到事件的时候肯定会很烦躁，总会抱怨两句。 如果女人在组成家庭之前，告诉男人将要监听那些事情，如果做一件事就抱怨一次，启不是多此一举，所以我们可以通过 Array event 把事件名写成一个数组，在数组里写入你所想监听的那些事件，使用共享原则去执行某些派发事件。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;p @click&#x3D;&#39;emit&#39;&gt;&#123;% raw %&#125;&#123;&#123;msg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;p @click&#x3D;&#39;emitOther&#39;&gt;&#123;% raw %&#125;&#123;&#123;msg2&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, data () &#123; return &#123; msg : &#39;点击后女人派发事件&#39;, msg2 : &#39;点击后女人派发事件2&#39;, &#125; &#125;, created () &#123; this.$on([&#39;wash_Goods&#39;,&#39;drive_Car&#39;],(arg)&#x3D;&gt; &#123; console.log(&#39;事真多&#39;) &#125;) this.$on(&#39;wash_Goods&#39;,(arg)&#x3D;&gt; &#123; console.log(arg) &#125;) this.$on(&#39;drive_Car&#39;,(...arg)&#x3D;&gt; &#123; console.log(BMW,Ferrari) &#125;) &#125;, methods : &#123; emit () &#123; this.$emit(&#39;wash_Goods&#39;,&#39;fish&#39;) &#125;, emitOther () &#123; this.$emit(&#39;drive_Car&#39;,[&#39;BMW&#39;,&#39;Ferrari&#39;]) &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 以上案例说明了当女人无论是派发 drive_Car 或者是 wash_Goods 事件，都会打印出 事真多 ，再执行一一对应监听的事件。 通常情况下，以上用法是毫无意思的。在平常业务中，这种用法也用不到，通常在写组件的时候，让 $emit在父级作用域中 进行一个触发，通知子组件的进行执行事情。接下来，可以看一个通过在父级组件中，拿到子组件的实例进行派发事件，然而在子组件中事先进行好派好事件监听的准备，接收到一一对应的事件进行一个回调，同样也可以称之为封装组件向父组件暴露的接口。 DEMO 下拉加载 infinite-scroll12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;template&gt; &lt;div&gt; &lt;slot name&#x3D;&quot;list&quot;&gt;&lt;&#x2F;slot&gt; &lt;div class&#x3D;&quot;list-donetip&quot; v-show&#x3D;&quot;!isLoading &amp;&amp; isDone&quot;&gt; &lt;slot&gt;没有更多数据了&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;list-loading&quot; v-show&#x3D;&quot;isLoading&quot;&gt; &lt;slot&gt;加载中&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt; export default &#123; data() &#123; return &#123; isLoading: false, isDone: false, &#125; &#125;, props: &#123; onInfinite: &#123; type: Function, required: true &#125;, distance : &#123; type : Number, default：100 &#125; &#125;, methods: &#123; init() &#123; this.$on(&#39;loadedDone&#39;, () &#x3D;&gt; &#123; this.isLoading &#x3D; false; this.isDone &#x3D; true; &#125;); this.$on(&#39;finishLoad&#39;, () &#x3D;&gt; &#123; this.isLoading &#x3D; false; &#125;); &#125;, scrollHandler() &#123; if (this.isLoading || this.isDone) return; let baseHeight &#x3D; this.scrollview &#x3D;&#x3D; window ? document.body.offsetHeight : this.scrollview.offsetHeight let moreHeight &#x3D; this.scrollview &#x3D;&#x3D; window ? document.body.scrollHeight : this.scrollview.scrollHeight; let scrollTop &#x3D; this.scrollview &#x3D;&#x3D; window ? document.body.scrollTop : this.scrollview.scrollTop if (baseHeight + scrollTop + this.distance &gt; moreHeight) &#123; this.isLoading &#x3D; true; this.onInfinite() &#125; &#125; &#125;, mounted() &#123; this.scrollview &#x3D; window this.scrollview.addEventListener(&#39;scroll&#39;, this.scrollHandler, false); this.$nextTick(this.init); &#125;, &#125;&lt;&#x2F;script&gt;复制代码 对下拉组件加载加更的组件进行了一个简单的封装： 1data 参数解释： isLoading false 代表正在执行下拉加载获取更多数据的标识 ， true代表数据加载完毕 isDone false 代表数据没有全完加载完毕 ， true 代表数据已经全部加载完毕 1props 参数解释： onInfinite 父组件向子组件传入当滚动到底部时执行加载数据的函数 distance 距离滚动到底部的设定值 从此组件中，我们进行每一步的分析 在 1mounted 的时候，对 1window 对像进行了一个滚动监听，监听的函数为 1scrollHandler 当 1isLoading，isDone 任何一个为true时则退出 - `isloading` 为 `true` 时防止多次同样加载，必须等待加载完毕 - `isDone` 为 `true` 时说明所有数据已经加载完成，没有必要再执行 `scrollHandler` 同时在$nextTick中进行了初始化监听 loadedDone 一旦组件实例$emit(‘loadedDone’)事件时，执行回调，放开加载权限 finishLoad 一旦组件实例$emit(‘finishLoad’)事件时，执行回调，放开加载权限 再看看 scrollHandler函数里发生了什么 if (this.isLoading || this.isDone) return; 一旦一者为true，则退出，原因在mounted已经叙述过了 12if (baseHeight + scrollTop + this.distance &gt; moreHeight) ​ 当在window对象上监听scroll事件时，当滚动到底部的时候执行 - `this.isLoading = true;` 防止重复监听 - `this.onInfinite()` 执行加载数据函数 父组件中调用 infinite-scroll 组件 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;infinite-scroll :on-infinite&#x3D;&#39;loadData&#39; ref&#x3D;&#39;infinite&#39;&gt; &lt;ul slot&#x3D;&#39;list&#39;&gt; &lt;li v-for&#x3D;&#39;n in Number&#39;&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;infinite-scroll&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;import &#39;InfiniteScroll&#39; from &#39;.......&#39; &#x2F;&#x2F;引入infinitescroll.vue文件 export default &#123; data () &#123; return &#123; Number : 10 &#125; &#125;, methods : &#123; loadData () &#123; setTimeout(()&#x3D;&gt;&#123; this.Number &#x3D; 20 this.$refs.infinite.$emit(&#39;loadDone&#39;) &#125;,1000) &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 在父组件中引入 infinite-scroll 组件 当滑到底部的时候，infinite-scroll 组件组件内部会执行传入的 :on-infinite=&#39;loadData&#39; 函数 同时在内部也会把 Loading 设置为 true，防止重复执行。 在这里用 this.$refs.infinite 拿到 infinite-scroll 组件的实例，同时触发事件之前在组件中 $on 已经监听着的事件，在一秒后进行改变数据，同时发出 loadDone 事情，告诉组件内部去执行 loadDone 的监听回调，数据已经全部加载完毕，设置 this.isDone = true； 一旦 isDone 或者 isLoading 一者为 true ，则一直保持 return退出状态 。 ** $emit 和 $on 必须都在实例上进行触发和监听。** v-on 使用自定义绑定事件第一阶段 $emit 和 $on 的两者之间的关系讲完了，接下来该说说 v-on 与 $emit 的关系。 另外，父组件可以在使用子组件的引入模板直接用 v-on 来监听子组件触发的事件。 v-on 用接着故事直观的说法就是，在家里装了一个电话，父母随一直听着电话，同样也有一本小册子，在组成家庭之前，也知识要去监听那些事。 Warn不能用 $on 侦听子组件释放的事件，而必须在模板里直接用 v-on 绑定 。 上面 Warn 的意思是 $emit和$on只能作用在一一对应的同一个组件实例 ，而 v-on只能作用在父组件引入子组件后的模板上 。 就像下面这样： `` 就拿官方的这个例子说吧，其实还是很直观的： 12345678910111213141516171819202122232425262728293031&lt;div id&#x3D;&quot;counter-event-example&quot;&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123; total &#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;button-counter v-on:increment&#x3D;&quot;incrementTotal&quot;&gt;&lt;&#x2F;button-counter&gt; &lt;button-counter v-on:increment&#x3D;&quot;incrementTotal&quot;&gt;&lt;&#x2F;button-counter&gt;&lt;&#x2F;div&gt;Vue.component(&#39;button-counter&#39;, &#123; template: &#39;&lt;button v-on:click&#x3D;&quot;incrementCounter&quot;&gt;&#123;% raw %&#125;&#123;&#123; counter &#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;button&gt;&#39;, data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementCounter: function () &#123; this.counter +&#x3D; 1 this.$emit(&#39;increment&#39;) &#125; &#125;,&#125;)new Vue(&#123; el: &#39;#counter-event-example&#39;, data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total +&#x3D; 1 &#125; &#125;&#125;)复制代码 这样的好处在哪里？虽然 Vue 是进行数据单向流的，但是子组件不能直接改变父组件的数据，(也不是完全不能，但不推荐用)，标准通用明了的用法，则是通过父组件在子组件模板上进行一个 v-on 的绑定监听事件，同时再写入监听后所要执行的回调。 在 counter-event-example 父组件里，声明了两个 button-count 的实列，通过 data 用闭包的形式，让两者的数据都是单独享用的，而且 v-on 所监听的 eventName 都是当前自己实列中的 $emit 触发的事件，但是回调都是公用的一个 incrementTotal 函数，因为个实例所触发后都是执行一种操作！ 如果你只是想进行简单的进行父子组件基础单个数据进行双向通信的话，在模板上通过 v-on 和所在监听的模板实例上进行 $emit 触发事件的话，未免有点多余。通常来说通过 v-on 来进行监听子组件的触发事件的话，我们会进行一些多步操作。 子组件12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;p @click&#x3D;&#39;emit&#39;&gt;&#123;% raw %&#125;&#123;&#123;msg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, data () &#123; return &#123; msg : &#39;点击后改变数据&#39;, &#125; &#125;, methods : &#123; emit () &#123; this.$emit(&#39;fromDemo&#39;) &#125;, &#125;&#125;&lt;&#x2F;script&gt;复制代码 父组件123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &lt;p&gt;hello &#123;% raw %&#125;&#123;&#123;msg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;demo v-on:fromDemo&#x3D;&#39;Fdemo&#39;&gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Demo from &#39;.&#x2F;Demo.vue&#39;export default &#123; name: &#39;hello&#39;, data () &#123; return &#123; msg: &#39;数据将在一秒后改变&#39; &#125; &#125;, methods: &#123; waitTime() &#123; return new Promise(resolve&#x3D;&gt;&#123; setTimeout(()&#x3D;&gt; &#123; this.msg &#x3D; &#39;数据一秒后改变了&#39; resolve(1) &#125;,1000) &#125;) &#125;, async Fdemo () &#123; let a &#x3D; await this.waitTime(); console.log(a) &#125; &#125;, components : &#123; Demo &#125;&#125;&lt;&#x2F;script&gt;复制代码 从上面 demo 可以看出当子组件触发了 fromDemo 事件，同时父组件也进行着监听。 当父组件接收到子组件的事件触发的时候，执行了 async 的异步事件，通过一秒钟的等秒改变 msg ，再打印出回调后通过 promise 返回的值。 接下来想通的此例子告诉大家，这种方法通常是通过监听子组件的事件，让父组件去执行一些多步操作，如果我们只是简单的示意父组件改变传递过来的值用此方法就显的多余了。 我们进行一些的改动： children 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;p @click&#x3D;&#39;emit&#39;&gt;&#123;% raw %&#125;&#123;&#123;msg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, props: [ &#39;msg&#39; ], methods : &#123; emit () &#123; this.$emit(&#39;fromDemo&#39;,&#39;数据改变了&#39;) &#125;, &#125;&#125;&lt;&#x2F;script&gt;复制代码 parent 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &lt;demo v-on:fromDemo&#x3D;&#39;Fdemo&#39; :msg&#x3D;&#39;msg&#39;&gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Demo from &#39;.&#x2F;Demo.vue&#39;export default &#123; name: &#39;hello&#39;, data () &#123; return &#123; msg: &#39;数据没有改变&#39; &#125; &#125;, methods: &#123; Fdemo (arg) &#123; this.msg &#x3D; arg &#125; &#125;, components : &#123; Demo &#125;&#125;&lt;&#x2F;script&gt;复制代码 上面 demo 中子组件从父组件接收一个 msg 数据，但是想点击按钮的时候，改变父组件的 msg ，进行父组件的数据改动，同时再次改变子组件的 msg ，但是最简便的方法则是直接改变 prop 里 msg 的数据。但是数据驱动都是单向数据流，为了不造成数据传递的混乱，我们只能依靠一些其它手段去完成，一个小小的传递数据就显得很复杂的了，所以后续我们会讲讲如何去用更简便的 Api 做对应的事。 下篇课程导读： 在2.0初期 .sync 被砍了， v-model 承担起了双向绑定的职责，毕竟 v-model 不是为组件与组件之间数据双向绑定而设计的，用起来总有蹩脚的时候。 2.3 版本的回归，启用了显示通知的形式让双向绑定又活了， .sync 或者 v-model 比 $emit 与 v-on 只是进行简单的父子组件数据交互更加便捷。 第04课：.sync 王者回归，v-model 使命将至上一章我们已经对 $emit和v-on 如何进行数据和行为的交互做了讲解，但如果只是简单用来数据传递改变的话 .sync和v-model 再适合不过了。如果用过1.0的 Vue 的开发者，我相信 .sync 会让你用起来非常便捷，通过双向绑定很简单就能实双，父子组件的双向绑定，2.0为了保持单向数据流的良好性，去除了 .sync 的功能。 官方解释： 1.0 Props 现在只能单向传递。为了对父组件产生反向影响，子组件需要显式地传递一个事件而不是依赖于隐式地双向绑定。 推荐使用 自定义组件事件 自定义输入组件 (使用组件事件) 全局状态管理 通过大量观察，在初期2.0版本中，因为 .sync 并没有回归，只是在2.3进行回归，在组件库中进行数据双向绑定，几乎都是通过 v-model 来进行的。但是无论从语意上还是感观上，给代码维护的感就是不直观，v-model 在开发通常都是结合 Input 输入框来结合进行一个数据绑定，进行父子组件双向绑定，但是相比自定义 v-on 组件事件，无论从代码量，还是用法上更加简洁。 在 Vue 中，有许多方法和 Angular 相似，这主要是因为 Angular 是 Vue 早期开发的灵感来源。然而 Angular 中存在许多问题，在 Vue 中已经得到解决。 官方解释 自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。 12&lt;input v-model&#x3D;&quot;something&quot;&gt;复制代码 这不过是以下示例的语法糖： 1234&lt;input v-bind:value&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something &#x3D; $event.target.value&quot;&gt;复制代码 v-model 其实也是一个语法糖，想要理解这些代码，你要先知道 Input元素 上本身有个 oninput事件 ，这是 HTML5新增加 的，类似 onchange，每当输入框内容发生变化的时候，就会触发 Input事件 ，然后把 Input 输入框中 value 值再次传递给 something。 此时 value 运用在一个 Input 元素上，用：v-bind:value=’something’，意义上面只是把 Input 输入框中的 value 值与 something 作为一一对应的双向绑定，这就像一个循环操作，当再次触发 Input 事件时， input($event.target)对象中的value值会再次改变something 。 这里我们对 v-model 绑定在 Input 元素上进行语法糖上的解析。 既然在元素上能进行双向绑定，那在组件中进行双向绑定又如何实现，原理其实都是一样的，只是应用在自定义的组件上时，拿的并不是 $event.target.value ，因为我此时不作用在 Input 输入框上。 在组件中使用时，它相当于下面的简写：12345&lt;custom-input v-bind:value&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something &#x3D; arguments[0]&quot;&gt;&lt;&#x2F;custom-input&gt;复制代码 通过以上简写，通过自定事件让 v-model 进行一个父子组件双向绑定的话。 v-bind:value=’something’ 此时 value 是作为子组件接收的 Props 接收的只能是 value 吗？必须是，因为 v-model 是基于 Input 输入框定制的，其中value 值是为 Input 内部定制的 12 v-on:input&#x3D;&quot;something &#x3D; arguments[0]&quot;复制代码 此时作用在组件上时，v-on 监听的语法糖也会有所改动，监听的并不是 $event.target.value ，而是 回调函数中的第一个参数 。 父组件1234567891011121314151617181920212223&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &lt;button @click&#x3D;&quot;show&#x3D;true&quot;&gt;打开model&lt;&#x2F;button&gt; &lt;demo v-model&#x3D;&quot;show&quot;&gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Demo from &#39;.&#x2F;Demo.vue&#39;export default &#123; name: &#39;hello&#39;, components: &#123; Demo &#125;, data () &#123; return &#123; show: false &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 子组件1234567891011121314151617181920&lt;template&gt; &lt;div v-show&#x3D;&quot;value&quot;&gt; &lt;div&gt; &lt;p&gt;这是一个Model框&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;close&quot;&gt;关闭model&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: [&#39;value&#39;], methods: &#123; close () &#123; this.$emit(&#39;input&#39;,false) &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 这是一个模态框的基本雏形，可以在父组件通过 v-model 来进行 model 框和父组件之间的显示交互。 通过子组件看出 通过props接收了value值 ，当点击关闭的时候还是通过 $emit事件触发input事件 ，然后通过传入 false 参数。 父组件隐式 v-on:input=”something = arguments[0]” 进行了监听，一但 Input 事件触发，父组件就会执行监听回调，从而做到了双向绑定。 checkbox 和 radio 原理 1234 &lt;input type&#x3D;&quot;checkbox&quot; :checked&#x3D;&quot;status&quot; @change&#x3D;&quot;status &#x3D; $event.target.checked&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;radio&quot; :checked&#x3D;&quot;status&quot; @change&#x3D;&quot;status &#x3D; $event.target.checked&quot; &#x2F;&gt;复制代码 通过绑定 checked 属性，同样的监听的是 change 事件，无论是 checkbox 还是 radio 在操作的时候都会隐式自动触发一个 change 事件，跟 Input 通过 value 值，Input 触发事件原理绑定是一样的。 定制组件 v-model定制组件，我们就可以 重写v-model里的Props 和 event ，默认情况下，一个组件的 v-model 会使用 value 属性 和 input 事件 ，往往有些时候，value 值被占用了，或者表单的和自定议 v-model的$emit(&#39;input&#39;)事件发生冲突 ，为了避免这种冲突，可以定制组件 v-model，冲突示例。 子组件1234567891011121314151617181920212223&lt;template&gt; &lt;div v-show&#x3D;&quot;value&quot;&gt; &lt;div&gt; &lt;p&gt;这是一个Model框&lt;&#x2F;p&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;value&quot;&gt; &#123;% raw %&#125;&#123;&#123;value&#125;&#125;&#123;% endraw %&#125; &lt;button @click&#x3D;&quot;close&quot;&gt;关闭model&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: [&#39;value&#39;], methods: &#123; close () &#123; this.$emit(&#39;input&#39;,false) &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 父组件1234567891011121314151617181920212223&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &lt;button @click&#x3D;&quot;show&#x3D;true&quot;&gt;打开model&lt;&#x2F;button&gt; &lt;demo v-model&#x3D;&quot;show&quot;&gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; name: &#39;hello&#39;, components: &#123; Demo &#125;, data () &#123; return &#123; show: false &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 上面例子可以发现，在子组件中 input中v-model 和 model显示的操作数据共同占用的 props 中的（value） ，同样两者也共同占用了 emit(‘input’) 触发事件，Input 输入框的事件是自动出发，而 model 显示消失是手动触发。 初始化的时候，Input 输入框的值的会被 value 传入的 false 值给自动加上，当改变 Input 输入框的时候，因为冲突而导致报错。 定制 v-model， 通过 model 选项改变 props 和 event 的值，从而解除两者的冲突。 props代替掉原本 value 的值，可以自定义值 event代表掉原本 input 的触发事件，可以自定义触发事件 子组件12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div v-show&#x3D;&quot;show&quot;&gt; &lt;div&gt; &lt;p&gt;这是一个Model框&lt;&#x2F;p&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;value&quot;&gt; &#123;% raw %&#125;&#123;&#123;value&#125;&#125;&#123;% endraw %&#125; &lt;button @click&#x3D;&quot;closeModel&quot;&gt;关闭model&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; model: &#123; prop: &#39;show&#39;, event: &#39;close&#39; &#125;, props: [&#39;show&#39;], data () &#123; return &#123; value: 10 &#125; &#125;, methods: &#123; closeModel () &#123; this.$emit(&#39;close&#39;,false) &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 父组件12345678910111213141516171819202122&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &lt;button @click&#x3D;&quot;show&#x3D;true&quot;&gt;打开model&lt;&#x2F;button&gt; &lt;demo v-model&#x3D;&quot;show&quot; &gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; name: &#39;hello&#39;, components: &#123; Demo &#125;, data () &#123; return &#123; show: false &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 通过 model 选项的改变，把 props 从原本的 value换成了show ， input触发的事件换成了close ，从而两者都不相互依赖，解决了冲突的问题。 有些时候通过父组件中的子组件模板中想传递 value 值，也会导致同样的冲突。 在不用定制组件的情况下，以下的写法，也会同样导致冲突，导致同用一个 value。 1234&lt;demo v-model&#x3D;&quot;show&quot; value&#x3D;&quot;some value&quot;&gt;&lt;&#x2F;demo&gt;复制代码props:[&#39;value&#39;]复制代码 王者回归 .sync在一些情况下，我们可能会需要对一个 prop 进行『双向绑定』。事实上，这正是 Vue 1.x 中的 .sync 修饰符所提供的功能。当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定的值。这很方便，但也会导致问题，因为它破坏了『单向数据流』的假设。由于子组件改变 prop 的代码和普通的状态改动代码毫无区别，当光看子组件的代码时，你完全不知道它何时悄悄地改变了父组件的状态。这在 debug 复杂结构的应用时会带来很高的维护成本。 在2.0发布一段之后，无论在业务组件还是在功能组件库上面的，大量的子组件改变父子组件的数据和组件库中可能达到大功率的复用，但是在2.3中回归，重新引入了 .sync 修饰符，这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器。 之前的例子中，v-model 毕竟不是给组件与组件之间通信而设计的双向绑定，无论从语意上和代码写法上都没有 .sync 直观和方便。 无论从 v-model 还是 .sync 修饰符来看，都离不开 $emit v-on 语法糖的封装，主要目的还是为了保证数据的正确单向流动与显示流动。 12&lt;demo :foo.sync&#x3D;&quot;something&quot;&gt;&lt;&#x2F;demo&gt;复制代码 语法糖的扩展： 12&lt;demo :foo&#x3D;&quot;something&quot; @update:foo&#x3D;&quot;val &#x3D;&gt; something &#x3D; val&quot;&gt;&lt;&#x2F;demo&gt;复制代码 foo 则是 demo 子组件需要从父组件 props 接收的数据 通过事件显示监听 update:foo (foo则是 props 显示监听的数据)，通过箭头函数执行回调，把参数传给 something，则就形成了一种双向绑定的循环链条 当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件： 12this.$emit(&#39;update:foo&#39;, newValue)复制代码 同时父组件 @update:foo 也是依赖于子组件的显示触发，这样就可以很轻松的捕捉到了 数据的正确的流动 。 第一个参数则是 update 是显示更新的事件，跟在后面的 ：foo 则是需要 改变对应的props值 。 第二个参数传入的是你 希望父组件foo数据里将要变化的值 ，以 用于父组件接收update时更新数据 。 子组件1234567891011121314151617&lt;template&gt; &lt;div v-show&#x3D;&quot;show&quot;&gt; &lt;p&gt;这是一个Model框&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;closeModel&quot;&gt;关闭model&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: [&#39;show&#39;], methods: &#123; closeModel () &#123; this.$emit(&#39;update:show&#39;,false) &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 父组件1234567891011121314151617181920212223&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &lt;button @click&#x3D;&quot;show&#x3D;true&quot;&gt;打开model&lt;&#x2F;button&gt; &lt;demo :show.sync&#x3D;&quot;show&quot; &gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; name: &#39;hello&#39;, components: &#123; Demo &#125;, data () &#123; return &#123; show: false &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 上面的 case 同样也解决了 model 显示交互操作，从代码的语意上看上去让开发者一目了然，同样也做了 v-model 做不了的事，基于 props 的原子化，对传入的 props 进行多个数据双向绑定 .sync 也能轻松做到。 父组件123456789101112131415161718192021222324&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &lt;button @click&#x3D;&quot;show&#x3D;true&quot;&gt;打开model&lt;&#x2F;button&gt; &lt;demo :show.sync&#x3D;&quot;show&quot; :msg.sync&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; name: &#39;hello&#39;, components: &#123; Demo &#125;, data () &#123; return &#123; show: false, msg: &#39;这是一个model&#39; &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 子组件123456789101112131415161718&lt;template&gt; &lt;div v-show&#x3D;&quot;show&quot;&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;msg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;closeModel&quot;&gt;关闭model&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;$emit(&#39;update:msg&#39;,&#39;改变了model文案&#39;)&quot;&gt;改变文案&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: [&#39;show&#39;, &#39;msg&#39;], methods: &#123; closeModel () &#123; this.$emit(&#39;update:show&#39;,false) &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 父组件向子组件 props 里传递了 msg 和 show 两个值，都用了.sync 修饰符，进行双向绑定。 warn子组件改变父组件的数据时，update 冒号后面的参数和父组件传递进来的值是同步的，想改变那个，则冒号后面的值对应的那个，两者是一一对应的，同时也是必填的。 同样还可以在组件 template 里点击执行 click 后不但可以支持回调函数，还可以写入表达式，只是一种直观的表现还是推荐这种写法的。 .sync 修饰符给我们开发中带来了很大的方便，同时在2.0的初期的组件库中大量的 v-model 给开发者用起来还是很别扭，在.sync 回归后同时也会慢慢向.sync 进行一个版本的迁移。 下篇课程导读： 不基于大量行为操作，只是进行一个或多个数据双向组件的时候，可以轻松用 .sync 与 v-model 去化解，往往组件通信并不是你想像的那么轻松简单，在项目复杂的时候，组件如何合理的拆分，会让业务代码的 清晰度 ， 复用率 ， 后续维护都会降低成本 ，有利必有困难，同样会造成组件与组件的深层次传递，那我们如何进行通信呢？第一个想到的办法必然是 Vuex。Vuex 理解其实本质上并不是处理跨度深层次组件而使用的，往往这样会导致大家会滥用 vuex，而 $attrs $listeners 这对兄弟可以很好的帮助你进行深组件的通信。 第05课： listeners 两兄弟 在2.4版本中，有关 $attrs 和 $listeners 这两个实例属性用法还是比模糊，深层次挖掘将会非常有用，因为在项目中深层次组件交互的话可能就需要 Vuex 助力了，但是如果只是一个简单的深层次数据传递，或者进行某种交互时需要向上通知顶层或父层组件数据改变时，杀鸡用牛 VUX 可能未免有点多余！ 什么情况才会显得多余，如果我们纯通过 props 一层一层向下传递，再通过 watch 或者 data 进行过渡，如果只是单向数据深层能传递，进行监听改变深传递的数据，不进行跨路由之间页面的共享的话，用这两个属性非常便捷。 组件与组件之间大胆解耦有些开发者，特别对 Vuex 没有深入理解和实战经验的时候，同时对组件与组件多层传递时，不敢大胆的解耦组件，只能进行到父子组件这个层面，而且组件复用率层面上也有所下降。 $attr 与 interitAttrs 之间的关系interitAttrs：默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。 注意：这个选项不影响 class 和 style 绑定。 what?官网上并没有给出一点 demo，语意上看起来还是比较官方的，理解起来总是有点不太友好，通过一些 demo 来看看发生了什么。 子组件12345678910111213&lt;template&gt; &lt;div&gt; &#123;% raw %&#125;&#123;&#123;first&#125;&#125;&#123;% endraw %&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, props: [&#39;first&#39;]&#125;&lt;&#x2F;script&gt;复制代码 父组件12345678910111213141516171819202122&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &lt;demo :first&#x3D;&quot;firstMsg&quot; :second&#x3D;&quot;secondMessage&quot;&gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; name: &#39;hello&#39;, components: &#123; Demo &#125;, data () &#123; return &#123; firstMsg: &#39;first props&#39;, secondMessage: &#39;second props&#39; &#125; &#125;, &#125;&lt;&#x2F;script&gt;复制代码 父组件在子组件中进行传递 firstMsg 和secondMsg 两个数据，在子组件中，应该有相对应的 props 定义的接收点，如果在 props 中定义了，你会发现无论是 firstMsg 和 secondMsg 都成了子组件的接收来的数据了，可以用来进行数据展示和行为操作。 虽然在父组件中在子组件模版上通过 props 定义了两个数据，但是子组件中的 props 只接收了一个，只接收了 firstMsg，并没有接收 secondMsg，没有进行接收的此时就会成为子组件根无素的属性节点。 ### 事件代理 当我们用 v-for 渲染大量的同样的 DOM 结构时，但是每个上面都加一个点击事件，这个会导致性能问题，那我们可以通过 HTML5 的 data 的自定义属性做事件代理。 父组件改动123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot; @click&#x3D;&quot;ff&quot;&gt; &lt;demo :first&#x3D;&quot;firstMsg&quot; :data-second&#x3D;&quot;secondMsg&quot;&gt;&lt;&#x2F;demo&gt; &lt;demo :first&#x3D;&quot;firstMsg&quot; :data-second&#x3D;&quot;secondMsg&quot;&gt;&lt;&#x2F;demo&gt; &lt;demo :first&#x3D;&quot;firstMsg&quot; :data-second&#x3D;&quot;secondMsg&quot;&gt;&lt;&#x2F;demo&gt; &lt;demo :first&#x3D;&quot;firstMsg&quot; :data-second&#x3D;&quot;secondMsg&quot;&gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; name: &#39;hello&#39;, components: &#123; Demo &#125;, data () &#123; return &#123; firstMsg: &#39;first props&#39;, secondMsg: &#39;secondMsg&#39; &#125; &#125;, methods: &#123; ff (e) &#123; if(e.target.dataset.second &#x3D;&#x3D; &#39;secondMsg&#39;) &#123; console.log(&#39;通过事件委托拿到了自定义属性&#39;) &#125; &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 经过改动之后，在父组件中，把向子组件传递的参数名改成了 HTML 自定义的 data-second 属性，同样在子组件中不进行 props 接收，就顺其自然的成为了子组件每一个根节点的自定义属性。 通过事件冒泡的原理，然而可以从e.target.dataset.second 就能找对应的 Dom 节点进行逻辑操作。 同样，在子组件模版上可以绑定多个自定义属性，在子组件包裹的外层进行一次监听，通过 data 自定义属性拿到循环出来组件的对应的数据，进行逻辑操作。 interitAttrs = false 发生了什么 ？ 1234567891011121314&lt;template&gt; &lt;div&gt; &#123;% raw %&#125;&#123;&#123;first&#125;&#125;&#123;% endraw %&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, props: [&#39;first&#39;], inheritAttrs: false,&#125;&lt;&#x2F;script&gt;复制代码 对子组件进行一个改动，我们加上 inheritAttrs: false，从字面上的翻译的意思，取消继承的属性，然而 props 里仍然没有接收 seconed，发现就算 props 里没有接收 seconed，在子组件的根元素上并没有绑定任何属性。 $attrs 包含了父作用域中不被认为 (且不预期为) props 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 props 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建更高层次的组件时非常有用。 在前面的例子中，子组件 props中并没有接受seconed ， 设置选项 inheritAttrs： false ，同样也不会作为根元素的属性节点，整个没有接收的数据都被 $attr 实例属性给接收，里面包含着所有父组件传入而子组件并没有在 Props里显示接收的数据。 为了验证事实，可以在子组件中加上 1234created () &#123; console.log(this.$attrs) &#125;复制代码 打印出来则是一个对象 {second: “secondMsg”, third: “thirdMsg”} warn想要通 $attr 接收，但必须要保证设置选项 inheritAttrs: false，不然会默认变成根元素的属性节点。 开头说了，最有用的情况则是在深层次组件运用的时候，创建第三层孙子组件，作为第二层父组件的子组件，在子组件引入的孙子组件，在模版上把整个 $attr 当数作数据传递下去，中间则并不用通过任何方法去手动转换数据。 子组件1234567&lt;template&gt; &lt;div&gt; &lt;next-demo v-bind&#x3D;&quot;$attrs&quot;&gt;&lt;&#x2F;next-demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;复制代码 孙子组件12345678910111213&lt;template&gt; &lt;div&gt; &#123;% raw %&#125;&#123;&#123;second&#125;&#125;&#123;% endraw %&#125;&#123;% raw %&#125;&#123;&#123;third&#125;&#125;&#123;% endraw %&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; props : [ &#39;second&#39; , &#39;third&#39;] &#125;&lt;&#x2F;script&gt;复制代码 孙子组件在 props 接收子组件中通过 $attr 包裹传来的数据，同样是通过父组件传来的数据，只是在子组件用了 $attrs 进行了统一接收，再往下传递，最后通过孙子组件进行接收。 以此类推孙子组件仍然不想接收，再传入下级组件，我们仍然需要对孙子组件实力选项进行设置选项 inheritAttrs: false，否则仍然会成为孙子组件根元素的属性节点。 从而利用 $attrs 来接收 props 为接收的数据再次向下传递是一件很方便的事件，深层次接收数据我们理解了，那从深层次向层请求改变数据如何实现。意思就是让顶层数据和最底层数据进行一个双向绑定。 $listenerslisteners 可以认为是监听者。 向下如何传递数据已经了解了，面临的问题是如何向顶层的组件改变数据，父子组件可以通过 v-model，.sync，v-on 等一系列方法，深层及的组件可以通过 $listeners 去管理。 $listeners 和 $attrs 两者表面层都是一个意思， $attrs 是向下传递数据， $listeners 是向下传递方法，通过手动去调用 $listeners 对象里的方法，原理就是 $emit 监听事件， $listeners 也可以看成一个包裹监听事件的一个对象。 父组件12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &#123;% raw %&#125;&#123;&#123;firstMsg&#125;&#125;&#123;% endraw %&#125; &lt;demo v-on:changeData&#x3D;&quot;changeData&quot; v-on:another &#x3D; &#39;another&#39;&gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; name: &#39;hello&#39;, components: &#123; Demo &#125;, data () &#123; return &#123; firstMsg: &#39;父组件&#39;, &#125; &#125;, methods: &#123; changeData (params) &#123; this.firstMsg &#x3D; params &#125;, another () &#123; alert(2) &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 在父组件中引入子组件，在子组件模板上面进行 changeData 和 another 两个事件监听，其它这两个监听事件并不打算被触发，而是直接被调用，再简单的理解则是向下传递两个函数。 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;p @click&#x3D;&quot;$emit(&#39;another&#39;)&quot;&gt;子组件&lt;&#x2F;p&gt; &lt;next-demo v-on&#x3D;&#39;$listeners&#39;&gt;&lt;&#x2F;next-demo&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt;&lt;script&gt;import NextDemo from &#39;.&#x2F;nextDemo.vue&#39;export default &#123; name: &#39;demo&#39;, components: &#123; NextDemo &#125;, created () &#123; console.log(this.$listeners) &#125;,&#125;&lt;&#x2F;script&gt;复制代码 在子组件中，引入孙子组件 nextDemo。在子组件中像 $attrs 一样，可以用 $listeners 去整体接收监听的事件， &#123;changeData: ƒ, another: ƒ&#125; 以一个对象去接收，此时在父组件中子组件模板上监听的两个事件不但可以被子组件实例属性 $listeners 去整体接收，并且同时可以在子组件进行触发。 同样在孙子 nextDemo 组件中，继续向下传递，通过 v-on 把整个 $listeners 所接收的事件传递到孙子组件中，只是通过 $listeners 把其所有在父组件拿到监听事件一并通过 $listeners 一起传递到孙子组件里。 孙子组件12345678910111213141516&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &lt;p @click&#x3D;&#39;$listeners.changeData(&quot;change&quot;)&#39;&gt;孙子组件&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, created () &#123; console.log(this.$listeners) &#125;,&#125;&lt;&#x2F;script&gt;复制代码 依然能拿到从子组中传递过来的 $listeners 所有的监听事件，此时并不是通过 $emit 去触发，而是像调用函数一样， $emit 只是针对于父子组件的双向通信， $listeners 包了一个对象，分别是 changeData 和 another，通过$listeners.changeData(‘change’)等于直接触发了事件，执行监听后的回调函数，就是通过函数的传递，调用了父组件的函数。 通过 $attrs 和 $listeners 可以很愉快地解决深层次组件的通信问题，更加合理的组织你的代码。 下篇导读 以上介绍了如何在高层组件向下传递数据，在底层组件向上通知改变数据或者进行一些行为操作，而 $listeners 就像是调用了父组件的函数一样，看上去根本没有什么区别，你可能会想用 $parents，$children 一样能做到。不是不可用，而是在什么情况下适合用，通过下篇介绍木偶组建和智能组件好好理一下正确场景下如何准确利用 Api 进行行为交互、数据交互。 第06课：智能组件与木偶组件的正确用法Vue 中在组件层面的数据和行为通信，前五章通过一些 demo 和进行了深入总结，包括以下几点： data 与 props 的数据存放要素 单个组件 $emit 与 $on 的通信，父子组件 v-on 与 $emit 的通信 .sync 和 v-model 双向绑定的模式 $attrs 与 $listeners 深层次数据传递与行为交互的运用模式 以上涵盖了大量组件与组件之间的通信模式，只有能熟练掌握以上知识点，接下来才能对智能组件与木偶组件写法和封装有准确用法。 智能组件原理智能组件可以称为第三方通用组件，也可以称之为业务型公用组件，与父组件之间的关系是完全解耦的，只能通过 props 进行数据传递，event 进行事件传递，不依赖于任何环境，只需要传递相应的数据和事件，就能得到你想要的操作。 木偶组件原理木偶组件是为了业务页面进行拆分而形成的组件模式。比如一个页面，可以分多个模块，而每一个模块与其余页面并没有公用性，只是纯粹拆分。 还有一个方面则是复合组件的联动用法。当一个智能组件是由两个组件组成的一个复合智能组件，而它的子组件与父组件之间就有一个木偶的原理，因为两者是相互的，在开发者调用并需保持它们的关系性、规范性，一旦改变其本身的模式则会无效。 木偶组件的拆分简便用法 对于每一个木偶组件在定义之前，你必然会知道它将作用于哪个页面，在哪一层，都是有一个准确的不变性，取决于你对页面的拆分深度和数量。 $parent 组件通信$parent 指向当前组件的父组件，可以拿到父组件的整个实例。前面已经说了，木偶组件可以明确的知道运用在每个 spa 页面对应路由的第几层组件，可能是当前页面的子组件，孙子组件，或者更深的层次。而想和父组件进行通信的话，在不考虑复用的前题下，可以明确如何与父组件进行数据通信或者行为通信。 父组件12345678910111213141516171819202122&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &#123;% raw %&#125;&#123;&#123;msg&#125;&#125;&#123;% endraw %&#125; &lt;demo&gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; name: &#39;hello&#39;, components: &#123; Demo &#125;, data () &#123; return &#123; msg: &#39;父组件&#39;, &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 子组件1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;demoMsg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;p @click&#x3D;&quot;handleClick&quot;&gt;子组件&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, data () &#123; return &#123; demoMsg : &#39;&#39; &#125; &#125;, methods: &#123; handleClick () &#123; let msg &#x3D; this.$parent.msg this.demoMsg &#x3D; msg this.$parent.msg &#x3D; &#39;父组件数据被改了&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 demo 组件已经明确的知道是 Hello 组件的子组件，也可以是 demo 组件是 Hello 组件的木偶组件，通过 $parent 就可以随意取到和改动父组件实例的属性（数据）。同样这也并不违反数据的单向流的原则，可以对比一下通过 v-on 和 $emit 或者 v-model，.sync 这几种方法，不但方便很多，还更加快捷，并且明确了组件的位置，就像木偶一样，永远不会变，它的父组件永远只会是同一个。 $parent 调用父组件方法父组件 1234567...methods : &#123; parentMethods () &#123; console.log(&#39;调用父组件的方法&#39;) &#125;&#125;复制代码 子组件12this.$parent.parentMethods()复制代码 同样可以调用父件的方法，通过子组的调用去执行父组件的方法。此方法是在父组件内部执行的，在某些场景下就会显得很便捷，后面会给出例子。 $children 的组件通信$children 也是针对于木偶组件的应用，它和 $parent 相反，此 Api是对于一个组件来说，已经明确知道它的子组件，也可能是一个子组件集，准确地拿到想要的子组件实例，或者子组件集实列 $children 可以通过父组件拿到子组件的实例，它是以一个数组的形式包裹。 父组件1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &lt;p @click&#x3D;&#39;handlerClick&#39;&gt;父组件&lt;&#x2F;p&gt; &lt;demo&gt;&lt;&#x2F;demo&gt; &lt;demo&gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; name: &#39;hello&#39;, components: &#123; Demo &#125;, methods: &#123; handlerClick () &#123; console.log(this.$children) this.$children.forEach(item &#x3D;&gt; &#123; item.demoMsg &#x3D; &#39;通过$children改变&#39; &#125;) &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 子组件1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;demoMsg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, data () &#123; return &#123; demoMsg : &#39;&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt;复制代码 此时已经不是通过子组件去与父组件通信，而是用父组件与子组件通信， $parent 与 $children 就形成了一个父子组件互相通信的机制，还是那句重点一句 只适合木偶组件的模式 。 在父组件中明确 demo 组件是子组件，通过 $children 拿到所有 demo 组件的实例，通过 forEach 循环改变每个子组件的实例属。因为 data 里所有属性(数据)都是通过 object.defineproperty 来进行数据劫持，把 data 里的属性都绑到 Vue 实例上。从中我们可以轻而易举的得到它。 智能组件的运用 智能组件可能是业务组件也可能是第三方通用组件，总归是多个组件公用的子组件，因为它可能服务多个组件或者页面，当嵌入不同组件里，所需要展求的业务能力也是有所区别的，因此称之为智能组件。 举一个例子：比方说一个智能组件 A，将嵌入 B，C 组件做为子组件： 当A嵌入到B中需要显示文案 嵌入B组件中 当A嵌入到C中需要显示文案 嵌入C组件中 通过向智能传递一个数据和标识，告诉它我需要你展示什么？ 父组件123456789101112131415161718&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &lt;p&gt;父组件&lt;&#x2F;p&gt; &lt;demo type&#x3D;&#39;A&#39;&gt;&lt;&#x2F;demo&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Demo from &#39;.&#x2F;Demo.vue&#39; export default &#123; name: &#39;hello&#39;, components: &#123; Demo &#125; &#125;&lt;&#x2F;script&gt;复制代码 子组件12345678910111213&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;type&#x3D;&#x3D;&#x3D;&#39;B&#39;?&#39;嵌入B的组件&#39;:&#39;嵌入C的组件&#39;&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;demo&#39;, props: [&#39;type&#39;]&#125;&lt;&#x2F;script&gt;复制代码 对于智能组件你永远不知道你将作用于哪个组件之下，这本身就是一个不定因素，特别对于通用组件，这将会暴露各种方法和 props 数据，只有传递数据传递事件去做自己想做的事件，智能组件（也是一个封装模块），会根据传入的数据和事件去做内部封装后所做的事情，而你并不可以轻意的随便改动它。 智能组件里的木偶组件智能组件与木偶组件同时可以相互嵌套，可以作用在 复合组件上 。一般复合组件是都是通三方通用组件称之为智能组件，但是复合组件的父组件和子组件同样可以互相成为对方的 木偶组件 ，两者可以成为 相互依赖的关系 。无论从代码量和理解，调用都会很方便，木偶组件相比智能组件 更方便理解和简洁 ，但是 功能上就比较单一 。 通过一个 accordion 折叠面板来理解智能组件中的木偶组件accordion属于第三方通用组件，同样也是一个复合组件。 Accordion 组件1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; props : [&#39;repeat&#39;], methods : &#123; open (uid) &#123; this.$children.forEach(item &#x3D;&gt; &#123; if(item._uid !&#x3D; uid)&#123; item.close &#x3D; false &#125; &#125;) &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 AccordionItem 组件12345678910111213141516171819202122232425262728293031&lt;template&gt;&lt;div&gt; &lt;p @click&#x3D;&#39;handleClick&#39;&gt;&#123;% raw %&#125;&#123;&#123;title&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;div v-show&#x3D;&#39;close&#39; &gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; props : [&#39;title&#39;], data () &#123; return &#123; close : false &#125; &#125;, created () &#123; if(this.$parent.repeat &#x3D;&#x3D;&#x3D; true) &#123; this.close &#x3D; true &#125; &#125;, methods : &#123; handleClick () &#123; this.$parent.open(this._uid) this.close &#x3D; !this.close &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 最后的调用12345678910111213141516171819202122&lt;template&gt; &lt;div class&#x3D;&quot;hello&quot;&gt; &lt;accordion :repeat&#x3D;&#39;true&#39;&gt; &lt;accordion-item title&#x3D;&#39;vueTitle&#39;&gt;vue&lt;&#x2F;accordion-item&gt; &lt;accordion-item title&#x3D;&#39;vue-routerTitle&#39;&gt;vue-router&lt;&#x2F;accordion-item&gt; &lt;accordion-item title&#x3D;&#39;vuex-Title&#39;&gt;vuex&lt;&#x2F;accordion-item&gt; &lt;&#x2F;accordion&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Accordion from &#39;.&#x2F;accordion.vue&#39; import AccordionItem from &#39;.&#x2F;accordion-item.vue&#39; export default &#123; name: &#39;hello&#39;, components: &#123; Accordion, AccordionItem &#125; &#125;&lt;&#x2F;script&gt;复制代码 先从智能组件这个方面说起，无论是 accordion 还是 accordion-item 同向外暴露一个 props进行你希望的操作。 accordion 暴露了一个 repeat，当 repeat 为 true 的时候则把所有 item 项初始化都进行展开。 accordion-item 暴露了一个 title，可以随意传入你想设计的标题。 以上这些往往都是一些不定因素，也不知道它可能会嵌套在哪个页面组件的哪一层，这就是复合组件的智能方面。 再从木偶组件这个方面论一下。accordion 与 accordion-item 两者是父子组件关系，这种关系是不可变的，想要用到这个复合组件，accordion 与 accordion-item 必须保证确定的父子组件关系，并且缺一不可，从中就能体现出两者的木偶性。 accordion-item 通过 $parent 调用 accordion 父组件的 open 方法， 而 accordion 通过 $children 拿到每一个 accordion-item 子组件的实例，进行显示隐藏的转换。两者很充分形成了一个对木偶关系，这种父子关系是永远断不了的。 总结： 木偶组件：子组件只能有一个爹，必须是唯一的，而且父子俩长得一模一模，谁离开谁都活不了。 智能组件：子组件可以有N个爹，非唯一性，而且父子长得不一定要一样，子组件可能会有N个爹的特性，子组件离开哪个爹都能继续生存。 第07课：你不知道的中央事件通信中央事件通信，就像一根线一样，把两个组件的通信用一根线连接起来。前面几节课讲了父子组件通信与深层次嵌套组件通信，并且已经通过各种 Api 和良好的解决方案，但是同级组件怎么办，无论用 $emit v-on v-model .sync $attr与$listeners 都不适用，以上这些都是 基于嵌套的父子组件进行通信 。 同级组件通信，也是一种常见的通信模式，在一个大的容器下(父组件)底下有两个平级的组件，两个组件进行数据交或者行为交互，在 Api 的方法里也没有专门的设计。 通过 $emit ，v-on， $on 三者结合使用这种操作是非常复杂的，如果你能良好掌握以上三个 Api 进行同级组件的通信，那你对这三个 Api 已经完全掌握了。这种方法是一种过渡方法， b-&gt;a a-&gt;c ，意思是 a 去通知 b ， b 对 a 进行一个监听，当 a 监听到件事，在进行向 c 触发， c 的内部再进行监听，这样就形成了一个过渡链条。但是代码上就不显的那么直观了，多个触发事件，多个监听事件，一旦这种平级组件需要通信多了，那么代码就有一种很难维护的感觉。 实例demo 同级子组件 First123456789101112&lt;template&gt; &lt;div&gt; &lt;p @click&#x3D;&quot;$emit(&#39;fromFirst&#39;,&#39;来自A组件&#39;)&quot;&gt;first组件&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &#39;first&#39; &#125;&lt;&#x2F;script&gt;复制代码 按着上面的讲解的顺序，先定义一个同级子组件，当点击的时候向外触发一个 eventName 为 fromFirst 的事件，传递一个 来自A组件 的参数这就形成了 b-&gt;a 让 a 去监听事件，让 b 去触发事件。 父组件12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;p&gt;父组件&lt;&#x2F;p&gt; &lt;first v-on:fromFirst&#x3D;&quot;hanlderFromA&quot;&gt;&lt;&#x2F;first&gt; &lt;second ref&#x3D;&quot;second&quot;&gt;&lt;&#x2F;second&gt; &lt;&#x2F;div&gt;&lt;template&gt;&lt;script&gt; import First from &#39;.&#x2F;first.vue&#39; import Second from &#39;.&#x2F;second.vue&#39; export default &#123; name: &#39;login&#39;, components: &#123; First, Second &#125;, methods: &#123; hanlderFromA (Bmsg) &#123; let second &#x3D; this.$refs.second second.$emit(&#39;fromLogin&#39;, Bmsg) &#125; &#125; &#125;&lt;script&gt;复制代码 父组件中引入了两个同级组件 First / Second ，还是延续 b-&gt;a 。此时 a 就是这个父组件，再梳理一下知识点， v-on与$emit 是进行 父子组件事件通信 ，作用在父子组件两个层面上，在 First 组件模版上进行一个 v-on监听 ，一旦监听到触发 fromFirst 事件，则进行 hanlderFromA 函数。 接下来是 a-&gt;c 这个阶段， $emit与$on 都是作用在同一个组件的实列上，通过 this.$refs 拿到 Second 组件的实列，在执行 hanlderFromA函数 时再告诉 c 组件进行通信，同时把从 b 接收到的参数再次传入。 以上很明显能看出 A（父组件）只是一个过渡体，也可以说是一个真实的中央体，进行中央事件的派发。 同级子组件 Second123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;Bmsg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;p&gt;second组件&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &#39;second&#39;, created () &#123; this.$on(&#39;fromLogin&#39;, (Bmsg) &#x3D;&gt; &#123; this.Bmsg &#x3D; Bmsg console.log(&#39;通信成功&#39;) &#125;) &#125;, data () &#123; return &#123; Bmsg: &#39;&#39; &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 Second 组件是被通信的一方，在 a(父组件) 进行触发，然而在 c(second) 组件中进行监听，一旦监听到了 fromLogin 事件，可以做你想做得改变数据，行为操作都不是问题了。 这就 是b-&gt;a a-&gt;c 的模式，我只能用一句话说，复杂！实在是复杂，那必然有简单的方法。在了解更简单的方法之前，先了解一下 ES6 模块的运行机制 。 ES6 模块的运行机制 JS 引擎对脚本静态分析的时候，遇到模块加载命令 import ，就会生成一个 只读引用 。ES6 export 的原始值变了， import加载 的值也会跟着变。因此， ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 举个例子 123456789101112&#x2F;&#x2F; lib.jsexport let counter &#x3D; 3;export function incCounter() &#123; counter++;&#125;&#x2F;&#x2F; main.jsimport &#123; counter, incCounter &#125; from &#39;.&#x2F;lib&#39;;console.log(counter); &#x2F;&#x2F; 3incCounter();console.log(counter); &#x2F;&#x2F; 4复制代码 虽然在 main.js 执行程序的时候加载了 count ，但是 count 在 lib.js 和在 main.js 里形成了一个引用关系，一旦libs内部的 export 导出的 counter 发生变化时， main.js 中同样会发生变化。 通过额外的实例进行简单的中央事件处理 定义一个额外的实例进行一个事件的中转，对于 ES6 模块的运行机制已经有了一个讲解，当模块内部发生变化的时候，引入模块的部分同样会发生变化，当又一个额外的实例对加载机制进行引入进行 $emit与$on 进行绑定通信，能轻而易举解决问题，通过 b-&gt;a-&gt;c 的模式直接过渡。 定义一个中央事件实例 12345import Vue from &#39;vue&#39;export default new Vue()复制代码 new 一个 Vue 的实例，然后把这个实例能过 es6 模块机制导出。 父组件改动123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;p&gt;父组件&lt;&#x2F;p&gt; &lt;first&gt;&lt;&#x2F;first&gt; &lt;second&gt;&lt;&#x2F;second&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import First from &#39;.&#x2F;first.vue&#39; import Second from &#39;.&#x2F;second.vue&#39; export default &#123; name: &#39;login&#39;, components: &#123; First, Second &#125; &#125;&lt;&#x2F;script&gt;复制代码 在父这里只需要进行两个同组件的引入，可以删除任何过渡的方式。 同级子组件 First 改动123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;p @click&#x3D;&quot;handleClick&quot;&gt;first组件&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Bus from &#39;.&#x2F;bus.js&#39; export default &#123; name: &#39;first&#39;, methods: &#123; handleClick () &#123; Bus.$emit(&#39;fromFirst&#39;, &#39;来自A的组件&#39;) &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 在 first同级 组件中把 bus 实例引入，点击时让 bus 实例触发一个 fromFirst 事件，这里你可能已经理解 module 加载机制配合在单个实例上用 $emit和$on 进行通信绑定，往下看。 同级子组件Second改动12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;Bmsg&#125;&#125;&#123;% endraw %&#125;&lt;&#x2F;p&gt; &lt;p&gt;second组件&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Bus from &#39;.&#x2F;bus.js&#39; export default &#123; name: &#39;second&#39;, created () &#123; Bus.$on(&#39;fromFirst&#39;, ( Amsg )&#x3D;&gt; &#123; this.Bmsg &#x3D; Amsg console.log(&#39;同级组件交互成功&#39;) &#125;) &#125;, data () &#123; return &#123; Bmsg: &#39;&#39; &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 同样也引入 bus 实列，通过 bus 用 $on 监听 fromFirst 事件，因为 bus实例 与 bus.js 里的 export defalt new Vue 关系是一个引用关系，当代码执行后，无论 first 或者 second 组件通过 bus实例 形成了一个 中央事件链条 ，这种方法不但直观，也更加便捷。 中央事件的延生 跨组件深层次交互 既然同级组件可以用中央事件去过渡，那深层次嵌套不同级组件可以吗？那你肯定第一时间用到了 Vuex，但我一直认为 Vuex 操作大量的数据联动性非常有用，但是如果只是一个改变数据，或者执行事件，用起来反而更加直观。 将要模拟的方案： a 组件 first 组件 -&gt; firstInner 组件 second 组件 -&gt; secondInner 组件 当 firstInner组件 可能会与 second组件 或者 secondInner组件 发生跨组件深层次交互也同样可以用中央事件去进行过渡 ，如果说 vuex 是顶层共享数据源，那么中央事件就是顶层共享通信网 。 demo 示例 前面的所有父组件都不写代码了，只展示一下firstInner 组件、secondInner 组件。 firstInner 组件123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;p @click&#x3D;&quot;handleClick&quot;&gt;firstInner组件&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Bus from &#39;.&#x2F;bus.js&#39; export default &#123; name: &#39;first&#39;, methods: &#123; handleClick () &#123; Bus.$emit(&#39;fromFirstInner&#39;, &#39;来自firstInner组件&#39;) &#125; &#125; &#125;&lt;&#x2F;script&gt;复制代码 SecondInner 组件123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;p&gt;secondInner组件&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import Bus from &#39;.&#x2F;bus.js&#39; export default &#123; name: &#39;secondInner&#39;, created () &#123; Bus.$on(&#39;fromFirstInner&#39;,(msg) &#x3D;&gt; &#123; console.log(msg) &#125;) &#125; &#125;&lt;&#x2F;script&gt;复制代码 无论你想通信的两个组件嵌到在任何地方，它们的关系是如何的，只需要通过中央事件的处理，都能完成，同时还可以进行一对多的中央事件处理方式。在程序代码可控的情况下，没有什么是不可行的，只要数据量的变动是在可控范围之内，做一个中央事件网去行成一个通信网络，也是一个不错的选择。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://1314xulujin.github.io/tags/vue/"}]},{"title":"30道Vue面试题(掘金社区)","slug":"30道Vue面试题-掘金社区","date":"2020-05-24T23:29:07.000Z","updated":"2021-11-03T08:46:43.019Z","comments":true,"path":"2020/05/25/30道Vue面试题-掘金社区/","link":"","permalink":"https://1314xulujin.github.io/2020/05/25/30%E9%81%93Vue%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8E%98%E9%87%91%E7%A4%BE%E5%8C%BA/","excerpt":"","text":"30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）前言本文以前端面试官的角度出发，对 Vue 框架中一些重要的特性、框架的原理以问题的形式进行整理汇总，意在帮助作者及读者自测下 Vue 掌握的程度。本文章节结构以从易到难进行组织，建议读者按章节顺序进行阅读，当然大佬级别的请随意。希望读者读完本文，有一定的启发思考，也能对自己的 Vue 掌握程度有一定的认识，对缺漏之处进行弥补，对 Vue 有更好的掌握。 文章最后一题，欢迎同学们积极回答，分享各自的经验 ~~~ 辛苦整理良久，还望手动点赞鼓励~ github地址为：github.com/fengshi123/…，汇总了作者的所有博客，也欢迎关注及 star ~ 1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对对服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 2、v-show 与 v-if 有什么区别？v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 3、Class 与 Style 如何动态绑定？Class 可以通过对象语法和数组语法进行动态绑定： 对象语法： 1234567&lt;div v-bind:class&#x3D;&quot;&#123; active: isActive, &#39;text-danger&#39;: hasError &#125;&quot;&gt;&lt;&#x2F;div&gt;data: &#123; isActive: true, hasError: false&#125;复制代码 数组语法： 1234567&lt;div v-bind:class&#x3D;&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;&#x2F;div&gt;data: &#123; activeClass: &#39;active&#39;, errorClass: &#39;text-danger&#39;&#125;复制代码 Style 也可以通过对象语法和数组语法进行动态绑定： 对象语法： 1234567&lt;div v-bind:style&#x3D;&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;data: &#123; activeColor: &#39;red&#39;, fontSize: 30&#125;复制代码 数组语法： 1234567891011&lt;div v-bind:style&#x3D;&quot;[styleColor, styleSize]&quot;&gt;&lt;&#x2F;div&gt;data: &#123; styleColor: &#123; color: &#39;red&#39; &#125;, styleSize:&#123; fontSize:&#39;23px&#39; &#125;&#125;复制代码 4、怎样理解 Vue 的单向数据流？所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。 有两种常见的试图改变一个 prop 的情形 : 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： 1234567props: [&#39;initialCounter&#39;],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125;复制代码 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性 1234567props: [&#39;size&#39;],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125;复制代码 5、computed 和 watch 的区别和运用的场景？computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 6、直接给一个数组项赋值，Vue 能检测到变化吗？由于 JavaScript 的限制，Vue 不能检测到以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一个问题，Vue 提供了以下操作方法： 1234567&#x2F;&#x2F; Vue.setVue.set(vm.items, indexOfItem, newValue)&#x2F;&#x2F; vm.$set，Vue.set的一个别名vm.$set(vm.items, indexOfItem, newValue)&#x2F;&#x2F; Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue)复制代码 为了解决第二个问题，Vue 提供了以下操作方法： 123&#x2F;&#x2F; Array.prototype.splicevm.items.splice(newLength)复制代码 7、谈谈你对 Vue 生命周期的理解？（1）生命周期是什么？ Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 （2）各个生命周期的作用 生命周期 描述 beforeCreate 组件实例被创建之初，组件的属性生效之前 created 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子 beforeUpdate 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前 update 组件数据更新之后 activited keep-alive 专属，组件被激活时调用 deactivated keep-alive 专属，组件被销毁时调用 beforeDestory 组件销毁前调用 destoryed 组件销毁后调用 （3）生命周期示意图 8、Vue 的父组件和子组件生命周期钩子函数执行顺序？Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分： 加载渲染过程 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted 子组件更新过程 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated 父组件更新过程 父 beforeUpdate -&gt; 父 updated 销毁过程 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed 9、在哪个生命周期内调用异步请求？可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面 loading 时间； ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性； 10、在什么阶段才能访问操作DOM？在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。 11、父组件可以监听到子组件的生命周期吗？比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现： 12345678&#x2F;&#x2F; Parent.vue&lt;Child @mounted&#x3D;&quot;doSomething&quot;&#x2F;&gt; &#x2F;&#x2F; Child.vuemounted() &#123; this.$emit(&quot;mounted&quot;);&#125;复制代码 以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示： 12345678910111213141516&#x2F;&#x2F; Parent.vue&lt;Child @hook:mounted&#x3D;&quot;doSomething&quot; &gt;&lt;&#x2F;Child&gt;doSomething() &#123; console.log(&#39;父组件监听到 mounted 钩子函数 ...&#39;);&#125;, &#x2F;&#x2F; Child.vuemounted()&#123; console.log(&#39;子组件触发 mounted 钩子函数 ...&#39;);&#125;, &#x2F;&#x2F; 以上输出顺序为：&#x2F;&#x2F; 子组件触发 mounted 钩子函数 ...&#x2F;&#x2F; 父组件监听到 mounted 钩子函数 ... 复制代码 当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。 12、谈谈你对 keep-alive 的了解？keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 13、组件中 data 为什么是一个函数？ 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？ 1234567891011121314151617&#x2F;&#x2F; datadata() &#123; return &#123; message: &quot;子组件&quot;, childName:this.name &#125;&#125;&#x2F;&#x2F; new Vuenew Vue(&#123; el: &#39;#app&#39;, router, template: &#39;&lt;App&#x2F;&gt;&#39;, components: &#123;App&#125;&#125;)复制代码 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 14、v-model 的原理？我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 以 input 表单元素为例： 123456&lt;input v-model&#x3D;&#39;something&#39;&gt; 相当于&lt;input v-bind:value&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something &#x3D; $event.target.value&quot;&gt;复制代码 如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示： 123456789101112131415父组件：&lt;ModelChild v-model&#x3D;&quot;message&quot;&gt;&lt;&#x2F;ModelChild&gt;子组件：&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;&#x2F;div&gt;props:&#123; value: String&#125;,methods: &#123; test1()&#123; this.$emit(&#39;input&#39;, &#39;小红&#39;) &#125;,&#125;,复制代码 15、Vue 组件间通信有哪几种方式？Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。 （1）props / $emit 适用 父子组件通信 这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。 （2）ref 与 $parent / $children 适用 父子组件通信 ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 $parent / $children：访问父 / 子实例 （3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信 这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。 （4）$attrs/$listeners 适用于 隔代组件通信 $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 inheritAttrs 选项一起使用。 $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件 （5）provide / inject 适用于 隔代组件通信 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 （6）Vuex 适用于 父子、隔代、兄弟组件通信 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 16、你使用过 Vuex 吗？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 （1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 （2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 主要包括以下几个模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 17、使用过 Vue SSR 吗？说说 SSR？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。 服务端渲染 SSR 的优缺点如下： （1）服务端渲染的优点： 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2) 服务端渲染的缺点： 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章《Vue SSR 踩坑之旅》，里面 SSR 项目搭建以及附有项目源码。 18、vue-router 路由模式有几种？vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示： 12345678910111213141516switch (mode) &#123; case &#39;history&#39;: this.history &#x3D; new HTML5History(this, options.base) break case &#39;hash&#39;: this.history &#x3D; new HashHistory(this, options.base, this.fallback) break case &#39;abstract&#39;: this.history &#x3D; new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123; assert(false, &#96;invalid mode: $&#123;mode&#125;&#96;) &#125;&#125;复制代码 其中，3 种路由模式的说明如下： hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器； history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式； abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式. 19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？（1）hash 模式的实现原理 早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’： 12https:&#x2F;&#x2F;www.word.com#search复制代码 hash 路由模式的实现主要是基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送； hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换； 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值； 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。 （2）history 模式的实现原理 HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： 123window.history.pushState(null, null, path);window.history.replaceState(null, null, path);复制代码 history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。 20、什么是 MVVM？Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表 MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示： ![1.png](data:image/svg+xml;utf8,) （1）View 层 View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。 （2）Model 层 Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。 （3）ViewModel 层 ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。 MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。 我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然： （1）View 层 12345&lt;div id&#x3D;&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt; &lt;button v-on:click&#x3D;&quot;showMessage()&quot;&gt;Click me&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;复制代码 （2）ViewModel 层 1234567891011121314151617181920212223var app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; &#x2F;&#x2F; 用于描述视图状态 message: &#39;Hello Vue!&#39;, &#125;, methods: &#123; &#x2F;&#x2F; 用于描述视图行为 showMessage()&#123; let vm &#x3D; this; alert(vm.message); &#125; &#125;, created()&#123; let vm &#x3D; this; &#x2F;&#x2F; Ajax 获取 Model 层的数据 ajax(&#123; url: &#39;&#x2F;your&#x2F;server&#x2F;data&#x2F;api&#39;, success(res)&#123; vm.message &#x3D; res; &#125; &#125;); &#125;&#125;)复制代码 （3） Model 层 123456789&#123; &quot;url&quot;: &quot;&#x2F;your&#x2F;server&#x2F;data&#x2F;api&quot;, &quot;res&quot;: &#123; &quot;success&quot;: true, &quot;name&quot;: &quot;IoveC&quot;, &quot;domain&quot;: &quot;www.cnblogs.com&quot; &#125;&#125;复制代码 21、Vue 是如何实现数据双向绑定的？Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示： 即： 输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。 Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。 其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。 Vue 主要通过以下 4 个步骤来实现数据双向绑定的： 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。 以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章《0 到 1 掌握：Vue 核心之数据双向绑定》，有进行详细的讲解、以及代码 demo 示例。 ![1.png](data:image/svg+xml;utf8,) 22、Vue 框架怎么实现对象和数组的监听？如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下： 123456789101112131415 &#x2F;** * Observe a list of Array items. *&#x2F; observeArray (items: Array&lt;any&gt;) &#123; for (let i &#x3D; 0, l &#x3D; items.length; i &lt; l; i++) &#123; observe(items[i]) &#x2F;&#x2F; observe 功能为监测数据的变化 &#125; &#125; &#x2F;** * 对属性进行递归遍历 *&#x2F; let childOb &#x3D; !shallow &amp;&amp; observe(val) &#x2F;&#x2F; observe 功能为监测数据的变化复制代码 通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。 23、Proxy 与 Object.defineProperty 优劣对比Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利； Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。 24、Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？ 我们查看对应的 Vue 源码：vue/src/core/instance/index.js 1234567891011121314151617181920212223242526export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123; &#x2F;&#x2F; target 为数组 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; &#x2F;&#x2F; 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误 target.length &#x3D; Math.max(target.length, key) &#x2F;&#x2F; 利用数组的splice变异方法触发响应式 target.splice(key, 1, val) return val &#125; &#x2F;&#x2F; key 已经存在，直接修改属性值 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] &#x3D; val return val &#125; const ob &#x3D; (target: any).__ob__ &#x2F;&#x2F; target 本身就不是响应式数据, 直接赋值 if (!ob) &#123; target[key] &#x3D; val return val &#125; &#x2F;&#x2F; 对属性进行响应式处理 defineReactive(ob.value, key, val) ob.dep.notify() return val&#125;复制代码 我们阅读以上源码可知，vm.$set 的实现原理是： 如果目标是数组，直接使用数组的 splice 方法触发相应式； 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法） 25、虚拟 DOM 的优缺点？优点： 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限； 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率； 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。 缺点: 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。 26、虚拟 DOM 实现原理？虚拟 DOM 的实现原理主要包括以下 3 部分： 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象； diff 算法 — 比较两棵虚拟 DOM 树的差异； pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。 如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》 27、Vue 中的 key 有什么作用？key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》 所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速 更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下： 12345678910function createKeyToOldIdx (children, beginIdx, endIdx) &#123; let i, key const map &#x3D; &#123;&#125; for (i &#x3D; beginIdx; i &lt;&#x3D; endIdx; ++i) &#123; key &#x3D; children[i].key if (isDef(key)) map[key] &#x3D; i &#125; return map&#125;复制代码 28、你有对 Vue 项目进行哪些优化？如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章《 Vue 项目性能优化 — 实践指南 》，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。 （1）代码层面的优化 v-if 和 v-show 区分使用场景 computed 和 watch 区分使用场景 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if 长列表性能优化 事件的销毁 图片资源懒加载 路由懒加载 第三方插件的按需引入 优化无限列表性能 服务端渲染 SSR or 预渲染 （2）Webpack 层面的优化 Webpack 对图片进行压缩 减少 ES6 转为 ES5 的冗余代码 提取公共代码 模板预编译 提取组件的 CSS 优化 SourceMap 构建结果输出分析 Vue 项目的编译优化 （3）基础的 Web 技术的优化 开启 gzip 压缩 浏览器缓存 CDN 的使用 使用 Chrome Performance 查找性能瓶颈 29、对于即将到来的 vue3.0 特性你有什么了解的吗？Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性： （1）监测机制的改变 3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制： 只能监测属性，不能监测对象 检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 新的 observer 还提供了以下特性： 用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。 默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。 更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。 不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。 更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。 （2）模板 模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 （3）对象式的组件声明方式 vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。 此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。 （4）其它方面的更改 vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改： 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。 30、说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？本题为开放题目，欢迎大家在评论区畅所欲言，分享自己的踩坑、填坑经历，提供前车之鉴，避免大伙再次踩坑 ~~~ 总结本文以前端面试官的角度出发，对 Vue 框架中一些重要的特性、框架的原理以问题的形式进行整理汇总，意在帮助作者及读者自测下 Vue 掌握的程度。 希望对读完本文的你有帮助、有启发，如果有不足之处，欢迎批评指正交流！ 辛苦整理良久，还望手动点赞鼓励~ github地址为：github.com/fengshi123/…，汇总了作者的所有博客，也欢迎关注及 star ~","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://1314xulujin.github.io/tags/vue/"}]},{"title":"多益战盟面试题","slug":"多益战盟面试可能会问到的问题","date":"2020-05-24T01:55:40.000Z","updated":"2022-02-07T14:30:59.284Z","comments":true,"path":"2020/05/24/多益战盟面试可能会问到的问题/","link":"","permalink":"https://1314xulujin.github.io/2020/05/24/%E5%A4%9A%E7%9B%8A%E6%88%98%E7%9B%9F%E9%9D%A2%E8%AF%95%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%97%AE%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"首先有iq测试，面试官会叫你网申 1.说一下事件捕获和事件冒泡，以及应用场景？ 会扯到： DOM2级事件规定的时间流包括 三个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段 答：首先，事件捕获会在事件冒泡之前进行，在一个元素上触发事件首先他的父级会判断有没有捕获到这个事件，如果没有事件就执行到自己，然后才会开始执行事件冒泡，从等级最低的元素开始，往文档的根节点，由内而外的冒泡 阻止事件冒泡： ​ 原生：e.stopPropagation(); ​ Vue: 绑定事件时加修饰符.stop 阻止事件捕获: ​ 原生： e.stopImmediatePropagation() ​ Vue: 绑定事件时加修饰符self (加了之后只有点击自身才触发事件，什么冒泡，捕获我都不执行) 事件冒泡的应用： 比如最简单的弹出层：当点击提交按钮的时候提交信息，当点击弹出层周边的空白区域的时候取消遮罩。但是因为存在事件冒泡机制，点击提交按钮时，点击事件会冒泡到div弹出层，以致遮罩层自动取消，这时我们就 Vue修饰符： .lazy：当表单的内容发生改变且失去焦点时触发，代替了@change事件 .trim: 修建两边空白字符 .number: 开头输入数字，后面也只能输入数字 .stop: 阻止事件冒泡 .prevent： 阻止默认事件 .self：只有点击自身才会触发方法，冒泡和捕获不会影响他 .once: 只执行一次该事件 .native： 组件绑定当前组件的事件是不会触发的，需要用native才能触发： @keydown的修饰符和@click的修饰符 .exact精确触发 .keyCode 2.说一下Vue的常用指令？ v-model 双向绑定指令 v-bind 绑定属性指令(语法糖写法”:”) v-on 绑定事件指令(语法糖写法”@”) v-show 控制隐藏和显示的指令，值是boolean v-for 列表渲染指令(就是循环) v-if v-else-if v-else 控制DOM删除的添加的指令，值是boolean v-once 只渲染一次的指令 v-pre 跳过模板渲染的指令 v-cloak 解决花括号模板刷新时闪烁出现的问题 3.说一下常见的http响应头及其作用 ​ http包头分为 ​ 普通包头： ​ Request URL: 请求地址 ​ Request Methods: 请求的方法 ​ Status Code: 状态码 ​ 响应包头(主要将这个) Content-Type：服务器通过这个头告诉浏览器回送数据的类型 Last-Modified：告诉浏览器当前资源的最后缓存时间 ​ Expires：告诉浏览器把回送的资源缓存多长时间 -1或0则是不缓存 ​ Server ：服务端服务器的类型Apache/nginx ​ Refresh: 告诉浏览器多久刷新一次 ​ Cache-Contrl: no-cache ​ 请求包头： ​ Accept：用于高速服务器，客户机支持的数据类型 ​ If-Modified-Since：客户机通过这个头告诉服务器，资源的缓存时间 ​ Cookie： 请求头里面发给服务端的数据 ​ Authorization: 发给服务端的token，用于验证该用户是否登录过期，还有是否登录了再请求 4.聊一下缓存 浏览器缓存： ​ Cache-Control: no-cache ​ Last-Modified：告诉浏览器当前资源的最后缓存时间 ​ If-Modified-Since：客户机通过这个头告诉服务器，资源的缓存时间 ​ web缓存实际上除了浏览器缓存，还有代理缓存、网关缓存、CDN、反向代理缓存等。 按照自己的理解展开来讲，和面试官聊起来","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"温奕龙面试经验题目","slug":"温奕龙面试经验题目","date":"2020-05-24T00:56:47.000Z","updated":"2020-06-21T13:10:21.382Z","comments":true,"path":"2020/05/24/温奕龙面试经验题目/","link":"","permalink":"https://1314xulujin.github.io/2020/05/24/%E6%B8%A9%E5%A5%95%E9%BE%99%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E9%A2%98%E7%9B%AE/","excerpt":"","text":"面得中级，都是外包前两轮:css部分：1.rgba,opacity区别rgba:R：红色值。正整数 | 百分数G：绿色值。正整数 | 百分数B：蓝色值。正整数 | 百分数A：Alpha透明度。取值0~1之间 opacity:后面的取值为从 0.0 （完全透明）到 1.0（完全不透明）。 两者的区别：opacity会继承父元素的 opacity 属性，而RGBA设置的元素的后代元素不会继承不透明属性 2.因为简历写了flex相关，问了比较多flex的问题，比如谈谈传统布局和flex布局区别，说出3-5个flex属性3.移动端1px问题了解么？谈谈你是如何解决的4.谈谈你对rem的理解，rem单位是相对于谁？5.移动端项目遇到过什么兼容性问题么？说说你是怎么解决的？常用的解决兼容性方案你用得哪些？6.常用伪类有哪些？说几个。如果想获取父元素下第2个子元素，用哪个伪类？ js部分：1.原生touch事件了解么？谈谈你的理解。能手写或封装相关事件。（这里忘得差不多了，只说了几个基本事件。然后大概描述了下如何区别左滑右滑）2.ts了解么，说说ts。(这里我回答es6没用透，暂时没去学ts，只说了什么是ts。他就去问es6了)3.es6有用过吧？5个以上你常用的es64.谈谈箭头函数this指向，谈谈作用域和作用域链，是定义时确定还是调用时确定5.如果项目不兼容es6，你是如何解决的？我回答我的项目基本是面向指定客户，没这个烦恼。外加有webpack插件转译。他就跳过了6.本地存储，会话存储区别 vue 相关：1.vue-router模式有几种？实现原理？（每个都问）2.谈谈你对计算属性的认识3.生命周期知道吧？阐述下，然后说说钩子间能干什么？ beforeMounted-&gt;mounted 之间有什么变化？（问的也比较多）4.v-model 原理5.谈谈你对MVVM认识6.父子组件渲染顺序（这个没遇到过，答不出来）7.组件传值方式 后两轮技术面试，主要针对简历项目问了下1.柯里化听过么，谈谈你的认识2.vue响应式原理了解吧?问的比较细，数据劫持和发布订阅模式怎么实现大概都问了下3.前端优化做过吗，4个以上4.webpack原理，大概说下5.开发环境代理跨域如何解决？生产环境代理跨域如何解决？（生产环境没答出来）6.单页面应用如何优化？7.有封装组件的经验吗？(我谈了jq封装。然后他问的比较细)8.ajax/axios 封装过吗？(谈谈你封装的大概思路。我谈了下axios配置，拦截器，get相关接口，请求路径的封装，他就跳过了)9.vue组件封装过吗?谈谈你的封装过程。(我谈了下通过v-bind自定义样式和slot自定义插槽，他就跳过了)10.http 1.0,http2.0了解吗？（这里答不上）11.vue-router,vuex实现原理，vue-router的几种模式，history模式有什么要注意的 ——-项目相关1.你的项目主要技术栈，做什么的，可以搜到不2.项目写了后台系统，详细问了下登录拦截，用户鉴权怎么实现3.canvas用过么，自己造轮子还是用的插件。你项目echats都用的哪些组件？和three.js区别能说出来么？（区别答不出来） promise setTimeout 同步事件队列 组件通信 bus集成总线 虚拟dom真实dom面试题","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"马哥面试经验题目","slug":"马哥面试经验题目","date":"2020-05-24T00:56:47.000Z","updated":"2020-06-21T13:10:21.388Z","comments":true,"path":"2020/05/24/马哥面试经验题目/","link":"","permalink":"https://1314xulujin.github.io/2020/05/24/%E9%A9%AC%E5%93%A5%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E9%A2%98%E7%9B%AE/","excerpt":"","text":"css 12341. transform，transition和translate的区别 答：首先，三者的中文意思transform(变形，变换)，translate(调动)，transition(过渡) transform是css3的属性；而translate是tranform的属性值，指的是元素平移的值；transition也是css3的属性，作用是用来实现一组css属性变换到另一组css属性的动画过程，其参数有 transition-property(需要过渡的属性，如宽度) transition-duration(过渡的总时间) transition-delay(动画延迟播放的时间) transition-timing-function(时间曲线) Vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541. 生命周期的实现原理？ 答： 用一句话来说：Vue生命周期就是从开始创建实例，初始化数据；然后编译template模板，挂载到dom上，进行更新，渲染，最后卸载，销毁实例。 2. $nextick 答： 1.作用：因为Vue在数据更新之后其DOM是不会立即更新的，而是按Vue规划的一定的策略进行更细DOM，所以会导致我们修改data的数据时，获取DOM的数据给data的另外的一个变量再在DOM里面渲染DOM不会更新，我们会看不到更新的效果，这时我们就用到$nextTick进行延迟到其DOM更新完毕时进行获取数据。 2.原理：我们看$nextTick源码，里面的定时器就是他的精髓，我们碰到DOM更新渲染不出来的时候用到定时器来延迟，有时也是有用的，但是Vue中封装好的$nextTick似乎更好 3. Vue 中这些挂载的顺序 prop methods data computed watch4. Vue各种守卫钩子，说出钩子函数及其参数就够了 答： 1.全局前置守卫:beforeEach((to, from, next)=&gt;&#123; &#125;) 2.全局解析守卫:beforeResolve((to, from, next)=&gt;&#123; &#125;) 3.你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导 航本身： 全局后置钩子(不能守卫导航获取不到this):afterEach((to, from)=&gt;&#123; &#125;) 4.路由独享守卫:beforeEnter() const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/foo&#x27;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ] &#125;) 5.组件内守卫:beforeRouter(),beforeRouteUpdate(),beforeRouteLeave() const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 &#125;, //不过，你可以通过传一个回调给 next来访问组件实例。 //在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。 beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 &#125;) &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125; &#125; 5. Vue组件传值 答： 一.父到子： 1.父组件将数据v-bind到子节点上面 例如子节点&lt;sonCom v-bind:msg=&quot;父组件的数据&quot; &gt;,子组件在实例中使用props:[&#x27;msg&#x27;]接收使用。 6. 利用div实现table，不能用flex布局和table标签 答： 给最外层作为table的div加属性display:table，给作为tr的div加属性display:table-row属性,给作为th和td的div加属性display:table-cell。7. 左右布局，左边固定宽度，右边自适应 答： ①：给他加float:left，右边的盒子width:100%。 ②：他们的父级盒子加display:flex弹性盒子，右边的盒子添加属性flex:1。 ③：假如左边为200px，左右俩个盒子都添加属性float:left,右边的盒子设置宽度 width:calc(100% - 200px) 8. 数组去重的方法 答： 例：let arr = [1,2,4,5,1,5,5,4,58,1,5,4,5,1,1,5,2,2] 1.indexOf let tmp = [] for( var i=0;i&lt;arr.length;i++ )&#123; if( tmp.indexOf(arr[i]) == -1 )&#123; tmp.push( arr[i] ) &#125; &#125; 2.es6(set) Array.from(new Set(arr)) 3.利用sort() arr = arr.sort() let arr2 = arr[0] for( var i=1;i&lt;arrlength;i++ )&#123; if( arr[i] !== arr[i-1] )&#123; arr2.push( arr[i] ) &#125; &#125; 9. 函数组件和动态组件 答: 10. keep-alive 答: 1.keep-alive是用来缓存组件，避免多次加载相应的组件，减少重新加载组件的消耗，简单一点来说，就是从A到B页面之后再返回A页面将不会重新执行页面A的代码，只会从缓存中加载已经缓存的A页面。 2.keep-alive组件中的参数 一.include and exclude 2.1.0 新增 include 和 exclude prop 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示： &lt;!-- 逗号分隔字符串 --&gt; &lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 正则表达式 (使用 `v-bind`) --&gt; &lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 数组 (使用 `v-bind`) --&gt; &lt;keep-alive :include=&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; 匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配。 二.max 2.5.0 新增 最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。 &lt;keep-alive :max=&quot;10&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; javaScript 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475761. 项目中用到哪些es6？ 答：解构赋值，promise，async和await，for of遍历数组。 2. 谈谈你对闭包的理解？ 答：一个函数可以访问另一个函数内部的作用域。 3. 继承4. 构造函数 constructor指回(es5)5. map和foreach区别 答：map返回一个新数组，函数里面需要return;6. 事件冒泡说一下 答： 7. async和await的原理讲一下 答： 8. js数据类型 答：加上es6的symbol 9. js文件的加载方式10. jsonp详细说一下，会问具体代码 答： 原理：创建一个script标签，将路径，需要传过去的参数和回调函数拼接后添加给script的src， 将完整的script添加到网页中请求然后删除。 详情见本博客文章 https://1314xulujin.github.io/2020/05/27/%E5%8E%9F%E7%94%9Fjsonp%E8%B7%A8%E5%9F%9F/ 11. http2.0和http1.1的区别 答： 1.新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 2.多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 3.header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 4.服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。 12. cookie的存活周期 答: 13. js原型链 答: 1.首先先说原型，每一个对象他都有原型，这个原型对象由对象的内置属性__proto__指向他的constructor(构造函数)的prototype指向的对象，也就是说每一个对象都是一个构造函数创建的，但不是每一个对象都有prototype,只有方法才有。 2.原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就一层层的扒出创建对象的constructor(构造函数)，直至到Object时，就没有_proto_指向了。14. jQuery封装方法 答: // myplugin为自定义封装的方法名字 $.fn.myplugin = function () &#123; // 这里写方法的业务逻辑 this.fadeOut() &#125; // 调用 $(&quot;.element&quot;).myplugin() 15. 原生ajax的封装 function ajax (url, fn) &#123; var xhr = new XMLHttpRequest() xhr.open( &quot;GET&quot;, url, false ) xhr.onreadystatechange = function () &#123; if( xhr.readyState == 4 )&#123; console.log( xhr.responseText ) fn.call( xhr.responseText ) &#125; &#125; &#125; // 调用 ajax(&#123; url: &#x27;https://www.baidu.com&#x27;, success: function () &#123; &#125; &#125;) 移动端： 1231. 移动端的1px问题 2. 工作中移动端碰到兼容性的问题 安全问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758591. xss攻击 答: 1.定义:xss攻击指的是攻击者通过巧妙的方式在网页代码中恶意注入一些特殊的代码使其运 行，这些代码多数是js脚本，但也有可能是java，vbscript，flash，甚至是HTML标记语 言，攻击者在攻击成功后将会得到一些权限切不限于更高的权限，如查看私密的内容，修改一些 只有超级管理员才能修改的内容，盗取用户会话存储和cookie等。 2.防范技巧，过滤一些特殊dom事件，如点击事件；过滤一些特殊符号，如&#x27;&lt;&#x27; 和 &#x27;&gt;&#x27;; 禁止一些网页跳转操作。 3.在Vue中使用xss防范插件 // main.js import VueXss from &#x27;vue-xss&#x27; Vue.use(VueXss) &lt;!-- *.vue --&gt; &lt;div v-html=&quot;$xss(content)&quot;&gt;&lt;/div&gt; // main.js var options = &#123; // 默认白名单参考 xss.whiteList whiteList: &#123; a: [&#x27;href&#x27;, &#x27;style&#x27;], img: [&#x27;src&#x27;, &#x27;alt&#x27;], ... &#125;, stripIgnoreTag: true, // 去掉不在白名单上的标签 true：去掉不在白名单上的标签 stripIgnoreTagBody: [&#x27;script&#x27;, &#x27;style&#x27;] // 去掉不在白名单上的标签及标签体 [&#x27;tag1&#x27;, &#x27;tag2&#x27;]：仅去掉指定的不在白名单上的标签 onTagAttr: function () &#123; // todo &#125;, ... &#125; Vue.use(VueXss, options) &lt;!-- *.vue --&gt; &lt;template&gt; &lt;div v-html=&quot;$xss(content)&quot;&gt;&lt;/div&gt; &lt;!-- 过滤后输出：&lt;iframe&gt;&lt;/iframe&gt; --&gt; &lt;template&gt; &lt;script&gt; export default &#123; data () &#123; return&#123; content: &#x27;&lt;iframe onload=alert(&quot;XSS-TEST&quot;)&gt;&lt;/iframe&gt;&#x27; &#125; &#125;, ... &#125; &lt;/script&gt; 2. 你们前端对用户的密码进行加密用了那些？ 答：利用md5加密密码放在请求包头里面发给后端。 自动化工具 12345678910111213141516171819201. webpack如何设置跨域？ 答: 在config文件夹中的index.js中的dev属性对象中的proxyTable中设置需要跨域访问的站 点，例如: module.exports = &#123; dev: &#123; proxyTable: &#123; &#x27;/admin&#x27;: &#123; target:&quot;https://snackshop.lby.link/&quot;, secure: false,//运行在https协议上 changeOrigin: true, //是否跨域 &#125; &#125; &#125; &#125; 2. git的流程 见本博客文章 地址：https://1314xulujin.github.io/2020/01/31/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/ 对前端的优化 ​ 答：减少http请求，防止回流和重绘(减少DOM操作)，对用户操作比较频繁的操作进行防抖和节流，清除需要清除的定时器，减少css选择符（前端优化的视频 https://www.bilibili.com/video/BV1ZE411r7ri ） 其他 121. 如果整个项目中内存泄漏，需要怎么检测出来2. 整个项目组是怎么测试bug的 实战全栈项目bilibili https://www.bilibili.com/video/BV1EE411B7SU","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"2020年5月14日面试笔试题","slug":"2020年5月14日面试笔试题","date":"2020-05-16T11:45:51.000Z","updated":"2020-06-21T13:10:21.226Z","comments":true,"path":"2020/05/16/2020年5月14日面试笔试题/","link":"","permalink":"https://1314xulujin.github.io/2020/05/16/2020%E5%B9%B45%E6%9C%8814%E6%97%A5%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98/","excerpt":"","text":"Vue1.Vue常用指令及其作用​ v-model 双向绑定指令 ​ v-bind 绑定属性指令(语法糖写法”:”) ​ v-on 绑定事件指令(语法糖写法”@”) ​ v-show 控制隐藏和显示的指令，值是boolean ​ v-for 列表渲染指令(就是循环) ​ v-if v-else-if v-else 控制DOM删除的添加的指令，值是boolean ​ v-once 只渲染一次的指令 ​ v-pre 跳过模板渲染的指令 ​ v-cloak 解决花括号模板刷新时闪烁出现的问题 2.Vue父子组件传值父到子： 1234567891011121314151.在该父组件里的子组件里面v-bind父组件需要传的值，子组件使用prop来接收属性名，即可获取到传过来的值。2.$parent在父组件里面使用，可直接获取到其父组件，并且父组件里面的值就可以获取的到。3.使用provide和inject,provide为提供值的一方,例： provide:function()&#123; return &#123; apple:this.title &#125; &#125;inject为接收的一方 inject:[&#x27;apple&#x27;]这样就接受到了其他组件传过来的值 子到父： 1234567891011121314151.在组件定义一个方法绑定到子组件的模板中去，方法里用this.$emit(第一个参数，第二参数)，第一个参数为发送的方法键名在父组件中写为(@第一个参数)，键值为方法名，可在父组件的methods使用；第二个参数为发送的一些值，可在父组件中的键值方法中获取的到2.$children在子组件里面使用，可直接获取到子组件的(为一个数组，使用下标获取到想要的子组件)，并且子组件里面的值就可以获取的到。3.使用provide和inject,provide为提供值的一方,例： provide:function()&#123; return &#123; apple:this.title &#125; &#125;inject为接收的一方 inject:[&#x27;apple&#x27;]这样就接受到了其他组件传过来的值 3.Vue如何阻止事件冒泡比如@click.stop=”” 4.Vue生命周期1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950beforeCreate() 在实例初始化之后，数据观测(data observer) 和 event&#x2F;watcher 事件配置之前被调用。 created() 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch&#x2F;event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount() 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted() el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate() 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated() 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。beforeDestroy() 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed() Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 CSS1.css3的新特性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899答:1.css选择器(属性选择器和伪类选择器) E[att^=&quot;val&quot;]匹配具有att属性、且值以val开头的E元素 E[att$=&quot;val&quot;]匹配具有att属性、且值以val结尾的E元素 E[att*=&quot;val&quot;]匹配具有att属性、且值中含有val的E元素 E:root匹配文档的根元素。在HTML中，根元素永远是HTML E:nth-child(n)匹配父元素中的第n个子元素E E:nth-last-child(n)匹配父元素中的倒数第n个结构子元素E E:nth-of-type(n)匹配同类型中的第n个同级兄弟元素E E:nth-last-of-type(n)匹配同类型中的倒数第n个同级兄弟元素E E:last-child匹配父元素中最后一个E元素 E:first-of-type匹配同级兄弟元素中的第一个E元素 E:only-child匹配属于父元素中唯一子元素的E E:only-of-type匹配属于同类型中唯一兄弟元素的E E:empty匹配没有任何子元素（包括text节点）的元素E :target匹配相关URL指向的E元素 E:enabled匹配所有用户界面（form表单）中处于可用状态的E元素 E:disabled匹配所有用户界面（form表单）中处于不可用状态的E元素 E:checked匹配所有用户界面（form表单）中处于选中状态的元素E E::selection匹配E元素中被用户选中或处于高亮状态的部分 E:not(s)匹配所有不匹配简单选择符s的元素E 2.css样式特效部分： 圆角：border-radius: 参数一(圆角半径单位可以是字体大小的所有单位) 盒子阴影:box-shadow:0 0 2px 2px #fff inset; 阴影上下偏移距离 阴影左右偏移距离 阴影宽度 阴影模糊程度 颜色 inset表示阴影在内部 文字阴影:text-shadow 颜色渐变:backgrount: linear-gradient(直线渐变) radial-gradient径向渐变 background：rgba()颜色属性 边框图像：border-image 滤镜：filter:rayscale(100%)、褐色filter:sepia(1)、饱和度saturate(2)、色相旋转hue-rotate(90deg) 模糊blur(3px) 透明度:opacity:0.5 3.css高级部分 transform： rotate 旋转(rotateX,rotateY,rotateZ)以下三个都有X/Y/Z scale 缩放 translate 平移 transform-origin 中心点调整 transition: 过渡 transition-property 需要过度的属性 transition-duration 过渡的总时间 transition-timing-function 过渡的时间曲线 transition-delay 过渡的延迟发生时间 matrix 矩阵参数 animation：动画 animation-name 动画名称 animation-duration 动画总时间 animation-timing-function 动画时间曲线 animation-delay 动画延迟时间 animation-iteration-count 动画播放方式(重复还是一次) animation-direction 动画播放是否来回播放(方向) animation-fill-mode 动画天从模式none(正常)|forwards(在动画初始位置停止)|backwards(动画在最后位置停止)|both(都有); @keyframe 动画名称&#123; 0%&#123; &#125; 100%&#123; &#125; &#125; 4.盒子反射box-reflect方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片 5.弹性布局：flex见菜鸟教程官方文档教程 https://www.runoob.com/css3/css3-flexbox.html 栅格布局：gird 6.媒体查询:@media () &#123; &#125; js​ 1.关于promise输出的先后顺序的题目 ​ 2.关于定义变量作用域和变量命名(用输出的先后顺序和输出结果来做题目) ​ 3.for( var i=0;i&lt;5;i++ ){ ​ if( i=3 ) continue ​ console.log(i) ​ } 输出什么 ​ 小程序​ 1.bindTap和catchTap的区别 ​ 答：bindtap绑定事件会冒泡到父级元素上面，catchTap不会","categories":[],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"2020年05月10日面试题","slug":"2020年05月10日面试题","date":"2020-05-10T06:32:51.000Z","updated":"2020-06-21T13:10:21.223Z","comments":true,"path":"2020/05/10/2020年05月10日面试题/","link":"","permalink":"https://1314xulujin.github.io/2020/05/10/2020%E5%B9%B405%E6%9C%8810%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"2020年05月10日面试题一.Vue1.Vue父组件和子组件之间传值？父到子： 1234567891011121314151.在该父组件里的子组件里面v-bind父组件需要传的值，子组件使用prop来接收属性名，即可获取到传过来的值。2.$parent在父组件里面使用，可直接获取到其父组件，并且父组件里面的值就可以获取的到。3.使用provide和inject,provide为提供值的一方,例： provide:function()&#123; return &#123; apple:this.title &#125; &#125;inject为接收的一方 inject:[&#x27;apple&#x27;]这样就接受到了其他组件传过来的值 子到父： 1234567891011121314151.在组件定义一个方法绑定到子组件的模板中去，方法里用this.$emit(第一个参数，第二参数)，第一个参数为发送的方法键名在父组件中写为(@第一个参数)，键值为方法名，可在父组件的methods使用；第二个参数为发送的一些值，可在父组件中的键值方法中获取的到2.$children在子组件里面使用，可直接获取到子组件的(为一个数组，使用下标获取到想要的子组件)，并且子组件里面的值就可以获取的到。3.使用provide和inject,provide为提供值的一方,例： provide:function()&#123; return &#123; apple:this.title &#125; &#125;inject为接收的一方 inject:[&#x27;apple&#x27;]这样就接受到了其他组件传过来的值 2.Vue常用指令？v-model 双向绑定指令 v-bind 绑定属性指令(语法糖写法”:”) v-on 绑定事件指令(语法糖写法”@”) v-show 控制隐藏和显示的指令，值是boolean v-for 列表渲染指令(就是循环) v-if v-else-if v-else 控制DOM删除的添加的指令，值是boolean v-once 只渲染一次的指令 v-pre 跳过模板渲染的指令 v-cloak 解决花括号模板刷新时闪烁出现的问题 3.Vue中v-if和v-show的区别？答： v-if是对dom节点进行删除或添加，达到隐藏和出现的效果，切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件。 ​ v-show是把节点的display属性设置为none达到隐藏的效果。 4.Vue生命周期？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950beforeCreate() 在实例初始化之后，数据观测(data observer) 和 event&#x2F;watcher 事件配置之前被调用。 created() 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch&#x2F;event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount() 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted() el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate() 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated() 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。beforeDestroy() 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed() Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 二.js1.手写js冒泡排序1234567891011121314151617181920212223242526272829303132333435363738394041424344/** 冒泡排序算法: (每一轮循环)每次把数组中的前一项与其后一项的对比,如果前一项,大于后一项,则两个人交换位置. 冒泡排序的过程: 第一轮: 1.[3,5,1,4,2] 2.[3,1,5,4,2] 3.[3,1,4,5,2] 4.[3,1,4,2,5] (找出数组中的最大值) 5.[3,1,4,2,5] 第二轮: 6.[1,3,4,2,5] 7.[1,3,4,2,5] 8.[1,3,2,4,5] 9.[1,3,2,4,5] 10.[1,3,2,4,5] 第三轮: 11.[1,3,2,4,5] 12.[1,2,3,4,5] 13.[1,2,3,4,5] 14.[1,2,3,4,5] 15.[1,2,3,4,5] ... 第五轮: .... */var arr = [1,5,15,456,45465,78487,4];for(var i=0;i&lt;arr.length-1;i++)&#123; for(var j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; var tmp = arr[j] arr[j] = arr[j+1] arr[j+1] = tmp &#125; &#125;&#125;console.log(arr ) 2.手写数组去重算法123456789101112131415161718192021//1. indexOfvar arr = [1,1,2,2,5,5,8,4,6,4,54,5,4,5,1,5,4,1,1,5,8,4]var tmp = []for( var i=0;i&lt;arr.length;i++ )&#123; if( tmp.indexOf(arr[i]) == -1 )&#123; tmp.push(arr[i]) &#125;&#125;console.log(tmp)//2. es6(set)Array.from(new Set(arr))//3. 利用sort()// 原理先将arr中的0位置的给arr2的0位置，再遍历arr从1位置开始，如果第1位置数不等于第0位置数就将第1位置数推进去，以此类推，如果第i位置数不等于第i-1位置数就将i位置数推进arr2，最后达到效果arr = arr.sort()var arr2 = [arr[0]]for( var i=1;i&lt;arr.length;i++ )&#123; if( arr[i] !== arr[i-1] )&#123; arr2.push(arr[i]) &#125;&#125; 3.手写九九乘法表(要求排版和乘法表一样)12345678910111213//外层1-9(i)乘数//内层1-i(j)被乘数//i*j=结果var i = 1;while(i&lt;10)&#123; var j = 1; while(j&lt;=i)&#123; document.write(`\\n$&#123;i&#125;*$&#123;j&#125;=$&#123;i*j&#125;`) j++ &#125; document.write(&#x27;&lt;br/&gt;&#x27;) i++&#125;","categories":[],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"let和var的区别","slug":"let和var的区别","date":"2020-05-02T06:15:00.000Z","updated":"2020-06-21T13:10:21.278Z","comments":true,"path":"2020/05/02/let和var的区别/","link":"","permalink":"https://1314xulujin.github.io/2020/05/02/let%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"let和var的区别：1.关于重复定义：不同点：​ ①var可以重复定义，新定义的值会覆盖前面定义的，var m=100,m=500;//不会报错。 ​ let不可以重复定义，会报错，let m=100,m=500;// 错误为：Uncaught SyntaxError: Identifier ‘m’ has already been declared ​ 2.关于作用域：相同点：var和let定义的变量都会变量提升不同点：​ ①var定义的变量可以是全局作用域和函数作用域，在全局作用域里面定义之后可以在window中获取的到 &gt;如果在同时在全局和函数里用var定义一个相同的变量，是不会互相影响的； &gt;而var没用块级作用域，如果在if或者for循环这样语句中使用，我们还是可以在全局中访问得到他。 ​ let定义的变量可以是块级作用域，(块级作用域指的是在小括号”()”和花括号”{}”里面的作用域)。 &gt;如果let在if和for循环定义一个变量，这个变量在全局是获取不到的，里面会产生块级作用域。 ​ ②var和let变量提升之后，如果在上面输出var定义的变量会得到undefined，而let定义的变量在上面输出会报错(test.html:10 Uncaught ReferenceError: Cannot access ‘a’ before initialization at test.html:10)，我们把let这种情况叫做暂时性死区。","categories":[],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"一个页面的增删改查有哪些方法","slug":"一个页面的增删改查有那些方法","date":"2020-04-30T08:42:01.000Z","updated":"2020-07-14T10:16:32.535Z","comments":true,"path":"2020/04/30/一个页面的增删改查有那些方法/","link":"","permalink":"https://1314xulujin.github.io/2020/04/30/%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%9C%89%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95/","excerpt":"","text":"data:1.表单验证器 2.一些表格的值tableList和一些表单的值form 3.表单验证的规则等等 mounted:1.获取一些需要打开页面需要的数据，比如所有的用户的信息渲染到页面。 methods:getEuicpUser:一个公用的方法，比如selectByPage分页查找数据，在增删改查的时候都需要重新调用一次search:查询方法，里面调用查询接口后还需调用getEuicpUser方法currentChange:分页方法，里面也需要调用getEuicpUser方法，传需要的参数达到分页效果insertRept:添加，编辑方法合体，设置其insert的isAdd码(1为新增，2为编辑)，分别调用新增和编辑接口addUser:设置其isAdd = ‘1’,在点击确定也就是insertRepteditClick:设置其isAdd = ‘2’点击编辑按钮触发，调用查询接口将已经设置的数据渲染到表单，对需要修改的自行操作，在点击确定时也就是insertReptdetailClick:详情按钮，和编辑按钮相似，不过只调用一开始获取用户信息渲染到表单上查看delClick:删除，调用删除接口，一般参数有删除的用户iD，如果有status就会做软删除(就是把status改成无效，本质不删除)resetForm:重置表单操作，在新增，编辑，查看详情之后还需将表单的内容清空","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://1314xulujin.github.io/tags/vue/"}]},{"title":"数组冒泡排序","slug":"数组冒泡排序","date":"2020-04-30T08:42:01.000Z","updated":"2020-06-21T13:10:21.372Z","comments":true,"path":"2020/04/30/数组冒泡排序/","link":"","permalink":"https://1314xulujin.github.io/2020/04/30/%E6%95%B0%E7%BB%84%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"关于虚拟DOM渲染和真实DOM的关系","slug":"关于虚拟DOM渲染和真实DOM的关系","date":"2020-04-29T09:11:11.000Z","updated":"2020-06-21T13:10:21.341Z","comments":true,"path":"2020/04/29/关于虚拟DOM渲染和真实DOM的关系/","link":"","permalink":"https://1314xulujin.github.io/2020/04/29/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%8B%9FDOM%E6%B8%B2%E6%9F%93%E5%92%8C%E7%9C%9F%E5%AE%9EDOM%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"","text":"关于虚拟DOM渲染和真实DOM的关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Vue.js基础&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 视图区域 --&gt; &lt;div id=&quot;page&quot; class=&quot;page&quot; :class=&quot;&#123;changed: changed == true&#125;&quot;&gt; &lt;button @click=&quot;onclickChange&quot;&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../lib/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //创建vue实例 （vm视图模型） let vm = new Vue(&#123; el:&quot;#page&quot;,//指定元素渲染的挂载位置（根元素节点）, data:&#123; changed:false &#125;, mounted () &#123; this.el = document.getElementById(&quot;page&quot;); this.el.className += &quot; page-show&quot; &#125;, methods:&#123; onclickChange()&#123; console.log(&quot;1.&quot;,page.className); this.changed = true;//会触发虚拟DOM重新渲染 console.log(this.changed) console.log(&quot;2.&quot;,page.className); setTimeout(function()&#123; console.log(&quot;3.&quot;,page.className) &#125;,0) &#125;, //输出结果为 //page page-show //page page-show //page changed //第一是改变真实DOM后获取，第二个也是在真实DOM获取，但是没有获取到虚拟DOM渲染后的结果，因为需要异步获取，第三个异步获取到了最后的结果，因为this.changed = true触发了虚拟DOM重新渲染，所以输出了page changed这个结果。 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Vue.js基础&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 视图区域 --&gt; &lt;div id=&quot;page&quot; class=&quot;page&quot; :class=&quot;&#123;changed: changed == true&#125;&quot;&gt; &lt;button @click=&quot;onclickChange&quot;&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../lib/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //创建vue实例 （vm视图模型） let vm = new Vue(&#123; el:&quot;#page&quot;,//指定元素渲染的挂载位置（根元素节点）, data:&#123; changed:false &#125;, mounted () &#123; this.el = document.getElementById(&quot;page&quot;); this.el.className += &quot; page-show&quot; &#125;, methods:&#123; onclickChange:()=&gt;&#123;//箭头函数么有this， console.log(&quot;1.&quot;,page.className); this.changed = true;//这里不会触发虚拟DOM重新渲染 console.log(this.changed) console.log(&quot;2.&quot;,page.className); setTimeout(function()&#123; console.log(&quot;3.&quot;,page.className) &#125;,0) &#125;, //输出结果为 //page page-show //page page-show //page page-show //箭头函数没有this，里面的this会指向window所以根本没有使data里面的changed改变，就不会触发虚拟DOM渲染，所以输出上面的结果。 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://1314xulujin.github.io/tags/vue/"}]},{"title":"Vue面试题13道","slug":"Vue面试题13道","date":"2020-04-27T05:36:39.000Z","updated":"2020-06-21T13:10:21.261Z","comments":true,"path":"2020/04/27/Vue面试题13道/","link":"","permalink":"https://1314xulujin.github.io/2020/04/27/Vue%E9%9D%A2%E8%AF%95%E9%A2%9813%E9%81%93/","excerpt":"","text":"1231.Vue2.0框架中哪个指令是实现列表渲染的？A. v-show B. v-repeat C. v-while D. v-for正确答案：D 1232.Vue框架中哪个指令是实现数据双向绑定的？A. v-show B. v-bind C. v-model D. v-data正确答案：C 1233.Vue框架中计算属性是用哪个关键字？A. computed B. watch C. created D. computer正确答案：A 1234.Vue框架中以下选项哪几个是常见的事件修饰符? A. native B. stop C. prevent D. enter E. start 正确答案:ABCD 1235.Vue框架中v-if和v-show 指令有什么区别？ 答：v-if是对dom节点进行删除或添加，达到隐藏和出现的效果，切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件。 v-show是把节点的display属性设置为none达到隐藏的效果。 1236.Vue中全局组件和局部组件的区别？ 答：全局组件：是注册在vm根实例里面的组件，可以在任何地方使用，且已经注册完成，无需注册。 局部组件：利用一个对象的形式来创建，不管是在vm根实例中使用还是在其他vm里面的组件里面使用都要注册，才能在注册的实例中使用。 127.vue-router中的history模式和hash模式有什么区别？ 答：使用url中的hash（#后面的参数）后面的参数来作为路由，通过监听，此参数的变化找到对应的组件及其内容，更新到页面中去，支持所有浏览器。 12348.怎么在Vue中点击别的区域输入框不会失去焦点？ 答： 阻止事件的默认行为。 具体操作：监听你想点击后不会丢失input焦点的那个元素的mousedown事件,回调里面调用event.preventDefault()，会阻止使当前焦点丢失这一默认行为。 1239.vue中的data属性可以和methods的方法同名吗？为什么？ 答：不可以，会报错; 因为data中的属性和methods中的方法重名时，属性名会覆盖方法名，会报this.*** is not a function的错误。 1234510.keep-alive内置组件的生命周期有哪些？请具体描述。 答： 1.activated():keep-alive中的组件被激活时触发。 2.deactivated():keep-alive中的组件被暂时挂起时触发。 3.destroyed():keep-alive中的组件被销毁时触发。 123411.Vue能监听到的数组变化的方法有哪些？为什么这些方法可以被监听到呢？ 答： push(),pop(),shift(),unshift(),splice(),sort(),reverse(); 因为watch监听是data中的数据变化，而上面这些方法会使原数组发生变化，则watch就能监听到。 1234567891011121312.vue中的计算属性和监听有什么区别？说说各自的特点及其应用场景。 答： 区别： computed： 1.会有缓存，只有依赖数据发生变化时，才会重新计算属性； 2.不支持异步，当computed内有异步操作时无效，无法监听数据的变化； 3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值 watch： 1. 不支持缓存，数据变，直接会触发相应的操作； 2.watch支持异步； 3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值； 场景：computed在计算数据量较小的时候更好用，而watch用于计算数据量较大的时候才用会更好。 123456789101112131415161718192021222324252613.请描述vue中的常用生命钩子函数？ 答： beforeCreate： 当实例创建之前触发 created： 当实例被创建的时候触发 beforeMounte： 当实例挂载之前触发 mounted: 当实例被挂载的时候触发 beforeUpdate： 当虚拟DOM重新渲染之前触发 updated： 当虚拟DOM重新渲染时触发 beforeDestroy： 当实例销毁之前触发 destroyed： 当实例销毁后触发","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://1314xulujin.github.io/tags/vue/"}]},{"title":"用webpack4.0撸一个单页/多页脚手架工具(支持jquery,react,vue,typescript)","slug":"用webpack4-0撸一个单页-多页脚手架工具-支持jquery-react-vue-typescript","date":"2020-04-27T05:14:23.000Z","updated":"2020-06-21T13:10:21.385Z","comments":true,"path":"2020/04/27/用webpack4-0撸一个单页-多页脚手架工具-支持jquery-react-vue-typescript/","link":"","permalink":"https://1314xulujin.github.io/2020/04/27/%E7%94%A8webpack4-0%E6%92%B8%E4%B8%80%E4%B8%AA%E5%8D%95%E9%A1%B5-%E5%A4%9A%E9%A1%B5%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81jquery-react-vue-typescript/","excerpt":"","text":"用webpack4.0撸一个单页/多页脚手架工具(支持jquery,react,vue,typescript) 趣谈前端_徐小夕关注 12019.05.09 00:03:04字数 3,487阅读 994 1.导语​ 首先来简单介绍一下webpack：现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个会映射项目所需的每个模块 的依赖图(dependency graph)，并生成一个或多个 bundle。webpack4.0出现之后，我们可以不用再引入一个配置文件来打包项目，并且它仍然有着很高的可配置性，可以很好满足我们的需求。在开始正文之前，首先先来看看我们要实现的成果： 支持ES6+JQuery+Less/Scss的单页/多页脚手架 支持ES6+React+Less/Scss+Typescript的单页/多页脚手架 支持ES6+Vue+Less/Scss+Typescript的单页/多页脚手架 github地址：基于webpack4.0搭建的脚手架（支持react/vue/typescript/es6+/jquery+less/scss) 在脚手架的开发过程中我会详细介绍每个插件或者loader的用途以及webpack的核心理念，如有不懂或者有其他更好的想法欢迎交流。下面是基于该文章的webpack4.0的思维导图： webpack4.png 2.webpack核心概念 入口：指示 webpack 应该使用哪个模块作为入口起点 输出：告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件 loader：让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用 插件：用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量 模式：通过选择 development, production 或 none 之中的一个，来设置 mode 参数，从而进行不同的打包优化 浏览器兼容性：支持所有符合ES5 标准的浏览器（不支持 IE8 及以下版本）下面提供官网的打包模型 &#x77;&#x65;&#98;&#112;&#x61;&#99;&#107;&#64;&#x32;&#x78;&#x2e;&#112;&#x6e;&#103; 3.支持ES6+JQuery+Less/Scss的单页/多页脚手架在实现脚手架之前，假设我们已经创建了目录和package.json文件，接下来先安装webpack相关依赖： 12// 此处建议安装局部依赖，安装全局依赖可能会出现版本问题npm install -D webpack webpack-cli 因为项目要支持es6+,我们还需要安装babel相关依赖： 1npm install -D babel-loader @babel/core @babel/preset-env 这个时候可以开始配置我们的脚手架逻辑了，为了项目结构清晰易于维护，我们建一个build目录专门放webpack构建的脚本，webpack默认的配置文件是webpack.config.js,由于实际项目需要，我们将其拆分为3个文件，分别是webpack通用配置文件webpack.base.js，开发环境配置文件webpack.dev.js以及生产环境配置文件webpack.prod.js。 image.png 我们先处理webpack.common.js文件 123456789101112131415161718192021222324const path = require(&#x27;path&#x27;);const webpack = require(&#x27;webpack&#x27;);module.exports = &#123; entry: &#123; main: &#x27;./src/index.js&#x27;, &#125;, output: &#123; path: path.resolve(__dirname, &#x27;../dist&#x27;), &#125;, module: &#123; rules: [ // 将es6编译成es5 &#123; test: /\\.jsx?$/, // ?表示x有0个或一个 exclude: /node_modules/, // 不编译某个目录下的文件 include: path.resolve(__dirname, &#x27;../src&#x27;), // 只在include包含的目录下进行loader编译 use: [ &quot;babel-loader&quot;, ] &#125;, ] &#125;&#125; 为了项目后期的开发和维护，我们建立好项目结构： image.png public目录是事先准备好的html模版，这里就不介绍了，其他目录可根据具体项目进行设置。 我们还需要一个插件将打包后的文件植入到html模版中并导出到dist目录下，这里使用html-webpack-plugin来实现 1npm install -D html-webpack-plugin 现在webpack.base.js为如下： 12345678910111213141516171819202122232425262728293031const path = require(&#x27;path&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const template = path.resolve(__dirname, &#x27;../public/index.html&#x27;);module.exports = &#123; entry: &#123; main: &#x27;./src/index.js&#x27; &#125;, output: &#123; path: path.resolve(__dirname, &#x27;../dist&#x27;) &#125;, module: &#123; rules: [ // 将es6编译成es5 &#123; test: /\\.jsx?$/, // ?表示x有0个或一个 exclude: /node_modules/, // 不编译某个目录下的文件 include: path.resolve(__dirname, &#x27;../src&#x27;), // 只在include包含的目录下进行loader编译 use: [ &quot;babel-loader&quot;, ] &#125;, ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template, filename: &#x27;index.html&#x27; &#125;) ]&#125; 为了打包项目，我们需要在webpack.prod.js目录下进行配置，此处需要一个模块webpack-merge将wepack基础配置合并进生产配置，我们先来安装一下： 1npm install -D webpack-merge webpack.prod.js配置如下： 12345678910const merge = require(&#x27;webpack-merge&#x27;);const base = require(&#x27;./webpack.base&#x27;);module.exports = merge(&#123; mode: &#x27;production&#x27;, output: &#123; filename: &#x27;js/[name]_[contenthash].js&#x27;, // 入口和内容hash组成的文件名，也可以是hash chunkFilename: &#x27;js/[name]_[contenthash].chunk.js&#x27; &#125;&#125;, base) 然后在package.json里添加执行脚本： 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --config ./build/webpack.prod.js&quot; &#125; webpack默认会找名为webpack.config.js的文件，由于我们将其拆解为prod和dev，所以我们要手动指定webpack执行的文件，添加–config，即可手动指定目录。下面我们开始写一段代码试试吧，在index.js中写入如下es6代码: 123456// index.jslet name = &#x27;xuxi&#x27;;let say = (name) =&gt; &#123; alert(name)&#125;;say(name); 下面我们执行： 1npm run build 此时我们会看见项目中多了一个dist目录，里面的html也植入了相应的代码， image.png 在浏览器中打开： image.png ok,第一步完成。下一步是支持css，我们先安装如下几个模块： 在webpack.base.js中的module中添加如下代码： 123456789101112131415161718module: &#123; rules: [ // 将es6编译成es5 &#123; test: /\\.jsx?$/, // ?表示x有0个或一个 exclude: /node_modules/, // 不编译某个目录下的文件 include: path.resolve(__dirname, &#x27;../src&#x27;), // 只在include包含的目录下进行loader编译 use: [ &quot;babel-loader&quot;, ] &#125;, // 加载css &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], &#125;, ] &#125; 注意，laoder的加载顺序是从下往上，从右往左的，所以配置loader的时候要注意一下顺序。此时在styles目录下加入app.css,在js中引入: 12345678// app.css#root &#123; background-color: #f0c; height: 100px;&#125;// index.jsimport &#x27;./styles/app.css&#x27; 此时打开浏览器，可以看到css生效了： image.png 现在css导入虽然生效了，但是是有js动态创建添加到head里面的，如果后期项目复杂了，将会严重影响项目的加载速度，所以我们这里需要另一个插件，对css进行代码分割，单独生成css文件： 1npm isntall mini-css-extract-plugin -D 根据该插件的官方配置，我们需要把style-loader替换成该插件提供的loader，并配置导出的css文件目录和文件名，为了提高开发环境构建速度，我们只在生产环境分割css： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// webpack.prod.jsconst merge = require(&#x27;webpack-merge&#x27;);const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;);const base = require(&#x27;./webpack.base&#x27;);module.exports = merge(&#123; mode: &#x27;production&#x27;, output: &#123; filename: &#x27;js/[name]_[contenthash].js&#x27;, // 入口和内容hash组成的文件名，也可以是hash chunkFilename: &#x27;js/[name]_[contenthash].chunk.js&#x27; &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ // loader解析的顺序是从下到上，从右到左的顺序 &#123; loader: MiniCssExtractPlugin.loader, options: &#123; filename: &#x27;[name].css&#x27;, chunkFilename: &#x27;[name].css&#x27;, publicPath: &#x27;../&#x27; //****最后打包的时候替换引入文件路径 &#125;, &#125;, // &#x27;style-loader&#x27;, 使用MiniCssExtractPlugin时就不能使用style-loader了 &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 //该方式可以让@import引入的css文件再次执行一边css打包loader &#125; &#125;, ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: &#x27;css/[name]_[hash].css&#x27;, chunkFilename: &#x27;css/[name]_[hash].chunk.css&#x27;, &#125;), ]&#125;, base) 由于我们在dev和prod环境的css-loader不一样，所以我们将base的css-loader配置删除，移到dev下 12345678910111213141516171819202122232425262728// webpack.dev.jsconst base = require(&#x27;./webpack.base&#x27;);const merge = require(&#x27;webpack-merge&#x27;);const webpack = require(&#x27;webpack&#x27;);module.exports = merge(&#123; mode: &#x27;development&#x27;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ // loader解析的顺序是从下到上，从右到左的顺序 &#x27;style-loader&#x27;, //使用MiniCssExtractPlugin时就不能使用style-loader了 &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 //该方式可以让@import引入的css文件再次执行一边css打包loader &#125; &#125;, ] &#125; ] &#125;, output: &#123; filename: &#x27;[name].js&#x27;, chunkFilename: &#x27;[name].js&#x27;, &#125;&#125;, base) ok,此时我们就完成一个基本的打包es6,css的模块打包工具，为了支持更高的es6+语法，我们配置.babelrc文件，以及安装相应的npm包： 1npm install @babel/polyfill core-js -D .babelrc文件如下： 1234567891011&#123; &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, // 将ES6语法转换为es5 &#123; &quot;useBuiltIns&quot;: &quot;usage&quot;, // 只编译需要编译的代码 &quot;corejs&quot;: &quot;3.0.1&quot;, &#125; ], ]&#125; 我们会看到babelrc文件里面有”useBuiltIns”: “usage”, 这个配置涉及到一个关于webpack打包的高级用法，tree-shaking。 tree-shaking:用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的 静态结构 特性，例如 import 和 export。这个术语和概念实际上是由 ES2015 模块打包工具 rollup 普及起来的。 我们通过使用tree-shaking，可以极大的减少代码的体积，对于提高打包性能很有帮助。为了使tree-shaking能生效，我们还要在webpack配置文件中开启： 1234// webpack.base.jsoptimization: &#123; usedExports: true &#125; 还有一个问题，由于tree-shaking是基于import 和export的，当我们用import引入css文件时，是没有导出的，所以我们需要配置忽略css文件的tree-shaking，在package.json中添加如下配置： 12345// package.json&quot;sideEffects&quot;: [ &quot;*.css&quot;, &quot;*.less&quot; ], 在打包的过程中，每次执行打包都会新建一个打包文件，我们想要每次打包之前都清除上一次打包的文件怎么办呢？我们可以使用clean-webpack-plugin来实现，首先先安装，然后具体配置如下： 1234// webpack.prod.jsplugins: [ new CleanWebpackPlugin() ], 该插件会默认清除dist目录下的打包文件。接下来我们安装jquery： 1npm install jquery -S 在index.js引入并使用： 1234import $ from &#x27;jquery&#x27;;import &#x27;./styles/app.css&#x27;console.log($(&#x27;#root&#x27;).html(&#x27;hello world&#x27;)); 执行npm run build后，我们在浏览器中打开，即可看到jq的作用： image.png 但是我们看dist目录下的js文件，发现jquery和业务代码都打包进一个页面了，这样会导致当业务复杂时，整个页面代码会非常大，我们进一步做优化，即js代码分割。根据webpack官网的方案，我们只需要进行简单的配置，便可以进行对js代码分割： 123456789101112131415161718192021222324252627282930//webpack.base.jsoptimization: &#123; splitChunks: &#123; chunks: &#x27;all&#x27;, // chunks: &#x27;async&#x27;, // async表示只对异步代码进行分割 minSize: 30000, // 当超过指定大小时做代码分割 // maxSize: 200000, // 当大于最大尺寸时对代码进行二次分割 minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: &#x27;_&#x27;, name: true, cacheGroups: &#123; // 缓存组：如果满足vendor的条件，就按vender打包，否则按default打包 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10, // 权重越大，打包优先级越高 // filename: &#x27;js/vender.js&#x27; //将代码打包成名为vender.js的文件 name: &#x27;vender&#x27; &#125;, default: &#123; minChunks: 2, priority: -20, name: &#x27;common&#x27;, // filename: &#x27;js/common.js&#x27;, reuseExistingChunk: true // 是否复用已经打包过的代码 &#125; &#125; &#125;, usedExports: true &#125; 由于篇幅限制，splitChunks的具体配置我通过注释写出来了，如果想了解更详细的配置，后面大家可以去webpack官网查看。此时执行npm run build,我们可以看到代码已经进行了分割： image.png 当然只满足与css和js的打包还远远不够，我们项目中还会用到各种图片，字体图标，css预编译语言如less或者scss，由于这部分的安装比较简单，我们直接上代码。首先安装相关依赖： 1npm install url-loader file-loader less less-loader 此时我们webpack.base.js中module变为： 123456789101112131415161718192021222324252627282930313233module: &#123; rules: [ // 将es6编译成es5 &#123; test: /\\.jsx?$/, // ?表示x有0个或一个 exclude: /node_modules/, // 不编译某个目录下的文件 include: path.resolve(__dirname, &#x27;../src&#x27;), // 只在include包含的目录下进行loader编译 use: [ &quot;babel-loader&quot;, ] &#125;, // 加载解析文件资源 &#123; test: /\\.(jpg|png|gif)$/, use: &#123; loader: &#x27;url-loader&#x27;, // 和file-loader功能相同，但更智能 options: &#123; // 配置打包后的文件名,具体可看webpack的file-loader文档 name: &#x27;[name].[ext]?[hash]&#x27;, outputPath: &#x27;images/&#x27;, limit: 4096 // 当图片大小大于4k时将以文件形式输出，否则以base64输出 &#125; &#125; &#125;, // 引入字体，svg等文件 &#123; test: /\\.(eot|ttf|svg)$/, use: &#123; loader: &#x27;file-loader&#x27; &#125; &#125; ] &#125;, 为了支持less，我们修改一下dev和prod文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// webpack.dev.jsmodule: &#123; rules: [ &#123; test: /\\.(css|less)$/, use: [ // loader解析的顺序是从下到上，从右到左的顺序 &#x27;style-loader&#x27;, //使用MiniCssExtractPlugin时就不能使用style-loader了 &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 //该方式可以让@import引入的css文件再次执行一边css打包loader &#125; &#125;, &#x27;less-loader&#x27;, ] &#125; ] &#125;// webpack.prod.jsmodule: &#123; rules: [ &#123; test: /\\.(css|less)$/, use: [ // loader解析的顺序是从下到上，从右到左的顺序 &#123; loader: MiniCssExtractPlugin.loader, options: &#123; filename: &#x27;[name].css&#x27;, chunkFilename: &#x27;[name].css&#x27;, publicPath: &#x27;../&#x27; //****最后打包的时候替换引入文件路径 &#125;, &#125;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 //该方式可以让@import引入的css文件再次执行一边css打包loader &#125; &#125;, &#x27;less-loader&#x27; ] &#125; ] &#125; 我们写一段less代码试试： 123456body &#123; #root &#123; background-color: #000; color: #fff; &#125;&#125; 我们执行build之后在浏览器打开看看效果： image.png ok，至此，我们第一步也是最重要的一步已经完成了，由于开发项目的时候不可能每次改动代码都构建一次，这样时间成本太大了，我们想要实时看到改变的内容，这个时候就要用webpack4.0提供的devServer了，它使得我们项目可以支持热更新和热模块替换，我们需要在开发环境下对其进行配置，具体如下：首先安装开发服务器模块： 1npm install webpack-dev-server -D 接着配置dev文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758webpack.dev.jsconst base = require(&#x27;./webpack.base&#x27;);const merge = require(&#x27;webpack-merge&#x27;);const webpack = require(&#x27;webpack&#x27;);module.exports = merge(&#123; mode: &#x27;development&#x27;, module: &#123; rules: [ &#123; test: /\\.(css|less)$/, use: [ // loader解析的顺序是从下到上，从右到左的顺序 &#x27;style-loader&#x27;, //使用MiniCssExtractPlugin时就不能使用style-loader了 &#x27;vue-style-loader&#x27;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 //该方式可以让@import引入的css文件再次执行一边css打包loader &#125; &#125;, // &#x27;sass-loader&#x27;, &#x27;less-loader&#x27;, &#x27;postcss-loader&#x27;, ] &#125; ] &#125;, // 服务器配置 devServer: &#123; port: &#x27;8081&#x27;, // 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html historyApiFallback: true, // 解决单页面路由问题， contentBase: &#x27;../dist&#x27;, open: true, //自动打开浏览器 hot: true, // 开启热替换, css代码跟新不刷新页面 // hotOnly: true 开启后只有手动配置才能更新，即使hot为true也不刷新浏览器 proxy: &#123; index: &#x27;&#x27;, // 将index设置为空，可以对根路径进行转发 &#x27;api/get&#x27;: &#x27;xxxx.com/api&#x27;, // 第一种方式，直接代理到api路径 &#x27;api/vue&#x27;: &#123; // 第二种方式，在路径需要临时替换时使用 target: &#x27;xxxx.com/api&#x27;, pathRewrite: &#123; &#x27;head&#x27;: &#x27;demo&#x27; //此时访问head路径将被代理到demo下 &#125;, secure: false, //对https请求的配置，false为支持https changeOrigin: true //做代理分发时允许访问其他网站，突破网站限制，建议在开发环境使用 &#125;, &#125; &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ], output: &#123; filename: &#x27;[name].js&#x27;, chunkFilename: &#x27;[name].js&#x27;, &#125;&#125;, base) 以上代码中，要使用热模块替换，我们需要用到webpack自己集成的插件webpack.HotModuleReplacementPlugin，在devServer中，我们还可以设置开发环境中的代理proxy，这已经是目前开发的默认模式了，代码中一些属性的用法和含义我都做了注释，如果大家有兴趣，可以查看webpack原版官方文档，那里有更详细的配置信息。我们再来修改package.json,添加开发环境的运行指令： 12// 在script里面添加&quot;start&quot;: &quot;webpack-dev-server --config ./build/webpack.dev.js&quot;, 我们执行 npm start，此时会自动打开浏览器，运行我们的项目。 到此，我们基本的一个支持ES6+Less/css+JQuery的单页应用打包工具已经做好了，当然这只是基础，后面的多页应用，vue/react/typescript都是在这个基础上构建的，让我们拭目以待。 多页面应用：我们开发多页面应用还是需要用到之前使用的html-webpack-plugin插件，此时我们需要定义多个入口： 123456789101112131415161718192021222324// webpack.base.jsentry: &#123; main: &#x27;./src/index.js&#x27;, about: &#x27;./src/about.js&#x27; &#125;plugins: [new HtmlWebpackPlugin( &#123; template, title: &#x27;webpack打包但单应用&#x27;, chunks: [&#x27;vender&#x27;, &#x27;main&#x27;]， filename: &#x27;index.html&#x27; &#125; ), new HtmlWebpackPlugin( &#123; template, title: &#x27;关于我们&#x27;, chunks: [&#x27;vender&#x27;, &#x27;about&#x27;]， filename: &#x27;about.html&#x27; &#125; ),] template是我们定义的public下的html路径，title是我们要植入html模版中的titl标签中的内容，我们在index.html中这么使用： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;./favicon.ico&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ​ 这样，webpack配置的title就可以动态的添加到html页面中了，这里我要说一下在new HtmlWebpackPlugin中我们添加了chunks数组，这个数组就是我们要打包进页面的js，main和about分别代表入口的名字，vender就是我们定义optimization时里面cacheGroups属性值中vendors中定义的name,当代码超过30000b时就会生成vender.js文件。​ 此时我们执行npm run build，打包结束后将会生成2个html页面，对应的文件依赖也会引入，在浏览器中打开，亲测有效～ image.png 这样，一个基本的多页面打包工具就开发完成了，不过还有几点优化： 代码压缩， 第三方模块懒编译，我们可以使用webpack提供的dll技术做优化 pwa技术引入下面分别是相关实现：1.代码压缩，我们使用terser-webpack-plugin压缩js，用optimize-css-assets-webpack-plugin压缩css 1npm install terser-webpack-plugin optimize-css-assets-webpack-plugin -D 我们在webpack.prod.js中添加一下配置： 1234567891011121314151617181920// 导入模块// 压缩cssconst OptimizeCSSAssetsPlugin = require(&#x27;optimize-css-assets-webpack-plugin&#x27;);// 压缩jsconst TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;);// 配置module.exports,添加配置如下optimization: &#123; minimizer: [ new TerserPlugin(&#123; // 压缩js代码 cache: true, // 启用文件缓存 parallel: true, // 使用多进程并行执行任务来提高构建效率 sourceMap: true, // 将错误消息位置映射到模块 terserOptions: &#123; drop_console: true, // 打包时剔除所有console.log drop_debugger: true // 打包时剔除所有debugger &#125; &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;)] // 压缩css代码 &#125;, pwa：渐进式网络应用程序(progressive web application - PWA)，是一种可以提供类似于native app(原生应用程序) 体验的 web app(网络应用程序)。首先我们安装依赖： 1npm install workbox-webpack-plugin --save-dev 在需要做pwa的页面里加入如下脚本启动： 12345678if (&#x27;serviceWorker&#x27; in navigator) &#123; window.addEventListener(&#x27;load&#x27;, () =&gt; &#123; navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;).then(registration =&gt; &#123; console.log(&#x27;SW registered: &#x27;, registration); &#125;).catch(registrationError =&gt; &#123; console.log(&#x27;SW registration failed: &#x27;, registrationError); &#125;); &#125;); &#125; dll文件优化打包速度关于dll问题，我们可以在官网上查询具体的使用方法，这里就不具体说明了。 至此，我们关于开发基于ES6+JQuery+Less/Scss的单页/多页脚手架就告于段落了，下面我们来集成对react/vue/typescript的支持。 1.支持react我们首先安装一个babel模块： 1npm install --save-dev @babel/preset-react 然后在.babelrc中加入如下配置： 123456789101112&#123; &quot;presets&quot;: [ [ &quot;@babel/preset-react&quot;, &#123; &quot;pragma&quot;: &quot;dom&quot;, // default pragma is React.createElement &quot;pragmaFrag&quot;: &quot;DomFrag&quot;, // default is React.Fragment &quot;throwIfNamespace&quot;: false // defaults to true &#125; ] ]&#125; 然后在index.js中写入一段react代码： 12345678910import React, &#123;Component&#125; from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;class App extends Component &#123; render() &#123; return &lt;div&gt;react frame content.&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)); 打包后即可在浏览器中看到效果。 2.支持vue首先先安装对应npm包： 1npm install -D vue-loader vue-template-compiler 之后在webpack的配置文件中写入如下代码： 123456789101112131415161718// webpack.base.jsconst VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;)module.exports = &#123; module: &#123; rules: [ // ... other rules &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27; &#125; ] &#125;, plugins: [ // make sure to include the plugin! new VueLoaderPlugin() ]&#125; 如果要想解析.vue文件中的style，我们需要使用vue-style-loader模块，安装之后将其添加到loder中即可。接下来我们写个简单的vue试一下吧： 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;example&quot;&gt; &#123;&#123; msg &#125;&#125; &lt;img src=&quot;~/images/logo.png&quot; /&gt; &lt;img :src=&quot;imgSrc&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Logo from &#x27;images/logo.png&#x27;;import &#x27;css/common.css&#x27;;export default &#123; data () &#123; return &#123; msg: &#x27;Hello world!单独的&#x27;, imgSrc: Logo &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;.example &#123; color: red; img &#123; border: 2px solid #000; &#125;&#125;&lt;/style&gt; 运行dev在浏览器中即可看到效果。值得注意的是vue文件中引入资源的问题，使用相对路径会有问题，这里我们可以使用~/images/logo.png的方式或者require的方式来引入图片。 3.支持typescript这里我们使用awesome-typescript-loader来编译typescript文件，也是官方推荐的一个加载器： 1npm install awesome-typescript-loader --save-dev 然后我们在webpack的配置文件base中，在module的rules里加入如下代码： 1234&#123; test: /\\.tsx?$/, loader: &#x27;awesome-typescript-loader&#x27; &#125; 最后一步，添加tsconfig.json文件： 123456789&#123; &quot;compilerOptions&quot;: &#123; &quot;noImplicitAny&quot;: true, &quot;removeComments&quot;: true &#125;, &quot;awesomeTypescriptLoaderOptions&quot;: &#123; /* ... */ &#125;&#125; 该文件有很多灵活的配置项，大家如果想了解更多可以去typescript官网上查看相关文档。至此，所有的配置都完成了，是不是很累？哈哈，当然脚手架中还存在一些优化的地方，欢迎大家可以一起完善。 未完成的优化点： vue文件内部style无法独立抽出样式，只能通过引入css文件的方式加载样式 公用css文件问题：多页面打包时，如果都引入了同一个css，无法服用这个css，希望能将这个css文件作为一个公共模块单独引用 相关推荐： vue高级进阶系列——用typescript玩转vue和vuex 三年前端，我觉得最有价值的5本书 vue高级进阶系列——用typescript玩转vue和vuex 我们为什么要拥抱React Hook","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://1314xulujin.github.io/tags/webpack/"}]},{"title":"一年半经验如何准备阿里巴巴前端面试","slug":"一年半经验如何准备阿里巴巴前端面试","date":"2020-04-27T05:10:02.000Z","updated":"2021-01-06T09:53:17.881Z","comments":true,"path":"2020/04/27/一年半经验如何准备阿里巴巴前端面试/","link":"","permalink":"https://1314xulujin.github.io/2020/04/27/%E4%B8%80%E5%B9%B4%E5%8D%8A%E7%BB%8F%E9%AA%8C%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/","excerpt":"","text":"axuebin 关注 一年半经验如何准备阿里巴巴前端面试本文想分享的是如何准备阿里面试的以及面试过程的所想所得，希望能帮到你。 首先，可能要让你们失望的是，这篇文章不会有大篇幅的面试题答案。如果想要看这方面的内容，我相信社区里已经有很多优秀的文章了。 0. 招人！！！最重要的事当然要放在第一位。 我们是阿里巴巴的AE技术部-无线技术&amp;会员导购-体验技术部，国际化大场景，欢迎来挑战！ 我们这，则是主要做小程序/工程化等基础建设方面的一些事情，当然，也有业务相关的事情要做，现在有 P6 及以上的 HC，如果感兴趣的可以来试试~ 0.1 业务/部门介绍作为阿里国际化进程中的核心技术力量，负责全球B端，C端业务前端技术，关注全球用户体验，赋能业务提供更好的买卖家服务，目前服务200+国家，拥有数十个研发平台，包含AE，lazada, 天猫国际等多个全球化链路，我们包含国际化最全的前端技术分类，技术空间全面且广大，包含搭投中台，导购中台，国际化小程序，国际B端解决方案，国际C端解决方案，国际化业务已成为集团的核心战略。 0.2 岗位职责 参与跨平台的应用开发，包括 Web, Mobile Web, 及跨端技术，负责产出高质量的技术产品； 充分理解产品和设计需求，负责AliExpress WWW Site &amp; Mobile Site的产品化过程的落地和实施； 学习研究业界的前沿技术，并迅速转化到未来潜在的业务或技术项目中； 与团队成员分享项目经验和业界新技术的应用，和团队一同成长。 0.3 岗位要求 精通HTML、CSS、Javascript，热衷浏览各类网页的源代码； 熟练掌握Java、NodeJS、Python等任意一种或多种后端语言，并有实际的项目经验； 深谙 MV* 模式，熟悉AMP、AngularJs、ReactJS、VueJS、Polymer等任意一种前端 UI 框架，一定程度了解其原理； 熟悉主流浏览器特性，乐于探究和解决各种类型的兼容性问题； 英语能流畅沟通者优先。 0.4 简历投递除了前端之外，客户端/Java/测试也有 HC，欢迎大家的加入 ~ 简历发送至 &#x6a;&#x6f;&#x62;&#64;&#x61;&#120;&#117;&#x65;&#98;&#x69;&#x6e;&#x2e;&#x63;&#111;&#109; 即可，可以在邮件正文中留一个你的微信，如果觉得简历合适，我会加你微信，面试过程中会积极跟进你的状态，随时有问题都可以来找我 ~ 目前机会比较好，流程也走得比较快，走过路过不要错过 ~ 1 关于简历我对于简历的理解是这样的，简历的作用是让看简历的人能够快速、准确地捕捉到有用信息： 你是谁 你做了什么 你哪方面比较牛逼 我觉得只要能展示出这三点，就够了。 1.1 内容我的简历主要是包含了以下几个模块： 基本资料：姓名、电话、邮箱、个人网站（GitHub） 工作经历：公司名、在职时间、工作内容（简述负责、参与什么业务） 项目经历：最重要的一点没有之一！展开描述 专业技能：加分项还是减分项都有可能，慎重对待，展开描述 教育经历：学校名、就读时间 其它：简单描述任何你想让面试官知道的东西，比如社区影响力： GitHub 1000000 Star、掘金 Lv9 等等 1.1.1 项目经历项目经历对于开发来说是一份简历最重要的部分！ 项目经历对于开发来说是一份简历最重要的部分！ 项目经历对于开发来说是一份简历最重要的部分！ 既然是最重要的，选择困难症选手可能就犯难了，怎么样的项目应该被宠幸，写在简历上呢？ 1. 自己做的 这点不用多说，一定得是自己做的项目，别看着别人项目牛逼，就拿来吹，面试和背调环节都可能穿帮的。 2. 很熟悉的 对于这个项目，你必须在业务和技术实现上都了如指掌： 业务上：这个项目的业务背景是什么，在业务上有什么比较牛逼的地方，推动了业务如何运行等等 技术实现上：这个项目的整体技术实现思路是怎样的，项目中用了什么比较牛逼的技术，解决了什么比较困难的问题等等 千万千万不能有这个想法：项目中有一个很牛逼的东西，但是不是你写的，你也完全不了解，但是就想写进项目里。 3. 有亮点的 好看的皮囊千篇一律，有趣的灵魂万里挑一 面试官比较在意的还是这个项目表面上看不到并且很有趣的东西。业务，技术都可。 这个项目做了什么牛逼的事情 你在项目里做了什么牛逼的事情 用了什么牛逼的技术解决了什么困难的问题 … 总结：项目经历一定是面试官比较关心的部分，面试中一定会细问的，所以不要啰嗦，挑牛逼的、有意思的东西写，并且自己能讲明白的。 1.1.2 专业技能专业技能这一块很多人会写这样写：精通 HTML/CSS/JavaScript 等等，而且写得特别多，恨不得把自己用过的东西都写在这… 个人建议这里不要写太多东西，可以写一些在项目经历里没提到的东西，比如： 我的项目经历主要是 Vue 业务开发为主，我在这里写的是 TypeScript/React/工程化/Node/MySQL 相关的，让面试官更全面的了解你。 如果面试官感兴趣，会挑几个技术栈问你几个问题，如果答的也很棒，必须是妥妥的加分项。 当然，在这里写的技术栈都必须是你了解或者掌握的，否则被随便问两个问题就不会了，就变成减分项了。 总结：专业技能也请慎重对待，有可能是你的加分项，也有可能是你的减分项。 1.2 样式如果是一份开发工作的简历，没必要花里胡哨的模板，只要简简单单的白纸黑字即可。 个人认为，除了排版上要稍微注意下之外，比较重要的有两点： 页数一页即可。将你最牛逼的东西写出来就好了 留白。适当的留白会让简历看上去很舒服，也利于阅读的人捕捉重点 1.3 总结简历，顾名思义，是你的情况的一份简要介绍，对于面试官而言，他最初只能通过这一张纸来了解你。 所以，无论在内容、表现上都需要你细心准备并且打磨的，望认真对待。 2. 关于复习大多数人应该都和我一样，是在职准备面试的，每天可用的时间大多数集中在晚上（22:00 - 24:00）。想想也挺好的，晚上的时间比较容易集中注意力。 个人觉得，复习主要是需要制定计划，切记不能三天打鱼两天晒网。 忌零散阅读，宜系统复习。 准备面试的时候，可以按照以下几个模块来准备： 无论前端技术栈日新月异，我们都得要扎实基础，脚踏实地，切记不可投机取巧、眼高手低。 2.1 JavaScript 基础JavaScript 基础非常重要，相比于大同小异的框架面试题，JavaScript 可以问很多东西，而且细问起来也有很多有意思东西，如果时间充足可以系统地过一遍。（现实往往是没时间…） 执行上下文/作用域链/闭包 this/call/apply/bind 原型/继承 Promise 深浅拷贝 事件机制/Event Loop 函数式编程 service worker/web worker 常用方法 … 2.2 CSS 基础 position 行内元素/块状元素 flex 1px 重绘回流 Sass/Less 居中/常见布局 层叠上下文 … 2.3 框架这一块主要是关注 Vue 和 React 的共性和特性，侧重 Vue（我工作中是主 Vue），过程中看了一些源码，加深理解。 MVVM 生命周期 数据绑定 状态管理 组件通信 computed/watch 原理 Virtual DOM diff React Hook React Hoc/Vue mixin Vue 和 React 有什么不同 … 2.4 工程化对于写业务的同学来说，之前可能没有大规模接触过工程化的东西，不过这并不影响我们可以自己去学习和了解。 webpack babel 模板引擎 前端发布 weex … 2.6 性能优化性能优化是必备技能，必须了解。 打包优化 网络优化 代码优化 … 2.7 TypeScriptTypeScript 不敢写自己深入，只是了解，所以只是复习了一些基础的知识点和比较简单的问题，比如：JavaScript 和 TypeScript 有什么区别，在进行项目选型时，什么因素会让你选择 TypeScript 等。 2.8 网络/浏览器对于前端开发来说，网络和浏览器也属于必须了解的知识点。 HTTP DNS TCP HTTPS CDN … 经典问题，从输入 URL 到页面展示，发生了什么。这个问题我觉得还是很考验广度和深度的，可以好好思考一下，每个人可能回答的结果都会是不一样的。 2.9 计算机基础 设计模式 数据结构 基础算法 安全 … 2.10 NodeNode 我的了解并不太多，所以没有特意去准备。 2.11 项目/业务简历上写的项目，仔细认真的过一遍。还有就是关于业务的一些深层次的东西，得好好思考一下。 2.12 其它一些开放性问题还是需要好好思考一下，顺便也准备一下 HR 面可能会问到的一些问题。 2.13 总结在复习某个部分时可能会引出其它知识点，如果也不是很清楚的话也需要系统的再复习一下。 前端知识体系比较广并且发展迅速，我们一定要铭记：基础才是最重要的。 如果想要获取完整的复习导图（一些重要问题以及真实面试后的补充点），可以关注公众号 axuebin，回复「面试」两字获取。 ![img](data:image/svg+xml;utf8,) 这里列出的应该也不是很全，欢迎补充，可以在公众号发送留言。 3. 关于面试投简历之前也在网上搜了一下阿里 P6 面试的相关文章，感觉流程也大同小异。亲身经历之后，在这里解答几个可能是你们在准备阿里 P6 这个级别的面试时比较关心的问题。 3.1 阿里 P6 的标准是什么？这个问题没有标准答案，你觉得自己的技术和业务水平过得去，就可以来试一下。 3.2 学历、学校、工作经验有什么要求？没有。 3.3 有几轮面试？需要笔试吗？一般来说面试分为技术面 + HR 面。 技术面一般有 4 ~ 5 轮左右。 可能会有笔试。笔试一般在一面的时候，如果面试官觉得需要有笔试来考察一下，就会进入笔试环节。 3.4 面试形式是什么样的？阿里的面试效率现在非常高，技术面试一般会以远程面试为主（电话 + 视频），笔试是通过线上 Coding 来完成的。 面试官或者 HR 会提前联系你约面试时间，耐心等待。 这里说一下，约了面试时间后，面试官突然说有急事，要改时间。不要瞎想，是真的有事情，耐心等待就好。 如果顺利通过前几面，最终会约在现场进行终面。 3.5 每一面之后会知道自己是否通过吗？ 有的面试官会在面试结束告诉你是否通过 你可能会加到面试官微信，可以直接询问 如果有 HR 联系方式，也可以询问 HR 内推人可以看到是否通过（比如找我内推，我会很乐意帮你跟进面试流程） 建议每一面结束之后不要多想，就和考研一样，考完一科就安心复习下一科，适当的时候可以问一下进度。 3.6 对于技术栈有要求吗？我听说阿里是 React，而我主要是用 Vue 的没有要求。平时用什么技术栈不重要，重要的是理解原理。 3.7 总结这里列到的也只是写文章的时候想起来的一些问题，如果还有其它疑问，可以在公众号留言，如果我可以回答我都会回复的。 4. 写在最后今年应该还会好好沉淀一下技术，写一些文章，如果感兴趣的可以关注一下公众号「前端试炼」。 喜欢玩摄影的也可以关注起来，偶尔可能还有一些关于摄影的东西分享给大家 ~ 我们招人哦，要求在最上面~","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"window10专业版命令行快速激活教程","slug":"window10专业版命令行快速激活教程","date":"2020-04-25T11:56:56.000Z","updated":"2020-06-21T13:10:21.322Z","comments":true,"path":"2020/04/25/window10专业版命令行快速激活教程/","link":"","permalink":"https://1314xulujin.github.io/2020/04/25/window10%E4%B8%93%E4%B8%9A%E7%89%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E9%80%9F%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/","excerpt":"","text":"window10专业版命令行快速激活教程1. 在window10搜索cmd命令行，以管理员身份运行。2. 输入：slmgr.vbs /upk （意思是卸载当前产品密钥）3. 输入: slmgr /ipk TX9XD-98N7V-6WMQ6-BX7FG-H8Q99 (安装密钥)4.输入： slmgr /skms zh.us.to (设置计算机名称为zh.us.to)5.激活： slmgr /ato (成功激活)优点：快，方便；缺点：只能激活180天，到期自己再搞一遍，部分机型只能激活45天，不怕麻烦可以搞，我也觉得不麻烦；","categories":[],"tags":[{"name":"window10","slug":"window10","permalink":"https://1314xulujin.github.io/tags/window10/"}]},{"title":"Vant-weapp框架","slug":"vant_weapp(微信小程序UI框架)","date":"2020-04-21T00:48:05.000Z","updated":"2020-06-21T13:10:21.282Z","comments":true,"path":"2020/04/21/vant_weapp(微信小程序UI框架)/","link":"","permalink":"https://1314xulujin.github.io/2020/04/21/vant_weapp(%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FUI%E6%A1%86%E6%9E%B6)/","excerpt":"","text":"介绍Vant Weapp 是移动端 Vue 组件库 Vant 的小程序版本，两者基于相同的视觉规范，提供一致的 API 接口，助力开发者快速搭建小程序应用。 预览扫描下方小程序二维码，体验组件库示例： 快速上手请参考 快速上手 安装步骤一 通过 npm 安装需要注意的是 package.json 和 node_modules 必须在 miniprogram 目录下 12345678# 通过 npm 安装npm i @vant/weapp -S --production# 通过 yarn 安装yarn add @vant/weapp --production# 安装 0.x 版本npm i vant-weapp -S --production 步骤二 构建 npm 包打开微信开发者工具，点击 工具 -&gt; 构建 npm，并勾选 使用 npm 模块 选项，构建完成后，即可引入组件 步骤四 修改 app.json将 app.json 中的 &quot;style&quot;: &quot;v2&quot; 去除，小程序的新版基础组件强行加上了许多样式，难以去除，不关闭将造成部分组件样式混乱。 使用引入组件以 Button 组件为例，只需要在app.json或index.json中配置 Button 对应的路径即可。如果你是通过下载源代码的方式使用 @vant/weapp，请将路径修改为项目中 @vant/weapp 所在的目录。 123456789101112131415// 通过 npm 安装// app.json&quot;usingComponents&quot;: &#123; &quot;van-button&quot;: &quot;@vant/weapp/button/index&quot;&#125;// 通过下载源码使用 es6版本// app.json&quot;usingComponents&quot;: &#123; &quot;van-button&quot;: &quot;path/to/@vant/weapp/dist/button/index&quot;&#125;// 通过下载源码使用 es5版本// app.json&quot;usingComponents&quot;: &#123; &quot;van-button&quot;: &quot;path/to/@vant/weapp/lib/button/index&quot;&#125; Vant_weapp在app.json里面的所有组件配置参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&quot;usingComponents&quot;: &#123; &quot;van-button&quot;: &quot;@vant/weapp/button/index&quot;, &quot;van-cell&quot;: &quot;@vant/weapp/cell/index&quot;, &quot;van-cell-group&quot;: &quot;@vant/weapp/cell-group/index&quot;, &quot;van-icon&quot;: &quot;@vant/weapp/icon/index&quot;, &quot;van-image&quot;: &quot;@vant/weapp/image/index&quot;, &quot;van-row&quot;: &quot;@vant/weapp/row/index&quot;, &quot;van-col&quot;: &quot;@vant/weapp/col/index&quot;, &quot;van-popup&quot;: &quot;@vant/weapp/popup/index&quot;, &quot;van-transition&quot;: &quot;@vant/weapp/transition/index&quot;, &quot;van-calendar&quot;: &quot;@vant/weapp/calendar/index&quot;, &quot;van-checkbox&quot;: &quot;@vant/weapp/checkbox/index&quot;, &quot;van-checkbox-group&quot;: &quot;@vant/weapp/checkbox-group/index&quot;, &quot;van-datetime-picker&quot;: &quot;@vant/weapp/datetime-picker/index&quot;, &quot;van-field&quot;: &quot;@vant/weapp/field/index&quot;, &quot;van-picker&quot;: &quot;@vant/weapp/picker/index&quot;, &quot;van-radio&quot;: &quot;@vant/weapp/radio/index&quot;, &quot;van-radio-group&quot;: &quot;@vant/weapp/radio-group/index&quot;, &quot;van-rate&quot;: &quot;@vant/weapp/rate/index&quot;, &quot;van-search&quot;: &quot;@vant/weapp/search/index&quot;, &quot;van-slider&quot;: &quot;@vant/weapp/slider/index&quot;, &quot;van-stepper&quot;: &quot;@vant/weapp/stepper/index&quot;, &quot;van-switch&quot;: &quot;@vant/weapp/switch/index&quot;, &quot;van-uploader&quot;: &quot;@vant/weapp/uploader/index&quot;, &quot;van-action-sheet&quot;: &quot;@vant/weapp/action-sheet/index&quot;, &quot;van-dialog&quot;: &quot;@vant/weapp/dialog/index&quot;, &quot;van-dropdown-menu&quot;: &quot;@vant/weapp/dropdown-menu/index&quot;, &quot;van-dropdown-item&quot;: &quot;@vant/weapp/dropdown-item/index&quot;, &quot;van-loading&quot;: &quot;@vant/weapp/loading/index&quot;, &quot;van-notify&quot;: &quot;@vant/weapp/notify/index&quot;, &quot;van-overlay&quot;: &quot;@vant/weapp/overlay/index&quot;, &quot;van-swipe-cell&quot;: &quot;@vant/weapp/swipe-cell/index&quot;, &quot;van-toast&quot;: &quot;@vant/weapp/toast/index&quot;, &quot;van-circle&quot;: &quot;@vant/weapp/circle/index&quot;, &quot;van-collapse&quot;: &quot;@vant/weapp/collapse/index&quot;, &quot;van-collapse-item&quot;: &quot;@vant/weapp/collapse-item/index&quot;, &quot;van-count-down&quot;: &quot;@vant/weapp/count-down/index&quot;, &quot;van-divider&quot;: &quot;@vant/weapp/divider/index&quot;, &quot;van-notice-bar&quot;: &quot;@vant/weapp/notice-bar/index&quot;, &quot;van-panel&quot;: &quot;@vant/weapp/panel/index&quot;, &quot;van-progress&quot;: &quot;@vant/weapp/progress/index&quot;, &quot;van-skeleton&quot;: &quot;@vant/weapp/skeleton/index&quot;, &quot;van-steps&quot;: &quot;@vant/weapp/steps/index&quot;, &quot;van-sticky&quot;: &quot;@vant/weapp/sticky/index&quot;, &quot;van-tag&quot;: &quot;@vant/weapp/tag/index&quot;, &quot;van-tree-select&quot;: &quot;@vant/weapp/tree-select/index&quot;, &quot;van-grid&quot;: &quot;@vant/weapp/grid/index&quot;, &quot;van-grid-item&quot;: &quot;@vant/weapp/grid-item/index&quot;, &quot;van-index-bar&quot;: &quot;@vant/weapp/index-bar/index&quot;, &quot;van-index-anchor&quot;: &quot;@vant/weapp/index-anchor/index&quot;, &quot;van-sidebar&quot;: &quot;@vant/weapp/sidebar/index&quot;, &quot;van-sidebar-item&quot;: &quot;@vant/weapp/sidebar-item/index&quot;, &quot;van-nav-bar&quot;: &quot;@vant/weapp/nav-bar/index&quot;, &quot;van-tab&quot;: &quot;@vant/weapp/tab/index&quot;, &quot;van-tabs&quot;: &quot;@vant/weapp/tabs/index&quot;, &quot;van-tabbar&quot;: &quot;@vant/weapp/tabbar/index&quot;, &quot;van-tabbar-item&quot;: &quot;@vant/weapp/tabbar-item/index&quot;, &quot;van-area&quot;: &quot;@vant/weapp/area/index&quot;, &quot;van-card&quot;: &quot;@vant/weapp/card/index&quot;, &quot;van-submit-bar&quot;: &quot;@vant/weapp/submit-bar/index&quot;, &quot;van-goods-action&quot;: &quot;@vant/weapp/goods-action/index&quot;, &quot;van-goods-action-icon&quot;: &quot;@vant/weapp/goods-action-icon/index&quot;, &quot;van-goods-action-button&quot;: &quot;@vant/weapp/goods-action-button/index&quot; &#125; 详情和使用的其他方法见Vant-weapp官方开发文档","categories":[],"tags":[{"name":"微信小程序UI框架","slug":"微信小程序UI框架","permalink":"https://1314xulujin.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FUI%E6%A1%86%E6%9E%B6/"}]},{"title":"面试经历 ~ （腾讯）外包岗","slug":"2020年0317腾讯面试所问到的问题","date":"2020-03-17T06:10:05.000Z","updated":"2020-06-21T13:10:21.220Z","comments":true,"path":"2020/03/17/2020年0317腾讯面试所问到的问题/","link":"","permalink":"https://1314xulujin.github.io/2020/03/17/2020%E5%B9%B40317%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E6%89%80%E9%97%AE%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"面试经历 ~ （腾讯）外包岗 面试地点：深圳南山区飞亚达科技大厦面试时间：2020年03月17日 14:30面试时长：23分06秒面试方式：电话面试面试内容：1.自我介绍2.技术面试​ ①前一家公司简介 ​ ②项目经验（每次你说一个项目他会问项目上线没） ​ ③面试问题（面试题） Ⅰ.自适应布局和响应布局的区别，你对自适应布局和响应式布局的理解。​ 答：响应式布局就是实现不同屏幕分辨率的终端上浏览网页的不同展示方式。通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验。换句话说就是一个网站能够兼容多个终端，而不是为了每一个终端做一个特定的版本。 ​ 自适应布局就是指能忘了使网页自适应的显示在不同大小终端设备上的新网页设计方式及技术，它需要开发多套界面来适应不同的终端。 ​ 区别 （1）自适应布局通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，从而请求服务层，返回不同的页面；响应式布局通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。 （2）自适应布局需要开发多套界面，而响应式布局只需要开发一套界面就可以了 （3）自适应对页面做的屏幕适配是在一定范围：比如pc端一般要大于1024像素，手机端要小于768像素。而响应式布局是一套页面全部适应 （4）自适应布局如果屏幕太小会发生内容过于拥挤。而响应式布局正是为了解决这个问题而衍生出的概念，它可以自动识别屏幕宽度并做出相应调整的网页设计 总之，响应式布局还是要比自适应布局要好一点，但是自适应布局更加贴切实际，因为你只需要考虑几种状态就可以了而不是像响应式布局需要考虑非常多状态。所以的说无论哪种设计都有它们各自的特点，我们要根据项目的需求来选择适合的布局方式 Ⅱ.flex布局(弹性布局)，一般面试官会比喻出一个布局的场景，会问你用到哪个样式及其属性可以实现这个布局场景。​ 答：答案不唯一，面试官会问任何一个场景，需要对flex布局属性熟悉，能说出来。 Ⅲ.常见的跨域有哪些，这些跨域是怎么实现的，步骤是什么样的？​ 答：常见的跨域有jsonp，cors，iframe等(一般会问个冷门的跨域怎么实现)。 ​ iframe跨域的实现步骤（解决iframe跨域）： ​ 设置domain ​ document.domain作用是获取/设置当前文档的原始域部分，同源策略会判断两个文档的原始域是否相同来判断是否跨域。这意味着只要把这个值设置成一样就可以解决跨域问题了。 在此我将domain设置为一级域名的值，a页面url为a.demo.com，a页面中iframe引用的b页面url为b.demo.com，具体设置为 1document.domain &#x3D; &#39;demo.com&#39; ​ 设置完之后，在a页面的window上挂载使iframe全屏的方法 1234&#x2F;&#x2F; a页面window.toggleFullScreen &#x3D; () &#x3D;&gt; &#123; &#96;&#96;&#x2F;&#x2F; do something&#125; ​ 在b页面上可以直接获取到a页面的window对象并直接调用 1&#x2F;&#x2F; b页面&#96;&#96;window.parent.toggleFullScreen() ​ 使用中间页面 ​ 我们还可以使用一个与a页面同域名但不同路由的c页面作为中间页面，b页面加载c页面，c页面调用a页面的方法，从而实现b页面调用a页面的方法。 在a页面的node层新开一个路由，此路由加载一个c页面作为中间页面，c页面的url为a.demo.com/c。c页面只是一个简单的html页面，在window的onload事件上调用了a页面的方法。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;script&gt; window.onload &#x3D; function () &#123; parent.parent.toggleFullScreen(); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; ​ postmessage ​ window.postMessage方法可以安全地实现跨源通信，写明目标窗口的协议、主机地址或端口就可以发信息给它， 为了安全，收到信息后要检测下event.origin判断是否要收信息的窗口发过来的。 12345&#x2F;&#x2F; a页面window.addEventListener(&quot;message&quot;, function( event ) &#123; if (event.origin !&#x3D;&#x3D; &#39;http:&#x2F;&#x2F;b.demo.com&#39;) return; toggleFullScreen() &#125;); 12345&#x2F;&#x2F; a页面window.addEventListener(&#96;&#96;&quot;message&quot;&#96;&#96;, &#96;&#96;function&#96;&#96;( event ) &#123; &#96;&#96;if&#96; &#96;(event.origin !&#x3D;&#x3D; &#96;&#96;&#39;http:&#x2F;&#x2F;b.demo.com&#39;&#96;&#96;) &#96;&#96;return&#96;&#96;; &#96;&#96;toggleFullScreen() &#96;&#96;&#125;); Ⅳ.有哪些前端性能优化的方法?1234567891011121.资源压缩合并，减少http请求 ①合并图片（css sprites）、CSS和JS文件合并、CSS和JS文件压缩 ②图片较多的页面也可以使用 lazyLoad 等技术进行优化。2.非核心代码异步加载 ①动态脚本加载 ②defer ③async3.利用浏览器缓存 ①强缓存 ②协商缓存4.使用CDN5.DNS预解析（dns-prefetch） Ⅴ.em rem px 的区别，在哪会用到？​ px（像素） ​ px这个单位用的非常多，我们大多数人都很熟悉了吧。px单位的名称为像素，它是一个固定大小的单元，像素的计算是针对（电脑/手机）屏幕的，一个像素（1px）就是（电脑/手机）屏幕上的一个点，即屏幕分辨率的最小分割。由于它是固定大小的单位，单独用它来设计的网页，如果适应大屏幕（电脑），在小屏幕（手机）上就会很不友好，做不到自适应的效果。 ​ em（相对长度单位） ​ em单位的名称为相对长度单位，它是用来设置文本的字体尺寸的，它是相对于当前对象内文本的字体尺寸；一般浏览器默认1em=16px，通过设置font-size大小来代表如：16px*0.625=10px，其则代表1em=10px，直接上代码(注释的样式为浏览器默认 （1em=16px）的长宽) ​ rem（css3新增的相对长度单位） ​ rem是css3新增的一个相对长度单位，它的出现是为了解决em的缺点，em可以说是相对于父级元素的字体大小，当父级元素字体大小改变时，又得重新计算。rem出现就可以解决这样的问题，rem只相对于根目录，即HTML元素。所以只要在html标签上设置字体大小，文档中的字体大小都会以此为参照标准，一般用于自适应布局。 Ⅵ.关于web页面的一些安全问题？(一般说出三个，及其原理就行)1、DOS、DDOS攻击DOS（Denial of Service），拒绝服务，造成远程服务器拒绝服务的行为，叫做DOS攻击。 DOS攻击的目的：使计算机或网络无法提供正常的服务。 常见的DOS攻击：计算机网络带宽攻击、连通性攻击。 2、CSRF攻击CSRF：Cross Site Requset Forgery，跨站请求伪造 CSRF攻击的原理步骤： 受害者用户正常登录网站A，输入个人信息，在本地保存cookie 攻击者构建一条恶意链接 受害者打开了攻击者构建的恶意链接，浏览器发出该恶意链接的请求，请求时发送本地保存的cookie到网址A A网站收到cookie，以为此请求时受害者发出的，导致受害者身份被盗用，完成恶意攻击的目的。 3、XSS攻击XSS：Cross Site Scripting , 跨站脚本攻击 XSS攻击原理：恶意攻击者往web页面注入恶意Script代码，当用户浏览这些网页时，就会执行其中的恶意代码，可对用户进行盗取cookie信息、会话劫持等各种攻击。 4、session劫持基于session的攻击有很多种方式。大部分的手段都是首先通过捕获合法用户的session, 然后冒充该用户来访问系统。也就是说，攻击者至少必须要获取到一个有效的session标识符，用于接下来的身份验证。 5、点击劫持：Click Jacking，点击劫持，是一种将恶意代码经过处理使其变成透明、不可见的iframe，并将其覆盖在一个网页上，然后诱使用户在该网页上进行点击操作。通过改变iframe的在页面的位置，可以诱使用户正好点击我们设置好的透明iframe。 Ⅶ.xss攻击是什么，可以怎么防范xss攻击？​ XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 1、如果您是用的vue、react或node。​ 安装：**$ npm install xss –save** ​ 2、也可以直接在页面引用。​ 引入文件： https://raw.github.com/leizongmin/js-xss/master/dist/xss.js ​ 使用： 3.过滤掉不必要的字符（表单验证会用到） Ⅷ.http和https，简述他们的区别，且说出https为什么更加安全?12https协议需要到ca申请书，一般证书是需要付费的。http是超文本传输协议，信息是不加密传输的，https则在其添加了ssl加密协议，是具有安全性的ssl加密传输协议 Ⅸ.mvc框架的原理？一、MVC 是什么？ MVC 是一个杂糅多个设计模式的框架，它强制性的使应用程序的输入、处理和输出分开。MVC 应用程序总是由这3个部分组成：模型–视图–控制器。它们各自处理自己的任务。 一、MVC 是什么？ MVC 是一个杂糅多个设计模式的框架，它强制性的使应用程序的输入、处理和输出分开。MVC 应用程序总是由这3个部分组成：模型–视图–控制器。它们各自处理自己的任务。 注：（要说到MVC框架是种面向对象的设计模式）Ⅹ.vue的生命周期？ 123456789101112131415161718&#x2F;&#x2F;八个阶段beforeCreate 实例组件刚创建，元素DOM和数据都还没有初始化，暂时不知道能在这个周期里面进行生命操作。created 数据data已经初始化完成，方法也已经可以调用，但是DOM未渲染。有人问了，请求都是异步的，并不会阻碍实例加载。这是我个人水平的问题，这边改正，在这个周期里面，请求因为是异步的，不会阻碍实例加载，除非是那些同步操走才会导致页面空白。这样说来，在这个周期里面进行请求，渲染速度反而会更快。beforeMount DOM未完成挂载，数据也初始化完成，但是数据的双向绑定还是显示&#123;&#123;&#125;&#125;，这是因为Vue采用了Virtual DOM（虚拟Dom）技术。先占住了一个坑。 mounted 数据和DOM都完成挂载，在上一个周期占位的数据把值给渲染进去。可以在这边请求，不过created请求会更好一些。这个周期适合执行初始化需要操作DOM的方法。beforeUpdate 只要是页面数据改变了都会触发，数据更新之前，页面数据还是原来的数据，当你请求赋值一个数据的时候会执行这个周期，如果没有数据改变不执行。updated 只要是页面数据改变了都会触发，数据更新完毕，页面的数据是更新完成的。beforeUpdate和updated要谨慎使用，因为页面更新数据的时候都会触发，在这里操作数据很影响性能和容易死循环。beforeDestroy 这个周期是在组件销毁之前执行，在我项目开发中，觉得这个其实有点类似路由钩子beforeRouterLeave,都是在路由离开的时候执行，只不过beforeDestroy无法阻止路由跳转，但是可以做一些路由离开的时候操作，因为这个周期里面还可以使用data和method。比如一个倒计时组件，如果在路由跳转的时候没有清除，这个定时器还是在的，这时候就可以在这个里面清除计时器。Destroyed 说实在的，我还真的不知道这个周期跟beforeDestroy有什么区别，我在这个周期里面调用data的数据和methods的方法都能调用，所以我会觉得跟beforeDestroy是一样的。 ⅩⅠ.最后会拿你简历上做的一些案例提问，是怎么做的，原理是什么？答：根据你的简历写的案例来提问，说出大概的原理，答案不唯一。 ​ ④面试官问你有哪些问题(这个时候一定要问)， ​ ⑤最后面试官会回答你的问题，并且会评价一下你这次面试的表现，说一下你回答面试问题的错误和问题，说一下你的简历不足和不恰当之处(如果你回答不上你简历上写的问题，他会说：关于你自己的简历，你应该特别的熟悉，问到的问题要全部回答的上来，甚至了解的东西，要超过你简历上写的内容) 面试结果：未通过面试评价：面试官挺好，提出的问题非常有水准，都是一些很原理性的东西，且最后面试官对我的评价比较准确，还对我的不足之处进行了建议。​","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"webpack优化方案","slug":"webpack优化方案","date":"2020-02-24T23:25:02.000Z","updated":"2020-06-21T13:10:21.311Z","comments":true,"path":"2020/02/25/webpack优化方案/","link":"","permalink":"https://1314xulujin.github.io/2020/02/25/webpack%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/","excerpt":"","text":"webpack 是一个现代 JavaScript 应用程序最为火热的静态模块打包器，当 webpack 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 bundle ，在项目构建的时候可以根据项目需求配置自己的构建配置来优化构建的速度和项目的加载速度。 我们在这篇文章中主要来说说优化webpack项目构建性能，和对于项目的优化为目的，罗列一些常见的webpack优化方案（配置方面优化 ， 优化插件的使用） 需要优化，是否先得知道当前构建工作流中还存在什么问题吧？ 1. 使用 webpack-bundle-analyzer 来查看构建出来的项目具体情况 123456789101112cnpm install webpack-bundle-analyzer -D//webpack.config.prod.jsconst BundleAnalyzerPlugin = require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPlugin;const merge = require(&#x27;webpack-merge&#x27;);const baseWebpackConfig = require(&#x27;./webpack.config.base&#x27;);module.exports = merge(baseWebpackConfig, &#123; //.... plugins: [ //... new BundleAnalyzerPlugin(), ]&#125;) npm run build 构建，会默认打开： http://127.0.0.1:8888/，可以看到各个包的体积 2. 使用 webpack-jarvis 相比上面的插件更为直观些（个人觉得）同样可以查看出所有构建的项目在构建的时间和各个chunk的细节。 12345678910const Jarvis = require(&quot;webpack-jarvis&quot;);module.exports = merge(baseWebpackConfig, &#123; //.... plugins: [ new Jarvis(&#123; watchOnly: true,//仅仅监听编译阶段 port: 3001 // 会开启一个web ，需要设置查看的端口 &#125;) ]&#125;) 3. 使用``speed-measure-webpack-plugin` 来测量各个插件和loader所花费的时间 插件的使用方法很简单，直接将webpack的配置包裹起来即可。 123456789//webpack.config.jsconst SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);const smp = new SpeedMeasurePlugin();const config = &#123; //...webpack配置&#125;module.exports = smp.wrap(config); 下面进入优化的实施细节：1.exclude/include 我们可以通过 exclude、include 配置来确保转译尽可能少的文件。顾名思义，exclude 指定要排除的文件，include 指定要包含的文件。 exclude 的优先级高于 include，在 include 和 exclude 中使用绝对路径数组，尽量避免 exclude，更倾向于使用 include。 1234567891011121314//webpack.config.jsconst path = require(&#x27;path&#x27;);module.exports = &#123; //... module: &#123; rules: [ &#123; test: /\\.js[x]?$/, use: [&#x27;babel-loader&#x27;], include: [path.resolve(__dirname, &#x27;src&#x27;)] &#125; ] &#125;,&#125; 2. cache-loader 在一些性能开销较大的 loader 之前添加 cache-loader，将结果缓存中磁盘中。默认保存在 node_modueles/.cache/cache-loader 目录下 12//按照正常的loader配置即可如果只需要配置babel-loader , 可以直接设置 cacheDirectory:true 即可 3.happypack 由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？ HappyPack 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 1234567891011121314151617181920212223242526272829303132const Happypack = require(&#x27;happypack&#x27;);module.exports = &#123; //... module: &#123; rules: [ &#123; test: /\\.js[x]?$/, use: &#x27;Happypack/loader?id=js&#x27;, include: [path.resolve(__dirname, &#x27;src&#x27;)] &#125;, &#123; test: /\\.css$/, use: &#x27;Happypack/loader?id=css&#x27;, include: [ path.resolve(__dirname, &#x27;src&#x27;), path.resolve(__dirname, &#x27;node_modules&#x27;, &#x27;bootstrap&#x27;, &#x27;dist&#x27;) ] &#125; ] &#125;, plugins: [ new Happypack(&#123; id: &#x27;js&#x27;, //和rule中的id=js对应 //将之前 rule 中的 loader 在此配置 use: [&#x27;babel-loader&#x27;] //必须是数组 &#125;), new Happypack(&#123; id: &#x27;css&#x27;,//和rule中的id=css对应 use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;,&#x27;postcss-loader&#x27;], &#125;) ]&#125; 4.HardSourceWebpackPlugin HardSourceWebpackPlugin 为模块提供中间缓存，缓存默认的存放路径是: node_modules/.cache/hard-source。 配置 hard-source-webpack-plugin，首次构建时间没有太大变化，但是第二次开始，构建时间大约可以节约 80%。 1234567var HardSourceWebpackPlugin = require(&#x27;hard-source-webpack-plugin&#x27;);module.exports = &#123; //... plugins: [ new HardSourceWebpackPlugin() ]&#125; 5.noParse 如果一些第三方模块没有AMD/CommonJS规范版本，可以使用 noParse 来标识这个模块，这样 Webpack 会引入这些模块，但是不进行转化和解析，从而提升 Webpack 的构建性能 ，例如：jquery 、lodash。 1234567//webpack.config.jsmodule.exports = &#123; //... module: &#123; noParse: /jquery|lodash/ &#125;&#125; 6.resolve中的 modules ， extensions resolve 配置 webpack 如何寻找模块所对应的文件 , modules是指定查找依赖模块的目录（默认就是node_modules ，不建议修改） ，extensions 是指定当没有指定文件扩展名的时候，该怎么去匹配文件，默认是[‘js’,’json’] ，就是说默认先找js文件 ，找不到再使用json ,可以按照项目文件的出现概率去设置。 7.IgnorePlugin 忽略第三方包可能导入的非必须依赖123456789101112//webpack.config.jsmodule.exports = &#123; //... plugins: [ //忽略 moment 下的 ./locale 目录 new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) ]&#125;//以上配置 会在以下方式导入包的时候，只引入手动引入的包import moment from &#x27;moment&#x27;;import &#x27;moment/locale/zh-cn&#x27;;// 手动引入 8.项目生产环境CDN 优化 - externals 经常使用一些第三方的库的时候，我们可以采用CDN方式来加速和降低本地服务器的压力，同样我们也可以使用在webpack中，那么久需要指定一些第三方的库不需要打包出来，我们后期可以通过cdn 在网页中引入即可。 12345678//webpack.config.jsmodule.exports = &#123; //... externals: &#123; //jquery通过script引入之后，全局中即有了 jQuery 变量 &#x27;jquery&#x27;: &#x27;jQuery&#x27; &#125;&#125; 9.抽离公共代码 抽离公共代码是对于多页应用来说的，如果多个页面引入了一些公共模块，那么可以把这些公共的模块抽离出来，单独打包。公共代码只需要下载一次就缓存起来了，避免了重复下载。 1234567891011121314151617181920212223242526272829//webpack.config.jsmodule.exports = &#123; optimization: &#123; splitChunks: &#123;//分割代码块 cacheGroups: &#123; vendor: &#123; //第三方依赖 priority: 1, //设置优先级，首先抽离第三方模块 name: &#x27;vendor&#x27;, test: /node_modules/, chunks: &#x27;initial&#x27;, minSize: 0, minChunks: 1 //最少引入了1次 &#125;, //缓存组 common: &#123; //公共模块 chunks: &#x27;initial&#x27;, name: &#x27;common&#x27;, minSize: 100, //大小超过100个字节 minChunks: 3 //最少引入了3次 &#125; &#125; &#125; &#125;, runtimeChunk: &#123;//runtimeChunk 的作用是将包含 chunk 映射关系的列表从 main.js 中抽离出来 生成一个mainfest.js 文件 name: &#x27;manifest&#x27; &#125; &#125; 10. webpack 4.x 自身的优化 tree-shaking 如果使用ES6的import 语法，那么在生产环境下，会自动移除没有使用到的代码 scope hosting 作用域提升，可以减少一些变量声明。在生产环境下，默认开启。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://1314xulujin.github.io/tags/webpack/"}]},{"title":"前端基础面试题40道(1)","slug":"前端基础面试题40道(1)","date":"2020-02-11T01:15:08.000Z","updated":"2021-01-06T09:53:45.709Z","comments":true,"path":"2020/02/11/前端基础面试题40道(1)/","link":"","permalink":"https://1314xulujin.github.io/2020/02/11/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%9840%E9%81%93(1)/","excerpt":"","text":"123451.下面哪一种不属于 js 的五种基本数据类型？（）A.undefined B.string C.null D.Object正确答案是:D 123452.js数组的方法中，哪些方法不能改变自身数组？（）A.pop B.splice C.sort D.concat正确答案是:D 12345673.从以下字符串const str &#x3D; ‘qwbewrbbeqqbbbweebbbbqee’;中能得到结果 [“b”, “bb”, “bbb”, “bbbb”] 以下错误语句是？A.str.match(&#x2F;b &#x2F;g) B.str.match(&#x2F;b*&#x2F;g) C.str.match(&#x2F;b&#123;1,4&#125;&#x2F;g) D.str.match(&#x2F;b&#123;1,5&#125;&#x2F;g)正确答案是:A 123456789101112134.执行以下程序段后，x的值是（ ）。var x=0;switch( x )&#123;case 0: x++;case 1: x++;case 2: x++;&#125;A.1 B.2 C.3 D.4正确答案是:C 123456785.下列js可以让一个input的背景颜色变成红色的是？A.inputElement.style.backgroundColor = &#x27;red&#x27;;B.inputElement.backgroundColor = &#x27;red&#x27;;C.inputElement.style.backgroundColor = &#x27;#0000&#x27;;D.inputElement.backgroundColor = &#x27;#0000&#x27;;正确答案是:A 123456786.关于 this 的工作原理，下面 4 种情况的描述哪一个是错误的？（）A.在全局范围内，this指向全局对象（浏览器下指window）B.对象函数调用时，this指向当前对象C.全局函数调用时，this指向全局函数D.使用new实例化对象时，this指向新创建的对象正确答案是:C 123456789101112137.执行下面JavaScript 代码，页面输出的内容是（ ）。function showInfo() &#123;var a = &quot;Hello&quot;;var b = &quot;World&quot;;document.write(a); return b;&#125;document.write(showInfo());A.Hello B.World C.HelloHello D.HelloWorld正确答案是:D 123456789101112138.下属片段中，el指向dom是？（） //html&lt;div id=&#x27;foo&#x27;&gt; &lt;p id=&#x27;foo&#x27;&gt;&lt;/P&gt;&lt;/div&gt;//javascriptvar el = document.getElementById(&#x27;foo&#x27;); A.&lt;div id=’foo’&gt;&lt;/div&gt; B.&lt;p id=”foo”&gt;&lt;/p&gt; C.null D.以上都错误正确答案是:A 123459.在javascript里，下列选项中不属于数组方法的是（）A.sort() B.length() C.concat() D.reverse()正确答案是:B 1234567810.在JavaScript 中，能正确定义数组的有（ ）。 A.var arr = [&#123;&quot;name&quot;:&quot;牛奶&quot;&#125;,&#123;&quot;name&quot;:&quot;面包&quot;&#125;]; B.var arr = [&#123;&quot;牛奶&quot;&#125;,&#123;&quot;面包&quot;&#125;]; C.var arr = new Array(&quot;牛奶&quot;,&quot;面包&quot;); D.var arr = (&quot;牛奶&quot;,&quot;面包&quot;); 正确答案是:AC 1234511.在JavaScript 中，产生当前日期的方法是（ ）A.Now() B.getDate() C.new Date() D.new Now()正确答案是:C 1234567812.下面有关JavaScript 常见事件，描述错误的是（ ）。A.onmousedown：鼠标键被按下B.onkeypress：键盘的键被按下或按住C.onblur：元素获得焦点D.onchange：会在域的内容改变时发生正确答案是:C 123456789101113.分析下段代码输出结果是（ ）var arr = [2,3,4,5,6];var sum =0;for(var i=1;i &lt; arr.length;i++) &#123;sum +=arr[i] &#125;console.log(sum);A.20 B.14 C.18 D.12正确答案是:C 1234567814.以下关于 Array 数组对象的说法不正确的是（ ） A.对数组里数据的排序可以用 sort 函数，如果排序效果非预期，可以给 sort 函数加一个排序函数的参数 B.reverse 用于对数组数据的倒序排列 C.向数组的最后位置加一个新元素，可以用 pop 方法 D.unshift 方法用于向数组删除第一个元素 正确答案是:CD 123456789101115.以下代码运行的结果是输出( )var a = b = 10;(function()&#123;var a=b=20&#125;)();console.log(b);A.10 B.20 C.报错 D.undefined正确答案是:B 1234567816.以下代码运行后的结果是输出( )var a=[1, 2, 3];console.log(a.join());A.123 B.1,2,3 C.1 2 3 D.[1,2,3]正确答案是:B 1234517.在 JS 中，’1555’+3 的运行结果是( )A.1558 B.1552 C.15553 D.1553正确答案是:C 12345678918.以下代码运行后弹出的结果是( )var a &#x3D; 888;++a;alert(a++);A.888 B.889 C.890 D.891正确答案是:B 12345678919.关于变量的命名规则，下列说法正确的是（ ） A.首字符必须是大写或小写的字母，下划线（_）或美元符（$） B.首字母的字符可以是字母，数字，下划线或美元符 C.变量名称不能是保留字 D.可以使用驼峰命名规则 E.区分大小写 正确答案是:ACDE 1234520.下列的哪一个表达式将返回值为假（ ）A.!(3&lt;=1) B.(4&gt;=4)&amp;&amp;(5&lt;=2) C.(“a”==“a”)&amp;&amp;(“c”!=“d”) D.(2&lt;3)||(3&lt;2)正确答案是:B 1234567891021.下面代码，k的运行结果是（ ）var i = 0,j = 0;for(;i&lt;10,j&lt;6;i++,j++)&#123;k = i + j;&#125;A.16 B.10 C.6 D.12正确答案是:B 123456789101122.以下代码中 y 的值为（ ）var x = 1; function fn(n)&#123; n = n+1 &#125;; y = fn(x);A.2 B.1 C.3 D.undefined正确答案是:D 1234567823.[1,2,3,4].join(‘0’).split(’’) 的执行结果是（ ）A.&#x27;1,2,3,4&#x27;B.[1,2,3,4]C.[“1”,“0”,“2”,“0”,“3”,“0”,“4”]D.&#x27;1,0,2,0,3,0,4&#x27;正确答案是:C 12345624.以下代码中 n 的值为：（ ）var n = &quot;jiao yu gai bian sheng huo&quot;.indexOf(&quot;gai&quot;,6)；A.8 B.7 C.6 D.-1正确答案是:A 1234525.alert( “12”&gt;“9” ) 的运行结果正确的是（ ）A.true B.false C.语法错误正确答案是:B 1234567826.下面的描述中不正确的是（ ）A.arguments 中保存了实际传入函数内的所有参数。B.return 只能在函数内部使用。C.setInterval(fn1,1000) 只会调用一次 fn1。D.Date 对象的 getMonth() 获取到的值比实际月份小1。正确答案是:C 1234567827.下面的等式成立的是（ ）A.parseInt(12.5) == parseFloat(12.5)B.Number(&#x27;&#x27;) == parseFloat(&#x27;&#x27;)C.isNaN(&#x27;abc&#x27;) == NaND.typeof NaN === &#x27;number&#x27;正确答案是:D 1234567828.下面的描述中不正确的是（ ） A.&#39;&#x3D;&#x3D;&#39; 在比较过程中，不但会比较两边的值，还会比较两边的数据类型。 B.NaN &#x3D;&#x3D; NaN 的结果是 true。 C.isNaN，判断传入的参数是否为数字，为数字返回true，否则返回false D.字符串的 length 只可以获取，不可以设置。 正确答案是:ABC 12345678929.以下代码运行后，arr的结果为（ ），arr2的结果为（ ）var arr = [1,2];var arr2 = arr.concat();arr2.push( arr.splice(1,0) ); A.[1,2] B.[1,2,[2]] C.[1,2,[]] D.[1,2,3] 正确答案是:AC 1234567830.下面关于数组的描述正确的是（ ）A . 数组的 length 既可以获取，也可以修改。B . 调用 pop() 方法，不会修改原数组中的值。C . shift() 方法的返回值是新数组的长度。D . 调用 concat() 方法，会修改原数组的值。正确答案是:A 1234567891031.分析下面的代码，输出的结果是（ ）var arr=new Array(5);arr[1]=1;arr[5]=2;console.log(arr.length);A.2 B.5 C.6 D.报错正确答案是:C 1234567832.在JavaScript中，下列（ ）语句能正确获取系统当前时间的小时值。A.var date=new Date(); var hour=date.getHour();B.var date=new Date(); var hour=date.gethours();C.var date=new date(); var hour=date.getHours();D.var date=new Date(); var hour=date.getHours();正确答案是:D 1234533.请选择结果为真的选项（ ）A.null &#x3D;&#x3D; undefined B.null &#x3D;&#x3D;&#x3D; undefined C.undefined &#x3D;&#x3D; false D.NaN &#x3D;&#x3D; NaN正确答案是:A 1234534.Math.ceil(-3.14)的结果是（ ）A.-3.14 B.-3 C.-4 D.3.14正确答案是:B 1234535.Math.floor(-3.14) 的结果是（ ）A.-3.14 B.-3 C.-4 D.3.14正确答案是:C 1234567836.阅读以下代码，在页面中结果是（ ）var s=&quot;abcdefg&quot;;alert(s.substring(1,2));A.a B.b C.bc D.ab正确答案是:B 1234537.以下 ECMAScript 变量命名格式正确的是（ ）A._125dollor B.1207A C.-dollor D.this正确答案是:A 1234538.下列哪个不是HTML DOM的event事件？A.onclick() B.onMove() C.onblur() D.onfocus()正确答案是:B 1234567839.在实际使用中，下面哪一个可以很方便的获得页面中定义的HTML对象？（）A.document.GetElementsByTagNameB.document.getElementByTagNamesC.document.getElementsByIdD.document.getElementById正确答案是:D 1234567840.下面有关javaScript事件的响应，描述错误的是？A.onclick 鼠标点击某个对象B.onfocus 元素失去焦点C.onload 是某个页面的css js html 文档结构和图像被完全加载D.onmousedown 某个鼠标按键被按下正确答案是:B","categories":[],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"前端基础面试题34道(2)","slug":"前端基础面试题34道(2)","date":"2020-02-11T00:27:35.000Z","updated":"2021-01-06T09:53:26.974Z","comments":true,"path":"2020/02/11/前端基础面试题34道(2)/","link":"","permalink":"https://1314xulujin.github.io/2020/02/11/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%9834%E9%81%93(2)/","excerpt":"","text":"123456789101.以下为一段浏览器中可运行的Javascript 代码，则运行该段Javascript代码的页面弹出框中显示的结果是：（）var obj = &#123;&quot;key&quot;:&quot;1&quot;,&quot;value&quot;:&quot;2&quot;&#125;;var newObj = obj;newObj.value = obj.key;alert(obj.value);A.2 B.12 C.3 D.1 正确答案是:D 123456782.以下语句那个是判断foo是否为String类型？A.foo instanceof String B.typeof foo &#x3D;&#x3D; ’string’ C.foo is String D.以上答案都不正确 正确答案是:B 123453.在JavaScript 中，使用（ ）事件可以更合理实现当焦点离开文本框userName 时，调用函数checkUser() 来验证文本框内容的合法性。A.onfocus B.onblur C.onchange D.onclick正确答案是:C 123456789101112134.以下代码运行后，结果为（ ）fn1();var fn1 = function(a)&#123; alert(a); &#125;A.1 B.程序报错 C.alert(1); D.undefined正确答案是:B 123455.alert( “12”&gt;“9” ) 的运行结果正确的是（ ）A.true B.false C.语法错误正确答案是:B 123456786.下面的描述中不正确的是（ ） A.&#39;&#x3D;&#x3D;&#39; 在比较过程中，不但会比较两边的值，还会比较两边的数据类型。 B.NaN &#x3D;&#x3D; NaN 的结果是 true。 C.isNaN，判断传入的参数是否为数字，为数字返回true，否则返回false D.字符串的 length 只可以获取，不可以设置。 正确答案是:ABC 123456787.下面关于数组的描述正确的是（ ）A.数组的 length 既可以获取，也可以修改。B.调用 pop() 方法，不会修改原数组中的值。C.shift() 方法的返回值是新数组的长度。D.调用 concat() 方法，会修改原数组的值。正确答案是:A 123456788.在 HTML 页面中包含一个按钮控件 mybutton ，如果要实现点击该按钮时调用已定义的 JavaScript 函数 compute ，要编写的 HTML 代码是()A.&lt;input name=”mybutton” type=”button” onBlur=”compute()” value=”计算”&gt;B.&lt;input name=”mybutton” type=”button” onFocus=”compute()” value=”计算”&gt;C.&lt;input name=”mybutton” type=”button” onClick=”function compute()” value=”计算”&gt;D.&lt;input name=”mybutton” type=”button” onClick=”compute()” value=”计算”&gt;正确答案是:D 123456789109.下面这段JS程序的执行结果是：var a &#x3D;[1,2,3];var b &#x3D; a.slice();b.push(4);console.log(a)A.[1,2,3,4] B.[1,2,3] C.[4] D.[2,3,4]正确答案是:B 1234567891011121314151610.问：控制台打印的结果是？for(let i=0;i&lt;2;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,100);&#125;for(var i=0;i&lt;2;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,100);&#125;A.0 1 2 2 B.0 1 0 1 C.0 1 1 1 D.1 1 0 0正确答案:A 123456789101112131411.查看如下 JavaScript 代码：var a = &quot;10&quot;;var b = 10;if (a == b) alert(&quot;equal&quot;);if (a === b) alert(&quot;same&quot;);此代码运行后，效果为( )A.只弹出”equal“ B.只弹出”same“ C.先弹出”equal“，再弹出”same“ D.没有弹出显示正确答案是:A 1234567891011121312.阅读如下代码：var a1 = [1, 2, 12]; var a2 = [4, 23]; a1.concat(a2); a1.sort(); alert(a1.join(&quot;;&quot;));代码运行后，alert 方法弹出的内容为( )A.1;2;12 B.1;12;2 C.1;2;4;12;23 D.1;12;2;23;4正确答案是:B 1234567813.HTML 页面上有一个超链接，要实现当鼠标移入该超级链接时，超级链接的文本背景色变为灰色。下列选项中，能实现此功能的是()A.&lt;a href=&quot;#&quot; onmouseover=&quot;this.style.background.color=&#x27;gray&#x27;;&quot;&gt;注册&lt;/a&gt;B.&lt;a href=&quot;#&quot; onmouseout=&quot;this.style.background-color=&#x27;gray&#x27;;&quot;&gt;注册&lt;/a&gt;C.&lt;a href=&quot;#&quot; onmouseover=&quot;this.style.backgroundColor=gray;&quot;&gt;注册&lt;/a&gt;D.&lt;a href=&quot;#&quot; onmouseover=&quot;this.style.backgroundColor=&#x27;gray&#x27;;&quot;&gt;注册&lt;/a&gt;正确答案是:D 123456789101114.有数组定义如下：var a1 = [1, 14, 4, 12, 23];现需要实现对数组 a1 中的内容按照数值大小升序排列，下列代码中，错误的是()A.a1.sort(new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a-b;&quot;));B.a1.sort(function (a, b) &#123; return a - b; &#125;);C.a1.sort(new function (a, b) &#123; return a - b; &#125;);D.a1.sort(sortFunc); function sortFunc(a, b) &#123; return a - b; &#125;正确答案是:C 1234515.下列选项中，不是 window 对象的子对象的是()A.location B.history C.screen D.arguments正确答案是:D 1234567816. html 页面上有一个 id 值为 b1 的按钮，现需要使用 JavaScript 代码为其定义单击事件：单击该按钮后，弹出“Hello”。下列选项中，错误的是()A.document.getElementById(&quot;b1&quot;).onclick &#x3D; function () &#123; alert(&quot;hello&quot;); &#125;;B.document.getElementById(&quot;b1&quot;).onclick &#x3D; new Function(&quot;alert(&#39;hello&#39;); &quot;);C.document.getElementById(&quot;b1&quot;).onclick &#x3D; new function () &#123; alert(&quot;hello&quot;); &#125;;D.document.getElementById(&quot;b1&quot;).onclick &#x3D; clickFunc; function clickFunc() &#123; alert(&quot;Hello&quot;); &#125;正确答案是:C 1234517.window对象的方法中，( ）方法是用于弹出确认对话框，可让选择“确定”或“取消”A.confirm() B.alert() C.prompt() D.open()正确答案是:A 1234518.以下JavaScript变量名不合法的有() A.4Myvariable B.My@variable C.function D.Myvariable4 正确答案是:ABC 1234519.在JavaScript程序中加入注释，方法有() A.&#x2F;&#x2F;注释内容 B.&#x2F;*注释内容*&#x2F; C.&#x2F;注释内容 D.&#x2F;*注释内容 正确答案是:AB 1234567820.关于javascript语言说法错误的是？A.JavaScript是目前Web应用程序开发者使用最为广泛的客户端脚本编程语言B.javaScript是网景公司专为Navigator浏览器开发、实现网页内容交互的功能。C.javascript是由SUN公司开发的。D.ECMAScript是一个为了规范Javascript语言而产生的国际标准。正确答案是:C 1234521.表达式5+22&#x2F;2%2的计算结果是：A.5 B.6 C.7 D.8 E.语法错误正确答案是:B 1234567822.关于文档对象模型（Document Object Model），如下说法错误的是A.DOM能够以编程方式访问和操作web页面内容。B.DOM允许通过对象的属性和方法访问页面中的对象C.DOM能够创建动态的文档内容，但是不能删除文档对象D.DOM也提供了处理事件的接口，它允许捕获和响应用户以及浏览器的动作正确答案是:C 1234523.下列事件哪个不是由鼠标触发的事件A.click B.contextmenu C.mouseout D.keydown正确答案是:D 1234567891024.下面代码执行后， arr 的值是：（）var arr=[&#123;a:1&#125;,&#123;&#125;];arr.forEach(function(item,idx)&#123; item.b=idx;&#125;);A.[&#123;a:1&#125;,&#123;&#125;] B.[&#123;a:1,b:0&#125;,&#123;b:1&#125;] C.[&#123;a:1,b:1&#125;,&#123;b:1&#125;] D.[&#123;a:!,b:0&#125;,&#123;b:0&#125;]正确答案是:B 1234525.以下哪一条Javascript语句会产生运行错误？A.var obj=( ); B.var obj=[ ]; C.var obj=&#123; &#125;; D.var obj=/ /;正确答案是:A 12345626.下列js延迟加载的方式中，只有IE浏览器支持的是哪一种方式？（）备注：该题可能过时，请按照之前的知识选择。A.async B.defer C.动态创建DOM方式 D.按需异步载入正确答案是:B 1234567891011121314151627.var x = new Boolean(false);if (x) &#123; alert(&#x27;hi&#x27;);&#125;var y = Boolean(0);if (y) &#123; alert(&#x27;hello&#x27;); &#125;的显示结果是？A.hi B.hi hello C.hello D.不显示正确答案是:A 1234567828.页面有一个按钮button id为button1，通过原生的js如何禁用？（） A.document.getElementById(“button1”).setAttribute(“Readolny”,true); B.document.getElementById(“button1”).setAttribute(“disabled”,true); C.document.getElementById(“button1”).Readolny&#x3D;true; D.document.getElementById(“button1”).disabled&#x3D;true; 正确答案是:BD 12345678910111213141516171829.下列 JavaScript 代码执行后的 li 元素的数量是()&lt;ul&gt;&lt;li&gt;Item&lt;&#x2F;li&gt;&lt;li&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;&#x2F;li&gt;&lt;li&gt;Item&lt;&#x2F;li&gt;&lt;li&gt;Item&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;var items &#x3D; document.getElementsByTagName(&#39;li&#39;);for(var i &#x3D; 0; i&lt; items.length; i++)&#123;if(items[i].innerHTML &#x3D;&#x3D; &#39;&#39;)&#123;items[i].parentNode.removeChild(items[i]);&#125; &#125; A.3 B.4 C.5 D.6 正确答案是:B 1234567830.请选择结果为真的表达式：（ )A.null instanceof ObjectB.null === undefinedC.null == undefinedD.NaN == NaN正确答案是:C 1234567831.下面的 JavaScript 语句中，（ ）实现检索当前页面中的表单元素中的所有文本框，并将它们全部清空A.for(var i&#x3D;0;i&lt; form1.elements.length;i++) &#123; if(form1.elements.type&#x3D;&#x3D;”text”) form1.elements.value&#x3D;”&quot;;&#125;B.for(var i&#x3D;0;i&lt;document.forms.length;i++) &#123; if(forms[0].elements.type&#x3D;&#x3D;”text”) forms[0].elements.value&#x3D;”&quot;; &#125;C.if(document.form.elements.type&#x3D;&#x3D;”text”) form.elements.va lue&#x3D;”&quot;;D.for(var i&#x3D;0;i&lt;document.forms.length; i++)&#123; for(var j&#x3D;0;j&lt;document.forms.elements.length; j++)&#123; if(document.forms.elements[j].type&#x3D;&#x3D;”text”) document.forms.elements[j].value&#x3D;”&quot;; &#125; &#125;正确答案是:D 1234532.以下哪个单词不属于 javascript 保留字：（ ）A.with B.parent C.class D.void正确答案是:B 1234567833.以下哪个结果是正确的？var a&#x3D;10;b&#x3D;20;c&#x3D;4;console.log(++b+c+a++);A.34 B.35 C.36 D.37正确答案是:B 12345678910111234.以下运算会输出什么结果?const a = &#123;a:1234&#125;;const b = &#123;b:5678&#125;;const c = &#123;&#125;c[a] = a;c[b] = 1122;console.log(c[a]);A.报错 B.1234 C.5678 D.1122正确答案是:D","categories":[],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Git 版本控制工具","slug":"Git-版本控制工具","date":"2020-01-31T01:18:53.000Z","updated":"2020-06-21T13:10:21.239Z","comments":true,"path":"2020/01/31/Git-版本控制工具/","link":"","permalink":"https://1314xulujin.github.io/2020/01/31/Git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/","excerpt":"","text":"什么是git? 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目 , 有效提高团队协作能和代码版本的管理问题. 目前工作流中使用版本控制系统主要有:SVN(集中式) 和 Git(分布式) SVN 与 Git的区别 1234SVN 是一个集中式管理系统(所有项目代码统一集中管理)Git 是一个分布式管理系统(每台终端设备既是终端也是一个本地的仓库 ,也会有一个集中管理仓库) 认识git 中的几个概念:1234567891.工作区 : 就是你在电脑里能看到的目录。2.暂存区 :英文叫stage, 或index。一般存放在 &quot;.git目录下&quot; 下的index文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。3.版本库(仓库) : 本地电脑上工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。4.远程仓库(版本库):在远程端(服务器上)的一个仓库HEAD : 用于指向当前工作中的分支或节点 在vscode编辑器中设置使用的终端为git的bash.exe , 不用windows 自带的cmd.exe ,这样有一些更友好的界面和提示: 123在vscode的设置中 - &gt; 功能- &gt; 终端 -&gt; Intergrated- shell - Windows 位置下 ,点击 在settings.json 中编辑 ,然后添加以下配置:&quot;terminal.integrated.shell.windows&quot;: &quot;C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe&quot; git的常用命令:1234567891011121314151617git工具的命令都是在命令通过git 指令开始 :1. 克隆远程仓库: git clone https:&#x2F;&#x2F;github.com&#x2F;jquery&#x2F;jquery.git 2. 初始化仓库 (为了生成.git 目录 :暂存区 ,版本库的,配置文件信息等)3. 查看当前的工作状态 : git status (查看到当前工作区中的文件,哪些已经改动的文件是否已经加入到暂存区(红色:未加入, 绿色加入))4. 将工作区变动的文件添加到暂存区: git add . (.代表一切改动文件 ,也可以直接使用文件名)5. 将暂存区的文件提交到本地版本库: git commit -m &#39;项目首次提交&#39;6. 如果是首次使用git , 一般会提示需要设置提交者的个人信息 1. git config --global user.email &quot;Timor-m@foxmail.com&quot; 2. git config --global user.name &quot;Timor-m&quot; 3. 再一次commit提交到本地仓库即可7.使用git log 查看所有的提交记录 (git log -p -2) -p显示详情 -2显示最近的两次提交记录8.git checkout 节点的名称&#x2F;分支的名称 将工作区内容切换到指定的节点或者分支9.推送到远程端仓库:git push 10.设置一个远程仓库地址 :git remote add 仓库名称 仓库地址 11.从远程端仓库拉取最新的更新到本地仓库:git pull git的使用工作流程:12341.初始化仓库 git init &#x2F; 通过克隆远程端的仓库 git clone 仓库地址2.git status 查看当前工作区的状态 (非必须)3.git add . 将变化的文件添加到暂存区4.git commit -m &#39;本次提交的一些备注&#39; 将本地仓库推送到远程仓库12345671.先确认本地仓库中是否有配置过远程的仓库地址: 1.git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;Timor-M&#x2F;iExam.git (设置一个本地名为origin的远程仓库) 2.git branch --set-upstream-to&#x3D;origin&#x2F;master master (设置一个从本地的master分支提交到远程仓库origin的master的映射关系) 3.因为每次提交都需要把远程的最新的记录要先拉取下来,所以一般在push之前需要pull一次,但是如果遇到有没有相关的提交记录,git会默认拒绝合并拉取回来的项目代码,所以可以在git pull的时候添加一个参数 --allow-unrelated-histories(允许合并两个不相关的记录) : git pull --allow-unrelated-histories 到此应该就没什么问题了..2.可以直接将远程的仓库先克隆一份到本地,这样就省去了一些配置过程,克隆过来的仓库已经配置好地址了. 对于一些不需要或者错误的操作的撤销:12341.撤销暂存区的文件 git reset HEAD 2.撤销对文的修改操作 git checkout -- 文件名 分支的使用:可以在不影响到主线上,进行的开发(突发发现主线Bug , 项目的迭代版本 ,开发版本) 相当于克隆多份项目代码进行开发 ,不会彼此影响12345678910创建分支: git brance dev (可以带 -b 参数:创建一个新分支并且切换到新分支 )首次提交会需要执行一个设置提交分支 : git push --set-upstream origin dev合并分支:(把dev分支合并到master分支) 1.需要先切换到master主分支 2. git merge dev (把新开发的功能dev分支 ,合并到主线分支master)删除(本地)分支:git branch --delete dev删除远程分支: git push origin --delete dev 提交冲突问题:(多协作或者多分支操作的时候会遇到提交分支冲突,需要解决冲突后再重现提交)123456场景:小A此时拉取了远程仓库上最新的代码(此时小A,小B本地仓库代码一样的了) , 然后开始修改了a.txt 文件 , 然后又直接提交到了远程仓库同时小B 也修改了a.txt , 然后也直接提交到仓库 ,此时就会遇到一个提交的提示,告知需要把远程仓库的最新代码拉取下来才能提交,所以此时又得使用git pull命令,拉取最新的内容 ,但是因为本地以及修改过a.txt ,而且远程仓库上的变更也是修改了a.txt文件 ,所以此时就会冲突,需要手动解决冲突后,才可以继续提交解决: 手动把 &lt;&lt;&lt;&lt;&lt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &lt;&lt;&lt;&lt;&lt; 标记代码去除掉, 把需要的代码留下 ,然后再使用 git add . 和git commit 提交 后 再推送到服务器即可.(如果更新的文件和需要提交的文件不相同,则会自动合并两个分支的内容 ,主要是同一个文件的变更,需要手动确认) 设置项目一些文件或者文件目录不需要提交到仓库(忽略目录) 121.创建一个 .gitignore 文件在git 项目的根目录下touch .gitignore (使用命令创建文件) 2.添加需要被忽略的文件及目录 .gitignore info.txt 1设置完之后 ,每次的提交变更都会忽略掉设置的那些文件 也不再检测","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://1314xulujin.github.io/tags/git/"}]},{"title":"ES6 Promise","slug":"ES6-Promise","date":"2019-12-19T01:41:02.000Z","updated":"2020-06-21T13:10:21.238Z","comments":true,"path":"2019/12/19/ES6-Promise/","link":"","permalink":"https://1314xulujin.github.io/2019/12/19/ES6-Promise/","excerpt":"","text":"ES6 - Promise1.Promise异步编程需自己引入jQuery1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // Promise 用于解决异步编程的一种解决方案, 也可以理解是一个执行异步操作的容器,在容器中封装好了一套处理异步的流程机制 /* * 1.有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。 * 2.一旦状态改变，就不会再变，任何时候都可以得到这个结果。从pending - &gt; fulfilled (成功) 或者 pending -&gt; 和rejected (失败) , 每次只能改变一次状态 * * */ var promise = new Promise(function(resolve,reject)&#123;//创建一个promise容器 , resolve 一个用于在处理异步成功时调用的函数 , reject 处理异步失败的时候调用的函数 setTimeout(function()&#123; //通过延时定时器模拟异步 , 2000ms 结束后就可以调用成功或者失败 console.log(&#x27;时间到了!!!&#x27;); resolve(123456); reject(12) &#125;,2000); &#125;); //当实例化Promise之后(已经执行异步操作) , (结果怎么样)然后呢? then() 编写需要执行的回调业务 promise.then(function(res)&#123; console.log(&quot;执行成功!&quot;,res); &#125;,function(err)&#123; console.log(&quot;执行失败!&quot;,err); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.Promise 异步编程-回调地狱现象需建一个data文件夹，里面创建四个txt文件(a.txt b.txt c.txt d.txt)来用于ajax请求，别忘了老夫写代码只用jQuery🤣12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // Promise 用于解决异步编程 /* * 比如说 ajax 就是一个异步操作 , 之前的使用的回调函数的方式解决异步编程 * * $.ajax(&#123; * url:&#x27;abc.com&#x27;, * success:function(res)&#123; * * &#125; * &#125;) * * 场景: * 1.先获取当前token是否已经失效 * 2.如果没有失效,返回当前的token的用户的基本信息(基本信息包含 uid ) * 3.根据uid 来查询当前用户的会员等级 * 4.再通过当前用户的会员等级,来查询当前用户的特权(来检测用户是否有权限来执行某个操作) * * 案例: * 已知a.txt 地址 ,然后需要根据a.txt 返回的结果进行下一次的查询 ,逐一查询到最后的结果d.txt内容 * */ //使用jQuery 实现 = &gt; 造成一个 &quot;回调地狱&quot; $.ajax(&#123; url:&quot;data/a.txt&quot;, success:function(res)&#123; console.log(&#x27;第一次:&#x27;,res); //再发出下一次请求 $.ajax(&#123; url:res, success:function(res)&#123; console.log(&#x27;第二次&#x27;,res); $.ajax(&#123; url:res, success:function (res) &#123; console.log(&#x27;第三次:&#x27;,res); $.ajax(&#123; url:res, success:function (res) &#123; console.log(&quot;第四次:&quot;,res); &#125; &#125;) &#125; &#125;) &#125; &#125;) &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://1314xulujin.github.io/tags/ES6/"}]},{"title":"H5存储(cookie,localStorage和sessionStorage)","slug":"H5存储CookielocalStorage和sessionStorage","date":"2019-12-19T01:13:48.000Z","updated":"2020-06-21T13:10:21.243Z","comments":true,"path":"2019/12/19/H5存储CookielocalStorage和sessionStorage/","link":"","permalink":"https://1314xulujin.github.io/2019/12/19/H5%E5%AD%98%E5%82%A8CookielocalStorage%E5%92%8CsessionStorage/","excerpt":"","text":"H5存储(cookie,localStorage和sessionStorage)1.js操作cookie1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // cookie 在document对象上 // console.log(document.cookie); var date = new Date(&quot;2087-10-26 10:21:30&quot;); //写入cookie 到浏览器本地 /* * 写入cookie 的时候 可以添加: * name=value 内容 * Expires=日期对象 * domain=域名(baidu.com) * path=/ (/ 表示该站点下所有页面都可以访问 ,/a 只能a目录下的页面可以访问) * */ // document.cookie = &#x27;name=张三;Expires=&#x27;+date+&#x27;&quot;;domain=localhost;path=/&#x27;; document.cookie = &#x27;sex=男;Expires=&#x27;+date+&#x27;&quot;;domain=localhost;path=/&#x27;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.本地存储localStorage123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; /* * localStorage 本地存储 * -属性: * length 当前站点下存储的数量 * -方法: * clear() 清空当前站点下所有的存储内容 * getItem(key) 获取指定 键名的存储数据 * removeItem(key) 删除指定键名的存储数据 * setItem(key,value) 按键值对关系设置存储数据 * key(index) 获取索引值为index的键名 * * -事件: * storage : 只要在同一个站点下有对存储内容进行改变 都会触发这个 * * 实现一个 &quot;浏览器多标签页之间通信&quot; = &gt; 类似于京东购物页面多个页面可以实现共享购物车数据 * */ console.log(window.localStorage)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.localStorage写入存储演示123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;button onclick=&quot;setText()&quot;&gt;写入存储&lt;/button&gt;&lt;script&gt; var txt = document.getElementById(&quot;txt&quot;); function setText()&#123; window.localStorage.setItem(&quot;txt&quot;,txt.value); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.localStorage读取存储演示12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;show&quot;&gt;&lt;/div&gt;&lt;script&gt; window.addEventListener(&quot;storage&quot;,function()&#123; show.innerHTML = localStorage.getItem(&quot;txt&quot;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.插件办cookie（类似于localStorage）需要自己去下载并引入插件来编写 12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;js/js.cookie.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //写入cookie Cookies.set(&quot;name&quot;,&quot;张三&quot;,&#123; expires : 7 , path:&quot;/s&quot; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.封装一个按键名读取cookie的方法12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; /* * 需求: 一般为了操作cookie方便 ,在使用的时候都是按照 key 名 来读取到指定的cooke的值 * */ function getCookie(key)&#123; var cookies = document.cookie;//获取cookie var arr = cookies.split(&quot;;&quot;); var obj = &#123;&#125;; arr.forEach(function (item) &#123; var tmp = item.split(&quot;=&quot;); var k = tmp[0]; //获取键名 k = k.trim(); obj[k] = tmp[1]; // console.log(tmp); &#125;) return obj[key]; &#125; console.log(getCookie(&quot;age&quot;));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.封装一个写入cookie的函数12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //定义一个设置cookie的方法 function setCookie(key,value,day,domain,path) &#123; // 键值对 key cookie的字段名 ,value 值 ,day 周期 domain域名 ,path 路径 var day = day || 1; var expires = new Date(new Date().getTime() + day * 24 * 60 * 60 * 1000); var domain = domain || &quot;localhost&quot;; var path = path || &quot;/&quot;; //写入cookie document.cookie = key+ &quot;=&quot; + value +&quot;;expires=&quot;+expires+&quot;;domain=&quot;+domain+&#x27;;path=&#x27;+path; &#125; var str = &quot;张三1&quot;; for(var o=0;o&lt;5000;o++)&#123; str+=&quot;张三&quot;+o; &#125; //测试一下浏览器能存储多少cookie for(var i=1;i&lt;=200;i++)&#123; setCookie(&quot;name&quot;+i,str,30); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8.解决浏览器缓存无法更新最新的内容问题其原理是如果下一次缓存过来的文件的名称与上一次相同，还是会用上一次的，导致其内容不能更新；解决的办法是每次缓存过来的文件用个随机的数来生成其文件名，反正名字不能一样。 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!--&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css?v=1.23565&quot;&gt;--&gt; &lt;script&gt; var link = document.createElement(&quot;link&quot;); link.rel=&quot;stylesheet&quot;; link.href = &quot;css/index.css?v=&quot; + Math.random(); document.head.appendChild(link); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 9.使用本地存储来存静态资源文件（localStorage综合使用）1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script src=&quot;js/jquery-v1.12.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //使用ajax 获取test.css 样式 //定义一个获取静态资源文件的方法 function getCss(url)&#123; var style = window.localStorage.getItem(url); if(style)&#123; createStyle(style); &#125;else&#123; $.get(url,function(res)&#123; createStyle(res); //把当前的url地址的文件存储到本地缓存 window.localStorage.setItem(url,res); &#125;) &#125; &#125; function createStyle(style)&#123; var styleElement = $(&quot;&lt;style&gt;&quot;+style+&quot;&lt;/style&gt;&quot;); $(&quot;head&quot;).append(styleElement); &#125; getCss(&quot;./css/test.css&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 10.可以使用本地存储来制作一个备忘录(ToDoList)详情可以去网上查资料也可看我的 html代码部分（其使用了bootstrapUI框架和很多的js框架可以看代码引入的名称去网上下载框架源码）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;ToDo List&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;&gt; &lt;style&gt; .table th&#123; text-align: center; background-color: #9acfea; color: #fff; &#125; .table td&#123; text-align: center; &#125; #register&#123; position: absolute; z-index: 1000; top: 40%; left: 50%; transform: translate(-50%,-50%); z-index: 1000; width: 400px; padding: 20px; border: 1px solid #ccc; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; margin: 50px auto; background-color: #f9f9f9; box-shadow: 0 0 10px #2aabd2; display: none; &#125; #login&#123; position: absolute; z-index: 1000; top: 40%; left: 50%; transform: translate(-50%,-50%); width: 400px; padding: 20px; border: 1px solid #ccc; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; margin: 50px auto; background-color: #93cfe1; box-shadow: 0 0 10px #ccc; display: none; &#125; #mask&#123; position: fixed; z-index: 999; top:0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,.8); display: none; &#125; #main&#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--登录成功的主视图--&gt; &lt;div id=&quot;main&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;div class=&quot;pull-right&quot;&gt;&lt;button class=&quot;btn btn-info logout&quot;&gt;退出登录&lt;/button&gt;&lt;/div&gt; &lt;h2&gt;TodoList - 备忘录 &lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8 col-md-offset-2&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-addon&quot;&gt;请输入待办事项&lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;txt&quot;&gt; &lt;div class=&quot;input-group-btn&quot;&gt; &lt;button class=&quot;btn btn-success&quot; id=&quot;addToDo&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-plus&quot;&gt;&lt;/span&gt;立即添加&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;hr&gt; &lt;table class=&quot;table table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;th width=&quot;10%&quot;&gt;编号&lt;/th&gt; &lt;th width=&quot;45%&quot;&gt;标题&lt;/th&gt; &lt;th width=&quot;20%&quot;&gt;创建时间&lt;/th&gt; &lt;th width=&quot;10%&quot;&gt;状态&lt;/th&gt; &lt;th width=&quot;15%&quot;&gt;操作&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--注册视图--&gt; &lt;div id=&quot;register&quot;&gt; &lt;div class=&quot;form-horizontal&quot;&gt; &lt;h3 class=&quot;text-center&quot;&gt;用户注册窗口&lt;/h3&gt; &lt;div class=&quot;form-group clearfix&quot;&gt; &lt;label class=&quot;control-label col-md-4 text-right&quot;&gt;用户名:&lt;/label&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control username&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group clearfix&quot;&gt; &lt;label class=&quot;control-label col-md-4 text-right&quot;&gt;密码:&lt;/label&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control userpwd&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group clearfix text-center&quot;&gt; &lt;button class=&quot;btn btn-success reg-btn&quot;&gt;立即注册&lt;/button&gt; &lt;a href=&quot;#login&quot; class=&quot;btn btn-info&quot;&gt;去登录&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--登录视图--&gt; &lt;div id=&quot;login&quot;&gt; &lt;div class=&quot;form-horizontal&quot;&gt; &lt;h3 class=&quot;text-center&quot;&gt;用户登录窗口&lt;/h3&gt; &lt;div class=&quot;form-group clearfix&quot;&gt; &lt;label class=&quot;control-label col-md-4 text-right&quot;&gt;用户名:&lt;/label&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control username&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group clearfix&quot;&gt; &lt;label class=&quot;control-label col-md-4 text-right&quot;&gt;密码:&lt;/label&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control userpwd&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group clearfix text-center&quot;&gt; &lt;button class=&quot;btn btn-success login-btn&quot;&gt;立即登录&lt;/button&gt; &lt;a href=&quot;#register&quot; class=&quot;btn btn-info&quot;&gt;去注册&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;mask&quot;&gt;&lt;/div&gt; &lt;script src=&quot;js/jquery-v1.12.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/md5.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/uuid.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/moment.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/todo.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 需要手写的js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307/*就是被引入的todo.js*//* 数据存储规划: 存储方式: localStorage 数据格式: json 对象 (字段名: todoList ) &#123; uid:注册时获取, store:[], //存储的数据 &#125; 详细的(每一条)数据格式: &#123; id : 编号, title:标题, crate_time:创建时间, status:状态 &#125; 完整的数据: &#123; uid:&#123; username:&quot;张三&quot;, store:[ &#123; id : 编号, title:标题, crate_time:创建时间, status:状态 &#125; ] &#125; &#125; *///初始化获取存储的数据var ToDoList = null;var uid = null; //当前用户UIDvar username = null;//当前用户名字var isLogin = false; //是否登录成功标识var hash = window.location.href.split(&quot;#&quot;).slice(-1)[0];//获取当前的hashfunction checkLogin()&#123; var loginStorage = window.sessionStorage.getItem(&quot;todoLogin&quot;); if(loginStorage)&#123; loginStorage = JSON.parse(loginStorage); isLogin = true; // 先暂时使用这个标识, 靠谱的做法会在登录成功的时候使用md5()随机生成一个 token 标识 ,每次加载页面时候开始对比 uid = loginStorage.uid; username = loginStorage.username; ToDoList = getStorage(); //首次渲染 render(); &#125; return false;&#125;checkLogin();//验证是否登录成功/** 判断是否登录业务:* 可以在登录成功之后存储一些登录标识 ,如果已经登录 ,则显示主体视图, 如果没有登录直接显示登录视图** 三个视图 = &gt;* #main* #register* #login** 路由的核心原理 : 如何知道去了哪? 通过获取url的hash值 判断 ,根据hash值切换对应的视图** 登录存储字段名: todoLogin* 数据结构:* &#123;* uid:,* username:* auth:true* &#125;* *//** * 注册逻辑: * 把注册信息 记录到本地存储 - &gt; 永久存储 * 数据字段名 : todoUser * 数据结构: * &#123; * 888:&#123; * uid:888, * username:张三, * usepwd:1223132 * &#125; * &#125; * * * */ //打开页面自动切换到login 视图 (需要判断是否登录) = &gt; 登录拦截 if(isLogin)&#123; window.location=&quot;#main&quot;; &#125;else&#123; if(hash!=&quot;register&quot;)&#123; window.location=&quot;#login&quot;; &#125; &#125; //获取对应视图容器 var main = document.getElementById(&quot;main&quot;); var register = document.getElementById(&quot;register&quot;); var login = document.getElementById(&quot;login&quot;); var mask = document.getElementById(&quot;mask&quot;);//监听hash值, 用于切换显示视图window.addEventListener(&quot;hashchange&quot;,function (e) &#123; console.log(&quot;hash切换了&quot;,e.newURL.split(&quot;#&quot;).slice(-1)[0]); // hash = e.newURL.split(&quot;#&quot;).slice(-1)[0]; //打开页面自动切换到login 视图 (需要判断是否登录) = &gt; 登录拦截 if(isLogin)&#123; view() &#125;&#125;)//定义一个方法用于显示视图function view()&#123; var hash = window.location.href.split(&quot;#&quot;).slice(-1)[0]; // console.log(hash); login.style.display=&quot;none&quot;; main.style.display=&quot;none&quot;; register.style.display=&quot;none&quot;; if(hash == &quot;login&quot;)&#123; login.style.display=&quot;block&quot;; mask.style.display=&quot;block&quot;; &#125;else if(hash==&quot;register&quot;)&#123; register.style.display=&quot;block&quot;; mask.style.display=&quot;block&quot;; &#125;else&#123; main.style.display=&quot;block&quot;; mask.style.display=&quot;none&quot;; &#125;&#125;view();//展示首次的视图//获取仓库数据function getStorage()&#123; var storage = window.localStorage.getItem(&quot;todoList&quot;); //获取的数据有可能是一个json字符串,还需要处理.. return storage?JSON.parse(storage):&#123; [uid]:&#123; username:username, store:[] &#125; &#125;;&#125;//写入存储function setStorage() &#123;//data只是写入的备忘录记录列表数据 //期间可能会有一些其他业务..... //写入到存储 var storage = JSON.stringify(ToDoList); window.localStorage.setItem(&quot;todoList&quot;,storage);&#125;//渲染数据的方法function render()&#123; var htmlStr= &quot;&quot;; if(uid in ToDoList)&#123; var data = ToDoList[uid].store;//需要渲染的列表数据 if(data.length == 0)&#123; htmlStr = &quot;&lt;tr&gt;&lt;td colspan=&#x27;5&#x27;class=&#x27;text-center&#x27;&gt;暂无代办事项...&lt;/td&gt;&lt;/tr&gt;&quot; &#125;else&#123; $.each(data,function (index,item) &#123; htmlStr+=&#x27;&lt;tr class=&quot;&#x27;+(item.status==0?&#x27;warning&#x27;:&#x27;success&#x27;)+&#x27;&quot; data-id=&quot;&#x27;+item.id+&#x27;&quot;&gt;\\n&#x27; + &#x27; &lt;td&gt;&#x27;+(index + 1)+&#x27;&lt;/td&gt;\\n&#x27; + &#x27; &lt;td&gt;&#x27;+item.title+&#x27;&lt;/td&gt;\\n&#x27; + &#x27; &lt;td&gt;&#x27;+(moment(item.create_time).format(&quot;YYYY-MM-DD HH:mm:ss&quot;))+&#x27;&lt;/td&gt;\\n&#x27; + &#x27; &lt;td&gt;&#x27;+(item.status==0?&#x27;&lt;span class=&quot;text-info glyphicon glyphicon-warning-sign&quot;&gt;&lt;/span&gt;&#x27;:&#x27;&lt;span class=&quot;text-success glyphicon glyphicon-ok&quot;&gt;&lt;/span&gt;&#x27;)+&#x27;&lt;/td&gt;\\n&#x27; + &#x27; &lt;td&gt;&#x27; +(item.status==0?&#x27;&lt;button class=&quot;btn btn-success btn-xs complete&quot;&gt;标记已完成&lt;/button&gt;&#x27;:&#x27;&lt;button class=&quot;btn btn-info btn-xs complete&quot;&gt;标记未完成&lt;/button&gt;&#x27;)+ &#x27;&lt;button class=&quot;btn btn-danger btn-xs delete&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;\\n&#x27; + &#x27; &lt;/tr&gt;&#x27;; &#125;) &#125; &#125;else&#123; htmlStr = &quot;&lt;tr&gt;&lt;td colspan=&#x27;5&#x27;class=&#x27;text-center&#x27;&gt;暂无代办事项...&lt;/td&gt;&lt;/tr&gt;&quot; &#125; //插入 $(&quot;tbody&quot;).html(htmlStr);&#125;//添加事件$(&quot;#addToDo&quot;).click(function()&#123; if(!(uid in ToDoList))&#123; //判断当前数据是否存在 ToDoList[uid] = &#123; username:username, store:[] &#125; &#125; var txt = $(&quot;#txt&quot;).val(); var id = ToDoList[uid].store.slice(-1);//截取最后一个 id = id.length&gt;0?(id[0].id)*1+1:1; console.log(id); //追加数据 ToDoList[uid].store.push(&#123; id:id, title:txt, create_time:new Date().getTime(), status:0 //0 未完成 1 已完成 &#125;); //存储到本地 setStorage(); //渲染更新 render();&#125;)//完成$(&quot;body&quot;).on(&quot;click&quot;,&quot;.complete&quot;,function () &#123; var id = $(this).parents(&quot;tr&quot;).data(&quot;id&quot;); ToDoList[uid].store.forEach(function(item)&#123; if(item.id == id)&#123; item.status = item.status==0?1:0; &#125; &#125;); //从新存储到本地 setStorage(); //渲染页面 render();&#125;)//删除$(&#x27;body&#x27;).on(&quot;click&quot;,&quot;.delete&quot;,function () &#123; var id = $(this).parents(&quot;tr&quot;).data(&quot;id&quot;); ToDoList[uid].store.forEach(function (item,index) &#123; if(item.id == id)&#123; ToDoList[uid].store.splice(index,1); &#125; &#125;) //从新存储到本地 setStorage(); //渲染页面 render();&#125;)/*_____________________________注册业务____________________________________*/$(&quot;.reg-btn&quot;).click(function () &#123; var username = $(&quot;#register .username&quot;).val(); var userpwd = $(&quot;#register .userpwd&quot;).val(); userpwd = md5(md5(userpwd)+&quot;WT18&quot;);//执行md5算法加密 var uid = uuid();//生成uuid //先取出原有的数据 var userData = window.localStorage.getItem(&quot;todoUser&quot;); userData = userData?JSON.parse(userData):&#123;&#125;; //添加到用户数据 userData[uid] = &#123; uid:uid, username:username, userpwd:userpwd &#125; //写入到本地存储 localStorage.setItem(&quot;todoUser&quot;,JSON.stringify(userData));&#125;)/*_____________________________登录业务___________________________________*/$(&quot;.login-btn&quot;).click(function () &#123; var username = $(&quot;#login .username&quot;).val(); var userpwd = $(&quot;#login .userpwd&quot;).val(); userpwd = md5(md5(userpwd)+&quot;WT18&quot;);//执行md5算法加密 //先取出原有的数据 var userData = window.localStorage.getItem(&quot;todoUser&quot;); if(!userData)&#123; alert(&quot;请先注册账号!&quot;); return false; &#125; userData = JSON.parse(userData); //判断用户名密码是否一样 // console.log(userData); for(key in userData)&#123; var item = userData[key]; if(item.username == username &amp;&amp; item.userpwd == userpwd)&#123; isLogin = true; uid = item.uid; username = item.username; window.location=&quot;#main&quot;; var token = md5(md5(uid)+username+&quot;WT18&quot;); //写入登录成功标识 window.sessionStorage.setItem(&quot;todoLogin&quot;,JSON.stringify(&#123; uid:item.uid, username:item.username, auth:token &#125;)); getStorage(); //渲染当前用户的数据 render(); return false; &#125; &#125; if(!isLogin)&#123; alert(&quot;登录失败!!!!&quot;); &#125;&#125;)/*____________________________退出登录____________________________________*/$(&quot;.logout&quot;).click(function () &#123; window.sessionStorage.removeItem(&quot;todoLogin&quot;); isLogin = false; window.location.href=&quot;#login&quot;;&#125;) 其他笔记123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102存储: 存储用户或者程序数据1.web浏览器端存储: 1.Cookie 2.浏览器的缓存 (H5新增) 3.离线缓存 4.localStorage 5.sessionStorage 浏览器数据库 (现在已经放弃了) 6.indexDB (还可以用 ,但是操作繁琐) 7.websql2.服务器端存储: session--------------------------------------------------------------------------浏览器的缓存: 可以减少http请求 ,降低服务器压力 &#x3D; &gt; 浏览器自带功能 浏览器默认会对一些静态资源文件进行缓存, 如果下一次请求一个相同地址(url)的资源时,会优先从缓存中读取, 如果缓存没有则重新从服务器下载 不足:因为浏览器会对一些历史的静态资源文件进行缓存 (css,js,图片之类的) ,html文件 不缓存 ,如果网站内容(css, js)有更新, 用户再次访问该站点时,检测到一样的url地址,则直接从缓存中使用曾经缓存的文件,而不是下载最新的 解决方案: 因为浏览器只是根据url地址 来检测是否有缓存 , 所以一般的项目中都会在发布新版本的时候改动一下文件url地址 常见做法: 1. 直接在引入的静态资源文件后添加一些参数 v?&#x3D;1.2 t&#x3D;201910260959 .... 2. 直接把静态资源文件放在对应的版本号的文件目录下 缓存的时间: 是可以通过后台的响应包头配置的 可以根据修改时间 或者一定时间的缓存时间--------------------------------------------------------------------------cookie :(存储一些安全级别不需要特别的高数据) cookie诞生: 因为http协议是一个无状态协议(在互联上访问无法追踪用户身份标识) , cookie就是用于当作一个http请求的用户标识 特征: 1.存储在浏览器客户端 (需要一定的服务器环境下才能使用) &#x3D; &gt; 可以使用js脚本获取 2.cookie 不能跨站点(跨域)使用 : 例如baidu.com 站点下的cookie 不能被qq.com 访问的 3.存储cookie的时候都是按站点存储,一般来说一个站点下可能最多就是20条(170左右)记录 ,一个浏览器最多存储 400条左右(具体情况得视浏览器而定) ,单条不超过4kb(现在1704字节) 4.cookie会随着http请求 ,一起通过包头发送给对应服务器的后台(当然理论上也是安全的,访问百度时只会发送百度站点下的cookie) 5.cookie可以设置存活时间(周期) ,时间到会自动失效 ,如果没有设置存活时间会在浏览关闭后自动失效 6.因为存储在浏览器端,不太安全,容易被一些恶意程序盗取 session : (存储一些安全要求级别比较高的数据) 1.存储在服务端的 &#x3D; &gt; 不能使用js获取 2.存储的数据比较安全,不会被盗取 3.浏览器打开页面则创建会话,当前浏览器关闭自动销毁 ------------------------------------------------------------------------- (H5新增)localStorage 本地存储 (永久存储) 除非手动删除 特征: 1.永久存储 ,除非删除删除不然一直存储在硬盘上 2.可以存储大量的数据 (css , js ,base64图片) 3.不允许跨域访问 4.接口的使用非常方便 5.只要是同一个站点下 ,多个标签页之间存储的数据是共享的 使用场景: 1.经常把一些常用,不怎么更新的css, js 存储 2.手机app 应用 存储大量的用户数据 3.微信小程序 用于存储应用的数据 无论什么存储方式 : 都只能存储字符串 sessionStorage: 会话存储 ,浏览器关闭即销毁 (可以用来存储一些数据安全级别较高的数据)------------------------------------------------------------------------md5 算法加密: 对称型 ,不可解密 : 按照相同的加密算法和被加密的明文, 使用md5加密后 , 密文一样的------------------------------------------------------------------------离线缓存: 在离线(无网络)状态下 , 可以继续使用应用中在有网络的时候所缓存的本地文件 1.需要先服务器配置中 ,添加配置: 以apache 服务器为例 E:\\xampp\\apache\\conf\\mime.types (服务器支持的文件类型) &#x3D; &gt; 添加一个文件类型 (默认添加) text&#x2F;cache-manifest 2.在网站根目录节点下 ,创建一个扩展名为: .appcache 文件 - &gt; 用于编写需要缓存文件的清单(告诉浏览在有网络的时候需要去缓存哪些文件) manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进&#96;行缓存 (需要缓存) NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存(不能缓存) FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 如果缓存找不到就跳指定页面 3.设置html 关联对应的缓存清单 [ chrome 浏览器需要在https 协议才可以使用离线缓存 ] 请留心缓存的内容。 一旦文件被缓存，则浏览器会继续展示已缓存的版本，即使您修改了服务器上的文件。为了确保浏览器更新缓存，您需要更新 manifest 文件。 注释：浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。--------------------------------------------------------------------------------------------- 说到存储 , 除以上的存储以外 : 更多是在服务端 , 有各种数据库 : mysql , oracle , redis , mongoDB ...","categories":[],"tags":[{"name":"Storage存储","slug":"Storage存储","permalink":"https://1314xulujin.github.io/tags/Storage%E5%AD%98%E5%82%A8/"}]},{"title":"BootStrap框架","slug":"BootStrap框架基本使用","date":"2019-12-18T07:06:32.000Z","updated":"2020-06-21T13:10:21.235Z","comments":true,"path":"2019/12/18/BootStrap框架基本使用/","link":"","permalink":"https://1314xulujin.github.io/2019/12/18/BootStrap%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"BootStrap框架 ​ 来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。基于H5标准 , 秉承移动端优先 构建移动端和PC响应式网站 中文文档地址: https://v3.bootcss.com/布局容器:​ .container 布局主要容器 , 跟以前的wrap一样的 ​ .container-fluid 满屏的容器 , 用于 100% 宽度，占据全部视口（viewport）的容器 框架默认主题风格颜色:1234567891011default 灰色primary 蓝色success 绿色info 浅蓝色warning 橙色danger 红色 状态样式类:1234567.active 激活.success.info.danger.warning.disabled 浮动类:123456.clearfix 清除浮动.pull-left 左浮动.pull-right 右浮动不能用于导航条组件中排列导航条中的组件时可以使用这些工具类：.navbar-left 或 .navbar-right 其他:12345678.center-block 块级元素居中关闭按钮: &lt;button class&#x3D;&quot;close&quot;&gt;&lt;span&gt;&amp;times;&lt;&#x2F;span&gt;&lt;&#x2F;button&gt;三角符号: &lt;span class&#x3D;&quot;caret&quot;&gt;&lt;&#x2F;span&gt;显示 &#x2F; 隐藏 : .show 和 .hidden 图片替换: .text-hide 文字隐藏 ,只显示背景图片 栅格系统:一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列123456789行 (.row)列 (.col-*) 按屏幕划分列名: .col-xs-1 .... -- .col-xs-12 (12个) .col-sm-1 .... -- .col-sm-12 (12个) .col-md-1 .... -- .col-md-12 (12个) .col-lg-1 .... -- .col-lg-12 (12个) 屏幕种类划分:通过下表可以详细查看 Bootstrap 的栅格系统是如何在多种屏幕设备上工作的。 超小屏幕 手机 (&lt;768px) xs 小屏幕 平板 (≥768px) sm 中等屏幕 桌面显示器 (≥992px) md 大屏幕 大桌面显示器 (≥1200px) lg 栅格系统行为 总是水平排列 开始是堆叠在一起的，当大于这些阈值时将变为水平排列C .container 最大宽度 None （自动） 750px 970px 1170px 类前缀 .col-xs- .col-sm- .col-md- .col-lg- 列（column）数 12 最大列（column）宽 自动 ~62px ~81px ~97px 槽（gutter）宽 30px （每列左右均有 15px） 可嵌套 是 偏移（Offsets） 是 列排序 是 列偏移(48个):1234.col-xs-offset-1 -- .col-xs-offset-12.col-sm-offset-1 -- .col-sm-offset-12.col-md-offset-1 -- .col-md-offset-12.col-lg-offset-1 -- .col-lg-offset-12 列排序(96个):12col-*-push-*: 48个col-*-pull-*: 48个 排版1.重写标题标签样式 , 浏览器常见标签的默认样式重置2.文本样式(text):12345678910111213141516171819202122232425对齐:.text-left 文本左对齐.text-center 居中.text-right 右对齐.text-justify 两端对齐.text-nowrap 不换行改变大小写:.text-lowercase 文本小写.text-uppercase 大写.text-capitalize 首字母大写文本颜色:.text-primary .text-info.text-success.text-warning.text-danger背景色:.bg-primary .bg-info.bg-success.bg-warning.bg-danger 3.列表123.list-unstyled 无列表样式.list-inline 行内列表.dl-horizontal 水平排列的自定义列表 4.表格(table)1234567.table 表格的基础样式类.table-bordered 带边框.table-hover 鼠标悬停背景色变化.table-striped 条纹背景色.table-condensed 紧凑表格.table-responsive 响应式表格 , 需要把这个给到嵌套表格的div 即可 5.表单12345678910111213141516form:.form-horizontal水平表单.form-inline 内敛表单.form-group 表单组 (包裹label 和 input).form-control 一般是给表单元素添加(input select textarea).control-label 给label设置的表单的校验状态: 每项表单组验证状态: .has-success &#x2F; .has-warning &#x2F; .has-error 带图标: 每项表单组.has-feedback .form-control-feedback 6.按钮: 为 &lt;a&gt;、&lt;button&gt; 或 &lt;input&gt; 元素添加按钮类（button class）即可使用 Bootstrap 提供的样式123456789101112131415161718192021.btn 按钮颜色: .btn-primary .btn-success .btn-info .btn-warning .btn-danger .btn-link .btn-default按钮大小: .btn-xs .btn-sm .btn-lg按钮组(.btn-group):块级按钮:.btn-block 7.响应式工具: (处理移动屏幕元素内容选择性可见)通过单独或联合使用以下列出的类，可以针对不同屏幕尺寸隐藏或显示页面内容。 超小屏幕手机 (&lt;768px) 小屏幕平板 (≥768px) 中等屏幕桌面 (≥992px) 大屏幕桌面 (≥1200px) .visible-xs-* 可见 隐藏 隐藏 隐藏 .visible-sm-* 隐藏 可见 隐藏 隐藏 .visible-md-* 隐藏 隐藏 可见 隐藏 .visible-lg-* 隐藏 隐藏 隐藏 可见 .hidden-xs 隐藏 可见 可见 可见 .hidden-sm 可见 隐藏 可见 可见 .hidden-md 可见 可见 隐藏 可见 .hidden-lg 可见 可见 可见 隐藏 注释: * 代表显示的类型: inline / inline-block / block 8.打印类:和常规的响应式类一样，使用下面的类可以针对打印机隐藏或显示某些内容。 class 浏览器 打印机 .visible-print-block .visible-print-inline .visible-print-inline-block 隐藏 可见 .hidden-print 可见 隐藏 .visible-print 类也是存在的，但是从 v3.2.0 版本开始不建议使用。它与 .visible-print-block 类大致相同，除了 &lt;table&gt; 相关元素的特殊情况外。 1.下拉菜单组件 (dropdown)123456789101112&lt;div class=&quot;dropdown&quot;&gt; &lt;button class=&quot;btn btn-success&quot; data-toggle=&quot;dropdown&quot;&gt;下拉菜单&lt;/button&gt; &lt;ul class=&quot;dropdown-menu dropdown-menu-right&quot;&gt; &lt;li class=&quot;dropdown-header&quot;&gt;Dropdown header&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级菜单4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级菜单5&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 2.输入框组(input-group)1234&lt;div class=&quot;input-group&quot;&gt; &lt;label class=&quot;input-group-addon&quot;&gt;商品&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt;&lt;/div&gt; 3.导航(nav):1nav 4.导航条(navbar)123456789101112131415161718192021.navbar (.navbar-default 默认灰色背景).navbar-fixed-top 固定在顶部 .navbar-fixed-bottom 固定在底部.navbar-inverse 反色导航(黑色) 导航条中的导航 (需要折叠展开: 使用.collapse.navbar-collapse 父级包裹) .nav.navbar-nav 导航条的表单 .navbar-form 汉堡按钮 &lt;button class=&quot;navbar-toggle&quot;&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;&lt;/button&gt;汉堡按钮功能 : data-toggle=&quot;collapse&quot; 设置按钮的开关功能, 调用collapse插件 data-traget=&quot;.navbar-collapse&quot; 设置触发的目标元素 ,用于折叠对象 5.进度条(progress)1","categories":[],"tags":[{"name":"BootStrap","slug":"BootStrap","permalink":"https://1314xulujin.github.io/tags/BootStrap/"}]},{"title":"12月06日14道面试题及其答案","slug":"12月06日14道面试题及其答案","date":"2019-12-06T07:35:55.000Z","updated":"2021-11-03T08:46:31.061Z","comments":true,"path":"2019/12/06/12月06日14道面试题及其答案/","link":"","permalink":"https://1314xulujin.github.io/2019/12/06/12%E6%9C%8806%E6%97%A514%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E5%85%B6%E7%AD%94%E6%A1%88/","excerpt":"","text":"12月06日 14道面试题及其答案1.http请求1234http请求由状态行，请求头，请求正文三部分组成： ①状态行：包括请求方式Method，资源路径URl，协议版本Version； ②请求头：包括一些访问的域名，用户代理，Cookie等等信息； ③请求正文：HTTP请求的数据(发送给服务器)； 2.http请求方式常用 ① get 请求指定页面的信息，并返回实体主体 ② post 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据包含在 请求体中。post请求可能会导致新的资源的建立和/或已有的资源的修改 不常用 ③ head 类似get请求方式，只不过返回的响应中没有具体的内容，用于获取包头 ④ put 从客户端向服务器传送的数据取代指定的文档的内容 ⑤ delete 请求服务器删除指定的页面 ⑥ connect HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 ⑦ options 允许客户端查看服务器的性能 ⑧ trace 回显服务器收到的请求，主要用于测试或诊断 3.最常用的http状态码​ ①200 =&gt; 请求数据成功 ②304 =&gt; 请求内容与之前请求过的内容一样(暂未修改) ③404 =&gt; 服务器找不到请求的网页 ④500 =&gt; 服务器内部错误 4.http和https的概念http：HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议 https：HTTPS（安全超文本传输协议）是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的 安全版。 5.http与https的区别https协议需要到ca申请书，一般证书是需要付费的。 http是超文本传输协议，信息是不加密传输的，https则在其添加了ssl加密协议，是具有安全性的ssl加密传输协议 6.let和var的区别let定义的变量是块级变量。var定义的变量是全局变量或者函数变量。let定义的变量只对它所在的区域内有效，而var定义的变量范围最小是一个函数之内，最大则是全局。 7.let和const的区别​ let声明的变量可以被修改，值和类型都可修改 const声明的变量不可被修改，一旦声明，就必须初始化 8.什么是闭包​ 在一个函数内嵌套一个函数，那么那个被嵌套的函数就是&quot;闭包&quot;函数 9.js判断一个对象属于哪一个类obj.constructor (constructor)用于返回实例对象的构造函数（可以理解为这个对象是由哪个模具造出来的） PObj.prototype.isPrototypeOf(obj) (isPrototypeOf)判断一个实例对象是否指向该个构造函数的原型对象 10.什么是跨域，说出几种跨域的方法跨域：请求域与当前域中 , 只要有: 【端口 , 协议 , 域名】 任何一项不同 ,则视为跨域. 跨域的方法： ①jsonp ②cors ③proxy ④(H5新增)websocket / postMessage ⑤iframe 11.什么是函数的节流和防抖函数的节流：确保函数在特定的时间内至多执行一次(假如这个时间为300ms，每300ms就执行一次操作，这样就减少了操作次数) 函数的防抖：函数在特定的时间内不被调用后执行(假如这个时间在300ms，这300ms内函数没调用就执行操作) 12.flex布局和传统布局有什么区别传统的布局，基于盒子模型，依赖display属性，position属性，float属性 flex布局为&quot;弹性布局&quot;，为盒子模型提供最大的灵活性(盒子定为flex后，子元素的float，clear，vertical-align会失效) 13.举例前端性能优化1.资源压缩合并，减少http请求 ①合并图片（css sprites）、CSS和JS文件合并、CSS和JS文件压缩 ②图片较多的页面也可以使用 lazyLoad 等技术进行优化。 2.非核心代码异步加载 ①动态脚本加载 ②defer ③async 3.利用浏览器缓存 ①强缓存 ②协商缓存 4.使用CDN 5.DNS预解析（dns-prefetch） 14.原型链和作用域链作用域是针对变量的，作用域的特点就是，先在自己的变量范围中查找，如果找不到，就会沿着作用域往上找 原型链是针对构造函数的，比如我先创建了一个函数，然后通过一个变量new了这个函数，那么这个被new出来的函数就会继承创建出来的那个函数的属性，然后如果我访问new出来的这个函数的某个属性，但是我并没有在这个new出来的函数中定义这个变量，那么它就会往上（向创建出它的函数中）查找，这个查找的过程就叫做原型链。","categories":[],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"HTML5+css3","slug":"HTML5+css3","date":"2019-11-16T01:19:49.000Z","updated":"2020-06-21T13:10:21.247Z","comments":true,"path":"2019/11/16/HTML5+css3/","link":"","permalink":"https://1314xulujin.github.io/2019/11/16/HTML5+css3/","excerpt":"","text":"H5+CSS31.HTML5基础①新增的网页布局结构1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--H5新增的结构化标签: 增强代码的语义化 ,提供代码可读性, 提升seo优化的友好度--&gt; &lt;header&gt; &lt;div&gt;这是一个网页的头部 , 引导信息块&lt;/div&gt; &lt;nav&gt;&lt;div&gt;&lt;/div&gt;&lt;/nav&gt; &lt;/header&gt; &lt;section&gt; &lt;aside&gt;左侧&lt;/aside&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;右侧&lt;/aside&gt; &lt;/section&gt; &lt;footer&gt;这是底部&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; ②新增的网页元素123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;完整HTML标签： https://www.w3school.com.cn/html5/html5_reference.asp&lt;marquee direction=&quot;down&quot; width=&quot;250&quot; height=&quot;200&quot; behavior=&quot;alternate&quot; style=&quot;border:solid&quot;&gt; &lt;marquee behavior=&quot;alternate&quot;&gt; This text will bounce &lt;/marquee&gt;&lt;/marquee&gt; &lt;div&gt; &lt;time&gt;7:30&lt;/time&gt; &lt;span&gt;7:30&lt;/span&gt; &lt;progress value=&quot;50&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; &lt;mark&gt;这是一个自带背景的男人&lt;/mark&gt; &lt;input type=&quot;text&quot; list=&quot;abc&quot;&gt; &lt;datalist id=&quot;abc&quot;&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;/datalist&gt; &lt;/div&gt;&lt;iframe src=&quot;http://www.baidu.com&quot; frameborder=&quot;0&quot; width=&quot;1440&quot; height=&quot;700&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; ③新增的全局属性1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; spellcheck=&quot;true&quot;&gt; &lt;p contenteditable=&quot;true&quot;&gt;这是一段文字&lt;/p&gt; &lt;p style=&quot;display: none;&quot;&gt;这是一段文字内容1&lt;/p&gt; &lt;p hidden&gt;这是一段文字内容2&lt;/p&gt; &lt;p&gt;这是一段文字内容3&lt;/p&gt; &lt;p&gt;这是一段文字内容4&lt;/p&gt; &lt;p&gt;这是一段文字内容5&lt;/p&gt; &lt;p&gt;这是一段文字内容6&lt;/p&gt; &lt;p&gt;这是一段文字内容7&lt;/p&gt; &lt;p&gt;这是一段文字内容8&lt;/p&gt; &lt;p&gt;这是一段文字内容9&lt;/p&gt; &lt;p&gt;这是一段文字内容10&lt;/p&gt; &lt;p&gt;这是一段文字内容11&lt;/p&gt; &lt;p&gt;这是一段文字内容12&lt;/p&gt; &lt;p&gt;这是一段文字内容13&lt;/p&gt; &lt;p&gt;这是一段文字内容14&lt;/p&gt; &lt;p&gt;这是一段文字内容15&lt;/p&gt; &lt;p&gt;这是一段文字内容16&lt;/p&gt; &lt;p&gt;这是一段文字内容17&lt;/p&gt; &lt;p&gt;这是一段文字内容18&lt;/p&gt; &lt;p&gt;这是一段文字内容19&lt;/p&gt; &lt;p&gt;这是一段文字内容20&lt;/p&gt; &lt;script&gt; //开启设计模式 document.designMode=&quot;on&quot;; // off &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ④tabIndex叠至次序12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 网页可交互元素 (a / input / select / checkbox / radio) + 网页的地址栏 &lt;a href=&quot;&quot; tabindex=&quot;5&quot;&gt;百度&lt;/a&gt; &lt;a href=&quot;&quot; tabindex=&quot;4&quot;&gt;淘宝&lt;/a&gt; &lt;a href=&quot;&quot; tabindex=&quot;3&quot;&gt;京东&lt;/a&gt; &lt;a href=&quot;&quot; tabindex=&quot;2&quot;&gt;天猫&lt;/a&gt; &lt;a href=&quot;&quot; tabindex=&quot;1&quot;&gt;腾讯&lt;/a&gt; tabIndex : 数值越小越先 获得焦点 (默认 1)&lt;/body&gt;&lt;/html&gt; ⑤css3新增选择器123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /*1.:first-of-type 匹配在当前选择器下 ,当前层级中第一个指定类型的元素*/ /*#box p:first-of-type&#123;*/ /*color: red;*/ /*&#125;*/ /*2.:last-of-type 匹配在当前选择器下 ,当前层级中最后一个指定类型的元素*/ /*#box p:last-of-type&#123;*/ /*color: green;*/ /*&#125;*/ /*3. :first-child 匹配在当前选择器下 ,当前层级中第一个子元素*/ #box p:first-child&#123; background: red; &#125; /*4. :last-child 匹配在当前选择器下 ,当前层级中最后一个子元素*!*/ #box p:last-child&#123; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div&gt; &lt;p&gt;这是一个p标签123&lt;/p&gt; &lt;p&gt;这是一个p标签1232&lt;/p&gt; &lt;div&gt; &lt;p&gt;这是一个p标签789&lt;/p&gt; &lt;p&gt;这是一个p标签7892&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;这是一个p标签456&lt;/p&gt; &lt;p&gt;这是一个p标签4562&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑥nth-child选择器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /*ul li:nth-child(2)&#123;*/ /*background: red;*/ /*&#125;*/ /** odd / even */ /*ul li:nth-child(even)&#123;*/ /*background: red;*/ /*&#125;*/ /** 2n 2n + 1 3n */ li:nth-child(4n)&#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;这是列表项1&lt;/li&gt; &lt;li&gt;这是列表项2&lt;/li&gt; &lt;li&gt;这是列表项3&lt;/li&gt; &lt;li&gt;这是列表项4&lt;/li&gt; &lt;li&gt;这是列表项5&lt;/li&gt; &lt;li&gt;这是列表项6&lt;/li&gt; &lt;li&gt;这是列表项7&lt;/li&gt; &lt;li&gt;这是列表项8&lt;/li&gt; &lt;li&gt;这是列表项9&lt;/li&gt; &lt;li&gt;这是列表项10&lt;/li&gt; &lt;li&gt;这是列表项11&lt;/li&gt; &lt;li&gt;这是列表项12&lt;/li&gt; &lt;li&gt;这是列表项13&lt;/li&gt; &lt;li&gt;这是列表项14&lt;/li&gt; &lt;li&gt;这是列表项15&lt;/li&gt; &lt;li&gt;这是列表项16&lt;/li&gt; &lt;li&gt;这是列表项17&lt;/li&gt; &lt;li&gt;这是列表项18&lt;/li&gt; &lt;li&gt;这是列表项19&lt;/li&gt; &lt;li&gt;这是列表项20&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; ⑦after与before伪类1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;style&gt; p::before&#123; display: inline-block; width: 12px; height: 12px; background: red; font-size: 12px; /*content: &quot;￥&quot;;*/ /*//元素属性指定内容*/ /*content:attr(abc);*/ content: &quot;&quot;; /* 即使没有内容 ,也需要加 content 属性*/ &#125; p::after&#123; content: &quot;&quot;; display: inline-block; width: 12px; height: 12px; background: green; &#125; &lt;/style&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p abc=&quot;哈哈&quot;&gt;50.00&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; ⑧after可以用于清除浮动12345678910111213141516171819202122232425262728293031323334353637&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 1200px; border: 2px solid red; &#125; .clearfix::after&#123; content: &quot;&quot;; display: block; visibility: visible; clear: both; &#125; .container div&#123; float: left; width: 300px; height: 200px; background: green; margin: 0 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑨伪类对象选择器1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .p1::first-letter&#123; color: red; font-size: 20px; font-weight: bold; &#125; .p2&#123; width: 200px; height: 300px;border: 1px solid red; &#125; .p2::first-line&#123; color: purple; &#125; .p2::selection&#123; background: darkorange; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;p1&quot;&gt;教育改变生活!&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;啊哈哈哈啊哈大萨达撒多撒多所大撒多多撒多撒多撒撒多撒大多所撒多sad撒多大所大所多啊是的飒飒大的萨达&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; target伪类制作一个无js的轮播图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; padding:0; margin:0; &#125; ul,li&#123; list-style:none; &#125; .container&#123; width:730px; height:454px; margin:50px auto; &#125; .slide&#123; position:relative; width:730px; height:454px; overflow:hidden; &#125; .slide-img li&#123; display:none; &#125; .slide-img li.active&#123; display:block; &#125; .slide-img a&#123; display:block; &#125; .slide-page&#123; position:absolute; width:100%; text-align:center; bottom:20px; &#125; .slide-page li&#123; display:inline-block; width:26px; height:26px; line-height:26px; background:#f1f1f1; color:#666; cursor:pointer; border-radius:50%; &#125; .slide-page li.active&#123; background-color:#ff3c3c; color:#fff; &#125; .controls&#123; position:absolute; top:50%; margin-top:-25px; width:50px; height:50px; text-align:center; font-size:30px; line-height:40px; font-family:&quot;幼圆&quot;; text-decoration:none; background:rgba(0,0,0,.5); color:#fff; /*display:none;*/ opacity:0; transition:all 0.35s; &#125; .slide:hover .controls&#123; /*display:block;*/ opacity:1; &#125; .controls.prev&#123; border-radius:0 50% 50% 0; text-indent:10px; left:-20px; &#125; .controls.next&#123; right:-20px; text-indent:-10px; border-radius:50% 0 0 50%; &#125; .slide-img li:target&#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;!--轮播图容器--&gt; &lt;div class=&quot;slide&quot;&gt; &lt;!--轮播图图片容器--&gt; &lt;ul class=&quot;slide-img&quot;&gt; &lt;li id=&quot;slide1&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/focus.jpg&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li id=&quot;slide2&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/focus1.jpg&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li id=&quot;slide3&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/focus2.jpg&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li id=&quot;slide4&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/focus3.jpg&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li id=&quot;slide5&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/focus4.jpg&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 轮播图的按钮容器--&gt; &lt;ul class=&quot;slide-page&quot;&gt; &lt;li&gt;&lt;a href=&quot;#slide1&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#slide2&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#slide3&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#slide4&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#slide5&quot;&gt;5&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.HTML5表单①表单类型1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 1. text 2.password 3.radio 4.checkbox 5.submit 6.reset 7.file 8.image 9.button &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; ②新增表单类型1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot;&gt; 邮箱: &lt;input type=&quot;email&quot;&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;form action=&quot;&quot;&gt; url: &lt;input type=&quot;url&quot;&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;form action=&quot;&quot;&gt; number: &lt;input type=&quot;number&quot; max=&quot;100&quot; min=&quot;16&quot; step=&quot;0.01&quot;&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;form action=&quot;&quot;&gt; range: &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;50&quot;&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;form action=&quot;&quot;&gt; search: &lt;input type=&quot;search&quot;&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ③表单-日期选择器123456789101112131415161718&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;date: &lt;input type=&quot;date&quot;&gt;&lt;/p&gt; &lt;p&gt;month: &lt;input type=&quot;month&quot;&gt;&lt;/p&gt; &lt;p&gt;week: &lt;input type=&quot;week&quot;&gt;&lt;/p&gt; &lt;p&gt;time: &lt;input type=&quot;time&quot;&gt;&lt;/p&gt; &lt;p&gt;datetime: &lt;input type=&quot;datetime&quot;&gt;&lt;/p&gt; &lt;p&gt;datetime-local: &lt;input type=&quot;datetime-local&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; ④新增表单属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; input::placeholder&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot; autocomplete=&quot;on&quot;&gt; &lt;p&gt;手机号码: &lt;input type=&quot;text&quot; pattern=&quot;^1[3-9]\\d&#123;9&#125;$&quot;&gt;&lt;/p&gt; &lt;p&gt;姓名: &lt;input type=&quot;url&quot; name=&quot;username&quot; required placeholder=&quot;请输入姓名...&quot;&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=&quot;email&quot; name=&quot;userpwd&quot; &gt;&lt;/p&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;hr&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot; autocomplete=&quot;on&quot; novalidate&gt; &lt;p&gt;姓名: &lt;input type=&quot;url&quot; name=&quot;username&quot; autofocus&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=&quot;email&quot; name=&quot;userpwd&quot; &gt;&lt;/p&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; input::placeholder&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot; autocomplete=&quot;on&quot;&gt; &lt;p&gt;手机号码: &lt;input type=&quot;text&quot; pattern=&quot;^1[3-9]\\d&#123;9&#125;$&quot;&gt;&lt;/p&gt; &lt;p&gt;姓名: &lt;input type=&quot;url&quot; name=&quot;username&quot; required placeholder=&quot;请输入姓名...&quot;&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=&quot;email&quot; name=&quot;userpwd&quot; &gt;&lt;/p&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;hr&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot; autocomplete=&quot;on&quot; novalidate&gt; &lt;p&gt;姓名: &lt;input type=&quot;url&quot; name=&quot;username&quot; autofocus&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=&quot;email&quot; name=&quot;userpwd&quot; &gt;&lt;/p&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ⑤validityState对象1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;#&quot;&gt; &lt;input type=&quot;url&quot; id=&quot;txt&quot;&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script&gt; //querySelector(选择器) 返回第一个选择器中匹配的元素对象 //querySelectorAll(选择器) 所有选择器中匹配的元素集合 //ValidityState 对象 =&gt; 包含当前表单元素的验证状态 (告知我们它哪里不对,不符合要求) var txt = document.querySelector(&quot;#txt&quot;); console.dir(txt.validity); /*** * 只要通过表单验证后 ,对应的表单会有ValidityState状态 : * ValidityState : * valueMissing :true =&gt; 值为空 ，false 值不为空 * typeMismatch : true =&gt; 输入的内容类型, 与表单设定的类型不匹配 * patternMismatch : true = &gt; 输入的内容类型 ,与设定的正则不匹配 * * tooLong 输入的长度过长 * tooShort 输入的长度过短 * * stepMismatch 输入的值与设定的step 不符合 * rangeOverflow 输入的值大于设定的最大值 * rangeUnderflow 输入的值小于设定的最小值 * * customError 使用自定义验证错误提示 * * valid:true 表单验证通过 , false 不通过 */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ⑥querySelectorAll()与getElementsByClassName的区别12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;这是列表项1&lt;/li&gt; &lt;li&gt;这是列表项2&lt;/li&gt; &lt;li id=&quot;li3&quot;&gt;这是列表项3&lt;/li&gt; &lt;li&gt;这是列表项4&lt;/li&gt; &lt;li&gt;这是列表项5&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //动态获取 ,如果元素被删除 ,也会同步删除 var lis = document.getElementsByTagName(&quot;li&quot;); console.log(lis); //相当于快照,一旦获取了 ,那么就是一直当前的状态, 即使有任何变化也不影响 var lis2 = document.querySelectorAll(&quot;li&quot;); console.log(lis2); var ul = document.querySelector(&quot;ul&quot;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ⑦表单验证伪类12345678910111213141516171819202122232425&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; input:valid&#123; border: 1px solid green; &#125; input:invalid&#123; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot;&gt; &lt;p&gt;网址:&lt;input type=&quot;url&quot;&gt;&lt;/p&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ⑧纯css表单验证（无js）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; form&#123; width: 28%; padding: 10px; margin: 0 auto; &#125; label&#123; cursor: pointer; &#125; span&#123; margin-top: 20px; width: 320px; border: 1px solid red; color: red; line-height: 30px; text-align: center; &#125; form:valid&#123; border:5px solid transparent; &#125; form:invalid&#123; border:5px solid red; &#125; input:valid &#123; background-color: #ddffdd; &#125; input:invalid &#123; background-color: #ffdddd; &#125; input:required:invalid &#123; border-color: #C00000; &#125; input:required &#123; border-color: #800000; border-width: 3px; &#125; input:valid~span&#123; display: none; &#125; input:invalid~span &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;label for=&quot;url_input&quot;&gt;请输入网址:&lt;/label&gt; &lt;input type=&quot;url&quot; id=&quot;url_input&quot; /&gt; &lt;br /&gt; &lt;br /&gt; &lt;label for=&quot;email_input&quot;&gt;请输入Emaild地址:&lt;/label&gt; &lt;input type=&quot;email&quot; id=&quot;email_input&quot; required /&gt; &lt;span&gt;表单字段填写不规范，请检查后重新输入！&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 3.css3基础①圆角边框123456789101112131415161718192021222324252627282930313233343536&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; /*border-top-left-radius: 50%;*/ /*border-top-right-radius: 50%;*/ /*border-bottom-right-radius: 50%;*/ /*border-bottom-left-radius: 50%;*/ /*border-radius: 50%;*/ /*border-radius: 50% 0; !* 左上50% , 右上 0 , 右下50% 左下0*!*/ /*border-radius: 50% 100% 0;*/ /*border-radius: 50% 100% 0 50%;*/ -webkit-border-radius: 150px; -moz-border-radius: 150px; border-radius: 150px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ②边框图像123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; /*需要先设置边框*/ border-width: 20px; border-style: solid; /*1.设置边框图片的路径*/ border-image-source: url(&quot;border.png&quot;); /*2.设置边框图片的向内偏移量*/ /*border-image-slice: 26 13 13;*/ border-image-slice: 26; /*3.设置图片边框的宽度*/ border-image-width: 26px; /*4.设置图片边框 ,超出边框的量*/ border-image-outset: 6px; /*5.设置图片边框的平铺方式 :拉伸 stretch \\ 平铺 repeat \\ 铺满 round */ border-image-repeat: stretch; &#125; .box2&#123; margin-top: 50px; width: 400px; height: 240px; border-width: 10px 8px; border-style: solid; border-image: url(&quot;border_image_button.png&quot;) 10 8; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;ssssss&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;这是一个聊天气泡&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ③盒子阴影12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; margin: 50px auto; /*盒子阴影: 1.阴影的水平偏移距离 （必须） 2.阴影的垂直偏移距离 （必须） 3.阴影模糊程度 4.阴影在大小 5.阴影的颜色 6.阴影在方向：内阴影(inset) / 外阴影（ 默认不需要写） */ /*box-shadow: -20px 20px 10px 10px #666;*/ box-shadow: -5px 0px 10px royalblue,-10px 0px 10px deeppink,-15px 0px 10px green,-20px 0px 10px purple; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ④背景大小12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; border:5px dashed green; margin: 10px auto; &#125; .box:nth-child(1)&#123; background: url(&quot;bg_flower.gif&quot;) no-repeat ; background-size: cover; &#125; .box:nth-child(2)&#123; background: url(&quot;bg_flower.gif&quot;) no-repeat ; background-size: contain; &#125; .box:nth-child(3)&#123; background: url(&quot;bg_flower.gif&quot;) no-repeat ; /*background-size: 100% 50%;*/ background-size: 200px 150px; &#125; /*background 所有背景简写: background:#f00 url(../bg.jpg) no-repeat 0px 0px / 100% 50%; 1.颜色 2.图片 3.重复方式 4.背景定位 / 5.背景大小 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑤背景的区域12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; border:5px dashed green; margin: 10px auto; background: url(&quot;bg_flower.gif&quot;) no-repeat ; padding: 20px; &#125; .box:nth-child(1)&#123; /*设置背景从边框开始*/ background-origin: border-box; &#125; .box:nth-child(2)&#123; /*设置背景从内边距开始(默认)*/ background-origin: padding-box; &#125; .box:nth-child(3)&#123; /*设置背景从内容开始*/ background-origin: content-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑥背景裁剪1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; border:5px dashed green; margin: 10px auto; background: url(&quot;bg_flower.gif&quot;) no-repeat ; padding: 20px; background-origin: border-box; &#125; .box:nth-child(1)&#123; /*设置背景从裁剪到边框*/ background-clip: border-box; &#125; .box:nth-child(2)&#123; /*设置背景裁剪到内边距*/ background-clip: padding-box; &#125; .box:nth-child(3)&#123; /*设置背景裁剪到内容*/ background-clip: content-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑦背景线性渐变1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; border:5px dashed green; margin: 10px auto; border:1px solid red; &#125; .box:nth-child(1)&#123; /*background-image: linear-gradient(to right,red,green);*/ background-image: linear-gradient(90deg,red,green); &#125; .box:nth-child(2)&#123; background-image: linear-gradient(90deg,red 10%,yellow 30%,green 50%); &#125; .box:nth-child(3)&#123; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑧背景径向渐变12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; border:5px dashed green; margin: 10px auto; border:1px solid red; &#125; .box:nth-child(1)&#123; /*background-image: radial-gradient(circle,#ffff00,#0000ff);*/ /*background-image: radial-gradient(ellipse,#ffff00,#0000ff);*/ /*background-image: radial-gradient(50px 50px at center center,#ffff00,#0000ff);*/ /*background-image: radial-gradient(50px 50px at right center,#ffff00,#0000ff);*/ background-image: radial-gradient(50px 80px at 0px 50px,#ffff00,#0000ff); &#125; .box:nth-child(2)&#123; background-image: radial-gradient(100px 100px at center center,#ffff00 50px,#0000ff 100px); &#125; .box:nth-child(3)&#123; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑨文本效果1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; p&#123; color: #fff; /*文本阴影*/ text-shadow: -10px 0 10px gold,5px 0 10px #b2dba1; &#125; .box&#123; width: 100px; height: auto; border: 1px solid red; /*强制文本换行 ， 在浏览器中,如果是字母,会以为是一个长单词,所以即使容器宽度不够,也不会折行*/ word-wrap: break-word; &#125; .box2&#123; width: 100px; height: auto; border: 1px solid red; /*强制文本联换行*/ white-space:nowrap; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box2&quot;&gt;撒谎大所多撒撒所大奥所多洒洒水多撒多多撒大所大大奥所大多所大所撒多多撒多撒奥啥的飒飒的的撒的撒&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;sadaddaaklsdasjsadasdajdasdasdasdasdsadsaadasadsaasdsadsadsasaddsawqqfeffdasd&lt;/div&gt; &lt;p&gt;教育改变生活!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; ⑩自定义文字1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /*引入外部字体文件 ,可以实现字体自定义*/ /*1.设置自定义字体*/ @font-face &#123; font-family: abc; src: url(&quot;fonts/shimesone_personal-webfont.svg&quot;), url(&quot;fonts/shimesone_personal-webfont.eot&quot;), url(&quot;fonts/shimesone_personal-webfont.ttf&quot;), url(&quot;fonts/shimesone_personal-webfont.woff&quot;); font-style: normal; font-weight: normal; &#125; /*2.使用自定义字体*/ p&#123; font-family: abc; font-size: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is a long time!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; filter123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img&#123; /*filter: blur(100px);*/ /*filter: brightness(20%);*/ filter: saturate(100%); &#125; /*css其实就像ps一样*/ &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;a.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;&lt;/body&gt;&lt;/html&gt; 阿里矢量图标库123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;fonts/iconfont.css&quot;&gt; &lt;style&gt; @font-face &#123; font-family: icon; src: url(&quot;fonts/iconfont.svg&quot;), url(&quot;fonts/iconfont.eot&quot;), url(&quot;fonts/iconfont.ttf&quot;), url(&quot;fonts/iconfont.woff&quot;); &#125; span&#123; font-family: icon; font-size: 500px; &#125; span:hover&#123; color: #2AAD6F; text-shadow: 0 0 100px gold; &#125; p::after&#123; content: &quot;\\e618&quot;; font-family: icon; font-size: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;i class=&quot;iconfont icon-zhifubao&quot;&gt;&lt;/i&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&amp;#xf0178;&lt;/span&gt; &lt;span&gt;&amp;#xe605;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 矢量图使用12345678910111213141516&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;微信.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;微信.svg&quot; alt=&quot;&quot;&gt; &lt;!--svg图片其实就是和canvas一样画出来的，但一般都是用AI这种绘图软件生成，可右键记事本打开此图片，看到是XML文件--&gt;&lt;/body&gt;&lt;/html&gt; 4.css3高级①.2d位移12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; margin: 50px auto; &#125; .box:nth-child(1)&#123; transform: translateX(-100px); &#125; .box:nth-child(2)&#123; transform: translateY(-100px); &#125; .box:nth-child(3)&#123; /* 如果只有一个参数 ,则以X轴方向位移*/ transform: translate(100px,100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;translateX&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; margin: 50px auto; &#125; .box:nth-child(1)&#123; transform: translateX(-100px); &#125; .box:nth-child(2)&#123; transform: translateY(-100px); &#125; .box:nth-child(3)&#123; /* 如果只有一个参数 ,则以X轴方向位移*/ transform: translate(100px,100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;translateX&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ②.位移的使用-让未知宽高的盒子水平和垂直居中1234567891011121314151617181920212223242526&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box&#123; position: absolute; left: 50%; top: 50%; width: 200px; height: 200px; background: red; transform: translate(-50%,-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ③2d旋转12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; margin: 50px auto; transition: all 0.35s; &#125; .box:nth-child(1):hover&#123; transform: rotate(90deg); &#125; .box:nth-child(2):hover&#123; transform: rotate(-90deg); &#125; .box:nth-child(3):hover&#123; transform: rotate(720deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ④.2d缩放1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; margin: 50px auto; transition: all 0.35s; &#125; .box:nth-child(1):hover&#123; transform: scaleX(1.5); &#125; .box:nth-child(2):hover&#123; transform: scaleY(1.5); &#125; .box:nth-child(3):hover&#123; /*一个参数时 ,x , y 同时缩放*/ transform: scale(2,0.5); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑤设置文字为10px12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; font-size: 16px; transform: scale(0.75); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;教育改变生活!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑥2d倾斜1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; margin: 50px auto; transition: all 0.35s; &#125; .box:nth-child(1):hover&#123; transform: skewX(45deg); &#125; .box:nth-child(2):hover&#123; /*任何一个方向的拉伸角度为90时会四条边平行(消失看不见)*/ transform: skewX(90deg); &#125; .box:nth-child(3):hover&#123; transform: skew(45deg,45deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑦.矩阵123456789101112131415161718192021222324252627282930313233343536&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; margin: 50px auto; transition: all 0.35s; &#125; .box:nth-child(1):hover&#123; /**最后两个参数: x , y 的偏移距离*/ transform: matrix(1,0,0,1,100,50); &#125; .box:nth-child(2):hover&#123; /**第一个,第四参数:x , y 的缩放*/ transform: matrix(0.5,0,0,0.5,0,0); &#125; .box:nth-child(3):hover&#123; transform: matrix(1,0.5,0.5,1,0,0); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑧.3D位移1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; /*设置舞台距离*/ perspective: 1000px; transform-style: preserve-3d; &#125; .box&#123; width: 200px; height: 200px; background: red; margin: 50px auto; transition: all 0.35s; &#125; .box:nth-child(1):hover&#123; transform: translateX(100px); &#125; .box:nth-child(2):hover&#123; transform: translateY(100px); &#125; .box:nth-child(3):hover&#123; transform: translateZ(-100px); &#125; .box:nth-child(4):hover&#123; transform: translate3d(100px,100px,100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑨3D旋转1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; /*设置舞台距离*/ perspective: 1000px; transform-style: preserve-3d; &#125; .box&#123; width: 200px; height: 200px; background: red; margin: 50px auto; transition: all 0.35s; &#125; .box:nth-child(1):hover&#123; transform: rotateX(360deg); &#125; .box:nth-child(2):hover&#123; transform: rotateY(360deg); &#125; .box:nth-child(3):hover&#123; transform: rotateZ(360deg); &#125; .box:nth-child(4):hover&#123; /**前面三个参数, 矢量值 ,最后一个参考的基数角度*/ transform: rotate3d(1,1,1,180deg); &#125; .box:nth-child(5):hover&#123; /**建议: 方便控制*/ transform: rotateX(180deg) rotateY(180deg) rotateZ(180deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;rotateX&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;rotateY&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;rotateZ&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;rotate3d&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;rotatex ,y ,z&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑩3D缩放123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; /*设置舞台距离*/ perspective: 1000px; transform-style: preserve-3d; &#125; .box&#123; width: 200px; height: 200px; background: red; margin: 50px auto; transition: all 0.35s; &#125; .box:nth-child(1):hover&#123; transform: scaleX(1.5); &#125; .box:nth-child(2):hover&#123; transform: scaleY(1.5); &#125; .box:nth-child(3):hover&#123; transform: scaleZ(1.5); &#125; .box:nth-child(4):hover&#123; transform: scale3d(1.5,1.5,1.5 ); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 11.鼠标悬停3D动画1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;style&gt; body&#123; /*background: #000;*/ &#125; *&#123; padding: 0; margin: 0; &#125; .container&#123; width: 600px; height: 600px; border: 1px solid #ccc; margin: 50px auto; /*设置舞台距离*/ perspective: 1200px; &#125; .phone&#123; display: block; width: 300px; height: 437px; background: url(&quot;images/phone.jpg&quot;) no-repeat 0 0 / 300px 437px ; margin: 50px auto; /*设置旋转中心点*/ transform-origin: 50% 50% 100px; /*设置旋转*/ transform: rotateX(60deg) rotateY(3deg) rotateZ(-25deg); /*设置阴影*/ box-shadow: -7px 10px 10px #333 ; /*设置过渡动画*/ transition: all 0.8s; &#125; .phone:hover&#123; transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); box-shadow: -100px 100px 10px transparent; &#125; &lt;/style&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;a href=&quot;&quot; class=&quot;phone&quot;&gt;&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css3中特效作用123456789101112131415&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;3d 的css3样式特性:&lt;/h3&gt; &lt;p&gt;如果在css3中 可以使用3d属性 ,代替实现相同效果的2d时 ,建议使用3d属性来完成效果&lt;/p&gt; &lt;p&gt;硬件加速&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 立方体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 100px; margin: 100px auto; perspective: 1200px; transform: rotateX(-22deg) rotateY(28deg) rotateZ(0deg); transform-style: preserve-3d; transform-origin: 50% 50% 0px; animation: animate 5s linear infinite; &#125; .cube&#123; position: relative; /*允许保留子元素的3d效果*/ transform-style: preserve-3d; transform: rotateX(-21deg); &#125; .cube &gt; div&#123; position: absolute; width: 100px; height: 100px; background: rgba(255,0,0,0.5); border: 1px solid #000; text-align: center; line-height: 100px; color: #fff; font-size: 50px; &#125; .front&#123; transform: translateZ(50px); &#125; .back&#123; transform: rotateY(180deg) translateZ(50px); &#125; .left&#123; transform: rotateY(-90deg) translateZ(50px); &#125; .right&#123; transform: rotateY(90deg) translateZ(50px); &#125; .bottom&#123; transform: rotateX(-90deg) translateZ(50px); &#125; .top&#123; transform: rotateX(90deg) translateZ(50px); &#125; @keyframes animate &#123; 0%&#123; transform: rotateY(0deg); &#125; 100%&#123; transform: rotateY(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;cube&quot;&gt; &lt;div class=&quot;front&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;back&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;top&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5.过度与动画①过渡12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; /*设置过渡效果:*/ /*[必须]1.设置允许元素产生过渡效果的css3属性 : transition-property :(1.指定某一个css样式属性 2. all 3.none)*/ transition-property: all; /*transition-property: backgroun d,transform;*/ /*[必须]2.设置元素产生过渡效果花费的时间 transition-duration: ms / s */ transition-duration: 1s; /*3.设置元素产生过渡的延迟时间 transition-delay : ms / s */ transition-delay: 0s; /*4.设置过渡效果的速度时间曲线(变化的速度) transition-timing-function */ transition-timing-function: ease; &#125; .box:nth-child(1):hover&#123; background: #2aabd2; border-radius: 50%; transform: scale(0.5); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; 过渡 : 需要通过:事件 / 行为 / js 触发机制 来触发 ,不能主动播放 &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ②时间曲线赛跑对比1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 1200px; margin: 50px auto; border: 1px solid red; &#125; .container .box&#123; position: relative; left: 0; width: 100px; height: 100px; border-radius: 50%; background: #2aabd2; color: #fff; text-align: center; line-height: 100px; margin: 10px 0; transition-property: all; transition-duration: 10s; &#125; #action&#123; background: #2AAD6F; border: none; padding: 16px 14px; color: #fff; display: block; margin: 15px auto; cursor: pointer; &#125; .container.on .box&#123; left: 1100px; &#125; .container .box:nth-child(1)&#123; transition-timing-function: linear; &#125; .container .box:nth-child(2)&#123; transition-timing-function: ease; &#125; .container .box:nth-child(3)&#123; transition-timing-function: ease-in; &#125; .container .box:nth-child(4)&#123; transition-timing-function: ease-out; &#125; .container .box:nth-child(5)&#123; transition-timing-function: ease-in-out; &#125; .container .box:nth-child(6)&#123; transition-timing-function:cubic-bezier(0, 2.93, 1, 1.26); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;action&quot;&gt;Action&lt;/button&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;linear&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;ease&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;ease-in&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;ease-out&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;ease-in-out&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;贝塞尔曲线&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var container = document.querySelector(&quot;.container&quot;); action.onclick = function()&#123; container.classList.add(&quot;on&quot;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ③过度简写123456789101112131415161718192021222324252627282930&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; /*简写:transition:1.过渡属性 2.时间 3.时间曲线 4.延迟*/ /*transition: all 0.35s ease 1s;*/ transition: background 2s ease 0s,transform 1s ease 0s; &#125; .box:nth-child(1):hover&#123; background: #2aabd2; border-radius: 50%; transform: scale(0.5); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;过渡 : 需要通过:事件 / 行为 / js 触发机制 来触发 ,不能主动播放&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ④动画12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /*1.创建动画 */ @keyframes breathLamp &#123; 0%&#123; opacity: 0.5; &#125; 100%&#123; opacity: 1; &#125; &#125; /*2.设置动画*/ .phone&#123; display: block; margin: 50px auto; /*[必须]1.设置需要使用的动画名称 animation-name*/ animation-name: breathLamp; /*[必须]2.设置动画播放的时间 animation-duration : m / ms */ animation-duration: 0.5s; /*3.设置动画播放的时间曲线*/ animation-timing-function: ease; /*4.设置动画的延迟 : m / ms*/ animation-delay: 0s; /*5.设置动画播放的次数: 数字 / infinite */ animation-iteration-count: infinite; /*6. 设置轮流反向播放*/ animation-direction: alternate; &#125; .phone:hover&#123; /*7.动画播放状态 , 控制动画播放 / 暂停*/ animation-play-state: paused; /*8.填充模式 animation-fill-mode */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;images/phone.jpg&quot; alt=&quot;&quot; class=&quot;phone&quot;&gt;&lt;/body&gt;&lt;/html&gt; ⑤动画的播放方向123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes animate &#123; 0%&#123; left: 0; &#125; 100%&#123; left: 1200px; &#125; &#125; .box&#123; position: relative; left: 0; width: 100px; height: 100px; background: red; /*!*[必须]1.设置需要使用的动画名称 animation-name*!*/ /*animation-name: animate;*/ /*!*[必须]2.设置动画播放的时间 animation-duration : m / ms *!*/ /*animation-duration: 1s;*/ /*!*3.设置动画播放的时间曲线*!*/ /*animation-timing-function: ease;*/ /*!*4.设置动画的延迟 : m / ms*!*/ /*animation-delay: 0s;*/ /*!*5.设置动画播放的次数: 数字 / infinite *!*/ /*animation-iteration-count: infinite;*/ /*!*6.设置动画轮流反向播放 : alternate *!*/ /*animation-direction: alternate;*/ /*//简写 : 1.动画名称 2.动画播放时间 3.时间曲线 4. 延迟 5.次数 6.轮流反向播放*/ animation: animate 1s cubic-bezier(0, 1.07, 0.8,-0.01) 0s infinite alternate; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑥动画的填充模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;animation-fill-mode 填充模式&lt;/title&gt; &lt;style&gt; @keyframes animate &#123; 0%&#123; left: 0; &#125; 100%&#123; left: 1100px; &#125; &#125; .container&#123; width: 1200px; margin: 50px auto; border: 1px solid red; &#125; .container .box&#123; position: relative; left: -100px; width: 100px; height: 100px; border-radius: 50%; background: #2aabd2; color: #fff; text-align: center; line-height: 100px; margin: 10px 0; animation: animate 1s; &#125; .container.on .box&#123; left: 1100px; &#125; .container .box:nth-child(1)&#123; /*设置填充模式*/ animation-fill-mode: none; &#125; .container .box:nth-child(2)&#123; /* 动画结束后元素停留在动画的最后一帧位置*/ animation-fill-mode: forwards; &#125; .container .box:nth-child(3)&#123; /* 动画开始时在第一帧位置开始出现(不一定是元素布局的位置) (配合延迟使用 ,效果可见)*/ animation-delay: 1s; animation-fill-mode: backwards; &#125; .container .box:nth-child(4)&#123; /**动画从第一帧开始出现 ,然后结束时停留在最后一帧*/ animation-delay: 1s; animation-fill-mode: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;none&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;forwards&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;backwards&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;both&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用animate.css插件(需自己下载引入并参照官方文档编写)1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/animate.min.css&quot;&gt; &lt;style&gt; #box&#123; width: 200px; height: 100px; margin: 100px auto; background: red; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;animated rotateOutDownLeft&quot; id=&quot;box&quot;&gt;教育改变生活!&lt;/p&gt; &lt;hr&gt; bounce flash pulse rubberBand shake headShake swing tada wobble jello bounceIn bounceInDown bounceInLeft bounceInRight bounceInUp bounceOut bounceOutDown bounceOutLeft bounceOutRight bounceOutUp fadeIn fadeInDown fadeInDownBig fadeInLeft fadeInLeftBig fadeInRight fadeInRightBig fadeInUp fadeInUpBig fadeOut fadeOutDown fadeOutDownBig fadeOutLeft fadeOutLeftBig fadeOutRight fadeOutRightBig fadeOutUp fadeOutUpBig flipInX flipInY flipOutX flipOutY lightSpeedIn lightSpeedOut rotateIn rotateInDownLeft rotateInDownRight rotateInUpLeft rotateInUpRight rotateOut rotateOutDownLeft rotateOutDownRight rotateOutUpLeft rotateOutUpRight hinge jackInTheBox rollIn rollOut zoomIn zoomInDown zoomInLeft zoomInRight zoomInUp zoomOut zoomOutDown zoomOutLeft zoomOutRight zoomOutUp slideInDown slideInLeft slideInRight slideInUp slideOutDown slideOutLeft slideOutRight slideOutUp heartBeat&lt;/body&gt;&lt;/html&gt; 走路动画HTML结构123456789101112131415161718192021222324252627282930&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @keyframes walk &#123; 0%&#123; background-position: -640px 0; &#125; 100%&#123; background-position: 0 0; &#125; &#125; .man&#123; width: 80px; height: 100px; margin: 100px auto; background: url(&quot;images/man.png&quot;); animation: walk 0.5s steps(8) infinite; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;man&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 走路动画需要找一张动画的一帧一帧的图 such as 6.音频视频(audio和video)在以后几乎要代替flash题外话普及&lt;chrome中告别Flash&gt;安东尼·拉福格Google Chrome产品经理2017年7月25日发布 ​ 今天，Adobe宣布计划在2020年底停止对Flash的支持。20年来，Flash帮助你塑造了在网络上玩游戏、看视频和运行应用程序的方式。但近年来，Flash变得不那么常见了。三年前，80%的Chrome桌面用户每天都访问Flash站点。如今，手机的使用率只有17%，而且还在继续下降。这一趋势表明，Web站点正在转向比Flash更快、更节能的开放Web技术。他们也更安全，所以你可以更安全的购物，银行，或阅读敏感文件。它们也可以用在移动设备和桌面，所以你可以从任何地方访问你喜欢的网站。去年年底，当网站开始要求你运行Flash时，这些开放网络技术成为了Chrome的默认体验。在接下来的几年里，Chrome将继续淘汰Flash，它会先征求你的许可，让你在更多的情况下运行Flash，然后在默认情况下禁用Flash。到2020年底，我们将完全从Chrome中移除Flash。 ①.音频123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;audio src=&quot;media/song.mp3&quot; controls autoplay preload=&quot;none&quot;&gt; 您的浏览器版本太低,请&lt;a href=&quot;https://baidu.com&quot;&gt;点击升级!&lt;/a&gt;&lt;/audio&gt;&lt;audio controls&gt; &lt;source src=&quot;media/song.wav&quot;&gt; &lt;source src=&quot;media/song.mp3&quot;&gt; &lt;source src=&quot;media/song.ogg&quot;&gt;&lt;/audio&gt;&lt;hr&gt;&lt;p&gt;1. controls 播放控件&lt;/p&gt;&lt;p&gt;2.autoplay 自动播放&lt;/p&gt;&lt;p&gt;3. loop 循环播放 (单曲循环)&lt;/p&gt;&lt;p&gt;4.preload : 设置浏览器加载音频文件的时刻 : auto:网页加载完加载音频文件 metadata:网页加载时只加载音频文件的元数据 (音频文件的基本信息:时长,作家这类的...) none:网页加载时不加载音频文件, 只有点击播放时才加载&lt;/p&gt;&lt;hr&gt;&lt;p&gt;关于浏览器用户规则:&lt;/p&gt;&lt;p&gt;如果页面打开,未产生用户的交互行为, 浏览器不允许各类音频 / 全屏功能的接口调用.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; ②视频1234567891011121314151617181920212223242526&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;视频尺寸: 4:3 / 16:9 &lt;/p&gt;&lt;video id=&quot;video&quot; src=&quot;media/vedio.mp4&quot; width=&quot;800&quot; height=&quot;1200&quot; controls autoplay&gt;&lt;/video&gt;&lt;hr&gt;&lt;p&gt;1. controls 播放控件&lt;/p&gt;&lt;p&gt;2.autoplay 自动播放&lt;/p&gt;&lt;p&gt;3. loop 循环播放 (单曲循环)&lt;/p&gt;&lt;p&gt;4.preload : 设置浏览器加载音频文件的时刻 : auto:网页加载完加载音频文件 metadata:网页加载时只加载音频文件的元数据 (音频文件的基本信息:时长,作家这类的...) none:网页加载时不加载音频文件, 只有点击播放时才加载&lt;/p&gt;&lt;hr&gt;&lt;p&gt;关于浏览器用户规则:&lt;/p&gt;&lt;p&gt;如果页面打开,未产生用户的交互行为, 浏览器不允许各类音频 / 全屏功能的接口调用.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 7.Canvas基础①基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); //获取canvas画布 var cxt = canvas.getContext(&quot;2d&quot;);// 获取canvas画笔 (获取canvas上下文环境) for(var i=0;i&lt;800;i+=40)&#123; //绘制起点 cxt.moveTo(0,800 - i); //绘制终点 (下一个点) cxt.lineTo(i,800); //设置描边的颜色样式 cxt.strokeStyle = &quot;#000&quot;; //设置描边粗细 cxt.lineWidth = 1; //描边 (绘制出来) cxt.stroke(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ②绘制三角型123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); //获取canvas画布 var cxt = canvas.getContext(&quot;2d&quot;);// 获取canvas画笔 (获取canvas上下文环境) cxt.moveTo(20,20); cxt.lineTo(400,400); cxt.lineTo(780,20); cxt.lineTo(20,20); cxt.lineWidth=10; cxt.stroke(); cxt.fillStyle = &quot;pink&quot;; cxt.fill();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ③路径开始与闭合1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); //获取canvas画布 var cxt = canvas.getContext(&quot;2d&quot;);// 获取canvas画笔 (获取canvas上下文环境) //路径开始 (每次绘制一个图形都需要加这个 与结束, 不然会出现一些线条连接一起的问题) cxt.beginPath(); cxt.moveTo(20,20); cxt.lineTo(400,400); cxt.lineTo(780,20); //路径结束(闭合) cxt.closePath(); cxt.lineWidth=10; cxt.stroke(); cxt.fillStyle = &quot;pink&quot;; cxt.fill();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ④绘制矩形123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); //获取canvas画布 var cxt = canvas.getContext(&quot;2d&quot;);// 获取canvas画笔 (获取canvas上下文环境) //绘制矩形路径 rect(x,y,w,h) // cxt.rect(300,300,200,200); // cxt.stroke(); //直接绘制一个带描边的路径 // cxt.strokeRect(300,300,200,200); //直接绘制一个带填充的矩形 cxt.fillRect(300,300,200,200); //清除矩形区域 cxt.clearRect(350,350,100,100);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ⑤canvas动画原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); //获取canvas画布 var cxt = canvas.getContext(&quot;2d&quot;);// 获取canvas画笔 (获取canvas上下文环境) var centerX = 400; var centerY = 400; var w = 0;//开始的宽度 var direction = true;//方向 , true 小 - &gt; 大 ,false 从大 - &gt; 小 var speed = 20 ; setInterval(function()&#123; cxt.fillStyle = &quot;pink&quot;; cxt.clearRect(0,0,800,800); if(direction)&#123; w+=speed; if(w &gt;=800)&#123; direction = false; &#125; &#125;else&#123; w-=speed; if(w&lt;=0)&#123; direction = true; &#125; &#125; cxt.fillRect(centerX - w /2,centerX - w /2,w,w); &#125;,1000 / 60)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ⑥绘制圆形12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); //获取canvas画布 var cxt = canvas.getContext(&quot;2d&quot;);// 获取canvas画笔 (获取canvas上下文环境) //绘制圆 arc(x,y,r,sAnagle,eAnagle,是否逆时针) //在canvas绘制中使用的都是弧度制(rad) Math.PI =&gt; π cxt.beginPath(); cxt.moveTo(400,400); cxt.arc(400,400,400,0,Math.PI / 2,false); cxt.closePath(); cxt.stroke();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ⑦二次贝塞尔曲线1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); //获取canvas画布 var cxt = canvas.getContext(&quot;2d&quot;);// 获取canvas画笔 (获取canvas上下文环境) //绘制二次贝塞尔曲线 cxt.moveTo(0,400); cxt.quadraticCurveTo(400,-400,800,400); cxt.stroke();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ⑧三次贝塞尔曲线1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); //获取canvas画布 var cxt = canvas.getContext(&quot;2d&quot;);// 获取canvas画笔 (获取canvas上下文环境) // 绘制三次贝塞尔曲线 cxt.moveTo(0,0); cxt.bezierCurveTo(0,700,700,0,800,400); cxt.stroke();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ⑨位移与状态修复1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); //获取canvas画布 var cxt = canvas.getContext(&quot;2d&quot;);// 获取canvas画笔 (获取canvas上下文环境) //所有的canvas画笔状态都是统一使用的 ,如果有一处更改则全局更改 = &gt; 全局变量 cxt.save(); //更改原点坐标 (使用位移) cxt.translate(200,200); cxt.arc(0,0,10,0,Math.PI*2); cxt.fill(); //在绘制需要旋转效果的图像上 ,先备份画笔的状态, 等画完之后, 恢复到备份之前的状态 cxt.save();//备份画笔状态 //缩放 cxt.scale(0.5,0.5); //设置旋转 ( 弧度制) 旋转中心在原点坐标上 cxt.rotate(40 * (Math.PI/180)); cxt.fillRect(200,200,100,100); //恢复画笔状态 cxt.restore(); cxt.restore(); cxt.fillRect(300,300,100,100);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 绘制风景时钟123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 600px; height: 600px; margin: 50px auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; /** * 绘制步骤: * 1.大圆盘 * 2.绘制分刻度 * 3.绘制时刻度 * 4.绘制时针 * 5.绘制分针 * 6.绘制秒针 * 7.绘制小圆点 * */ var canvas = document.querySelector(&quot;#canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); function drawClock() &#123; cxt.clearRect(0,0,600,600); //获取当前系统时间 var date = new Date(); var h = date.getHours(); // 0 - 23 var m = date.getMinutes();//0- 59 var s = date.getSeconds(); // 0- 59 h %=12; //换算成12小时制 h += m / 60; m += s / 60; //绘制大圆盘 cxt.beginPath(); cxt.arc(300,300,280,0,Math.PI *2); cxt.closePath(); cxt.lineWidth = 10; cxt.strokeStyle =&quot;#ccc&quot;; cxt.stroke(); cxt.save(); //分刻度 cxt.translate(300,300);//平移原点 cxt.save(); for (var i=0;i&lt;60;i++)&#123; cxt.rotate(Math.PI / 180 * 6); //绘制一个分刻度 cxt.beginPath(); cxt.moveTo(0,-265); cxt.lineTo(0,-275); cxt.strokeStyle = &quot;cyan&quot;; cxt.lineWidth = 6; cxt.stroke(); cxt.closePath(); &#125; cxt.restore(); //绘制时刻度 cxt.save(); for(var i=0;i&lt;12;i++)&#123; cxt.rotate(Math.PI / 180 * 30); cxt.beginPath(); cxt.moveTo(0,-258); cxt.lineTo(0,-275); cxt.strokeStyle = &quot;cyan&quot;; cxt.lineWidth = 10; cxt.stroke(); &#125; cxt.restore(); //绘制时针 cxt.save(); cxt.beginPath(); cxt.rotate(Math.PI / 180 * 30 * h); cxt.moveTo(0,20); cxt.lineTo(0,-130); cxt.lineWidth = 14; cxt.strokeStyle = &quot;blue&quot;; cxt.closePath(); cxt.stroke(); cxt.restore(); //绘制分针 cxt.save(); cxt.beginPath(); cxt.rotate(Math.PI / 180 * 6 * m); cxt.moveTo(0,20); cxt.lineTo(0,-170); cxt.lineWidth = 10; cxt.strokeStyle = &quot;purple&quot;; cxt.closePath(); cxt.stroke(); cxt.restore(); //绘制秒针 cxt.save(); cxt.beginPath(); cxt.rotate(Math.PI / 180 * 6 * s); cxt.moveTo(0,20); cxt.lineTo(0,-220); cxt.lineWidth = 4; cxt.strokeStyle = &quot;red&quot;; cxt.closePath(); cxt.stroke(); //绘制小圆点 - 中心圆点 cxt.beginPath(); cxt.arc(0,0,10,0,Math.PI*2); cxt.strokeStyle = &quot;red&quot;; cxt.fillStyle=&quot;yellow&quot;; cxt.stroke(); cxt.fill(); cxt.closePath(); //绘制小圆点 - 秒针上的 cxt.beginPath(); cxt.arc(0,-190,10,0,Math.PI*2); cxt.strokeStyle = &quot;red&quot;; cxt.fillStyle=&quot;yellow&quot;; cxt.stroke(); cxt.fill(); cxt.closePath(); cxt.restore(); cxt.restore(); setTimeout(drawClock,1000); &#125; drawClock(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 绘制风景时钟2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 600px; height: 600px; margin: 50px auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; /** * 绘制步骤: * 1.大圆盘 * 2.绘制分刻度 * 3.绘制时刻度 * 4.绘制时针 * 5.绘制分针 * 6.绘制秒针 * 7.绘制小圆点 * */ var canvas = document.querySelector(&quot;#canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); function drawClock() &#123; cxt.clearRect(0,0,600,600); //获取当前系统时间 var date = new Date(); var h = date.getHours(); // 0 - 23 var m = date.getMinutes();//0- 59 var s = date.getSeconds(); // 0- 59 var ms = date.getMilliseconds();//0 - 999 h %=12; //换算成12小时制 h += m / 60; m += s / 60; //绘制大圆盘 cxt.beginPath(); cxt.arc(300,300,280,0,Math.PI *2); cxt.closePath(); cxt.lineWidth = 10; cxt.strokeStyle =&quot;#ccc&quot;; cxt.stroke(); cxt.save(); //分刻度 cxt.translate(300,300);//平移原点 cxt.save(); for (var i=0;i&lt;60;i++)&#123; cxt.rotate(Math.PI / 180 * 6); //绘制一个分刻度 cxt.beginPath(); cxt.moveTo(0,-265); cxt.lineTo(0,-275); cxt.strokeStyle = &quot;cyan&quot;; cxt.lineWidth = 6; cxt.stroke(); cxt.closePath(); &#125; cxt.restore(); //绘制时刻度 cxt.save(); for(var i=0;i&lt;12;i++)&#123; cxt.rotate(Math.PI / 180 * 30); cxt.beginPath(); cxt.moveTo(0,-258); cxt.lineTo(0,-275); cxt.strokeStyle = &quot;cyan&quot;; cxt.lineWidth = 10; cxt.stroke(); &#125; cxt.restore(); //绘制时针 cxt.save(); cxt.beginPath(); cxt.rotate(Math.PI / 180 * 30 * h); cxt.moveTo(0,20); cxt.lineTo(0,-130); cxt.lineWidth = 14; cxt.strokeStyle = &quot;blue&quot;; cxt.closePath(); cxt.stroke(); cxt.restore(); //绘制分针 cxt.save(); cxt.beginPath(); cxt.rotate(Math.PI / 180 * 6 * m); cxt.moveTo(0,20); cxt.lineTo(0,-170); cxt.lineWidth = 10; cxt.strokeStyle = &quot;purple&quot;; cxt.closePath(); cxt.stroke(); cxt.restore(); //绘制秒针 cxt.save(); cxt.beginPath(); cxt.rotate(Math.PI / 180 * 6 * (s + ms/1000) ); cxt.moveTo(0,20); cxt.lineTo(0,-220); cxt.lineWidth = 4; cxt.strokeStyle = &quot;red&quot;; cxt.closePath(); cxt.stroke(); //绘制小圆点 - 中心圆点 cxt.beginPath(); cxt.arc(0,0,10,0,Math.PI*2); cxt.strokeStyle = &quot;red&quot;; cxt.fillStyle=&quot;yellow&quot;; cxt.stroke(); cxt.fill(); cxt.closePath(); //绘制小圆点 - 秒针上的 cxt.beginPath(); cxt.arc(0,-190,10,0,Math.PI*2); cxt.strokeStyle = &quot;red&quot;; cxt.fillStyle=&quot;yellow&quot;; cxt.stroke(); cxt.fill(); cxt.closePath(); cxt.restore(); cxt.restore(); setTimeout(drawClock,1000 / 60); &#125; drawClock();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二次贝塞尔曲线生成工具1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;!-- saved from url=(0028)http://www.j-%2Dd.com/bezier --&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Canvas贝塞尔曲线绘图工具-GavinJs&lt;/title&gt; &lt;meta name=&quot;keywords&quot; content=&quot;GavinJs-Canvas贝塞尔曲线代码生成工具,Canvas三次贝塞尔曲线代码生成工具&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;web前端开发技术的网站,GavinJs-Canvas二次贝塞尔曲线绘图工具,GavinJs-Canvas三次贝塞尔曲线代码生成工具&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./二次贝塞尔曲线绘图工具-GavinJs_files/curves.css&quot;&gt; &lt;/head&gt; &lt;body&gt;&lt;div id=&quot;BAIDU_DUP_fp_wrapper&quot; style=&quot;position: absolute; left: -1px; bottom: -1px; z-index: 0; width: 0px; height: 0px; overflow: hidden; visibility: hidden; display: none;&quot;&gt;&lt;iframe id=&quot;BAIDU_DUP_fp_iframe&quot; src=&quot;./二次贝塞尔曲线绘图工具-GavinJs_files/o.html&quot; style=&quot;width: 0px; height: 0px; visibility: hidden; display: none;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; &lt;div style=&quot;margin:0 auto;min-width: 1200px;&quot;&gt; &lt;h1 id=&quot;title&quot; style=&quot;float: left;&quot;&gt;Canvas&lt;span&gt;二次&lt;/span&gt;贝塞尔曲线操作实例&lt;/h1&gt; &lt;div style=&quot;float: right;&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; /*728*90 创建于 2015-03-28*/ var cpro_id = &quot;u2015392&quot;;&lt;/script&gt;&lt;script src=&quot;./二次贝塞尔曲线绘图工具-GavinJs_files/c.js.下载&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;div id=&quot;BAIDU_SSP__wrapper_u2015392_0&quot;&gt;&lt;iframe id=&quot;iframeu2015392_0&quot; name=&quot;iframeu2015392_0&quot; src=&quot;./二次贝塞尔曲线绘图工具-GavinJs_files/wcgm.html&quot; width=&quot;728&quot; height=&quot;90&quot; align=&quot;center,center&quot; vspace=&quot;0&quot; hspace=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:0;vertical-align:bottom;margin:0;width:728px;height:90px&quot; allowtransparency=&quot;true&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;content&quot; style=&quot;clear: both;&quot;&gt;&lt;canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;500&quot; class=&quot;bezier&quot; style=&quot;cursor: default;&quot;&gt;&lt;/canvas&gt; &lt;pre id=&quot;code&quot;&gt;canvas = document.getElementById(&quot;canvas&quot;);ctx = canvas.getContext(&quot;2d&quot;)ctx.lineWidth = 6;ctx.strokeStyle = &quot;#0090D2&quot;;ctx.beginPath();ctx.moveTo(100, 250);ctx.quadraticCurveTo(250, 100, 400, 250);ctx.stroke();&lt;/pre&gt; &lt;div class=&quot;nav&quot;&gt; &lt;button id=&quot;button&quot;&gt;切换成三次贝塞尔曲线生成工具&lt;/button&gt; &lt;a style=&quot;margin-left: 50px;color: #0090D2;text-decoration: none;&quot; href=&quot;http://j--d.com/&quot; title=&quot;html5前端开发技术分享网站&quot;&gt; html5前端开发技术分享网站&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; &lt;!--&lt;div style=&quot;float: right;margin-right: 10px;margin-top: 50px;&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt;var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot; : &quot; http://&quot;);document.write(unescape(&quot;%3Cspan id=&#x27;cnzz_stat_icon_1254162719&#x27;%3E%3C/span%3E%3Cscript src=&#x27;&quot; + cnzz_protocol + &quot;s11.cnzz.com/z_stat.php%3Fid%3D1254162719%26show%3Dpic1&#x27; type=&#x27;text/javascript&#x27;%3E%3C/script%3E&quot;));&lt;/script&gt; &lt;/div&gt;--&gt; &lt;/div&gt;&lt;div style=&quot;margin:0 auto;margin-top: 50px;&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt;var jd_union_unid=&quot;285262729&quot;,jd_ad_ids=&quot;505:6&quot;,jd_union_pid=&quot;CLfPuNrLKRCJh4OIARoAIP/J24gBKgA=&quot;;var jd_width=960;var jd_height=90;var jd_union_euid=&quot;&quot;;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;./二次贝塞尔曲线绘图工具-GavinJs_files/auto.js.下载&quot;&gt;&lt;/script&gt; &lt;/div&gt; &lt;script src=&quot;./二次贝塞尔曲线绘图工具-GavinJs_files/curves.js.下载&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 三次贝塞尔曲线生成工具1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;!-- saved from url=(0028)http://www.j-%2Dd.com/bezier --&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Canvas贝塞尔曲线绘图工具-GavinJs&lt;/title&gt; &lt;meta name=&quot;keywords&quot; content=&quot;GavinJs-Canvas贝塞尔曲线代码生成工具,Canvas三次贝塞尔曲线代码生成工具&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;web前端开发技术的网站,GavinJs-Canvas二次贝塞尔曲线绘图工具,GavinJs-Canvas三次贝塞尔曲线代码生成工具&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./三次贝塞尔曲线绘图工具-GavinJs_files/curves.css&quot;&gt; &lt;/head&gt; &lt;body&gt;&lt;div id=&quot;BAIDU_DUP_fp_wrapper&quot; style=&quot;position: absolute; left: -1px; bottom: -1px; z-index: 0; width: 0px; height: 0px; overflow: hidden; visibility: hidden; display: none;&quot;&gt;&lt;iframe id=&quot;BAIDU_DUP_fp_iframe&quot; src=&quot;./三次贝塞尔曲线绘图工具-GavinJs_files/o.html&quot; style=&quot;width: 0px; height: 0px; visibility: hidden; display: none;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; &lt;div style=&quot;margin:0 auto;min-width: 1200px;&quot;&gt; &lt;h1 id=&quot;title&quot; style=&quot;float: left;&quot;&gt;Canvas&lt;span&gt;三次&lt;/span&gt;贝塞尔曲线操作实例&lt;/h1&gt; &lt;div style=&quot;float: right;&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; /*728*90 创建于 2015-03-28*/ var cpro_id = &quot;u2015392&quot;;&lt;/script&gt;&lt;script src=&quot;./三次贝塞尔曲线绘图工具-GavinJs_files/c.js.下载&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;div id=&quot;BAIDU_SSP__wrapper_u2015392_0&quot;&gt;&lt;iframe id=&quot;iframeu2015392_0&quot; name=&quot;iframeu2015392_0&quot; src=&quot;./三次贝塞尔曲线绘图工具-GavinJs_files/wcgm.html&quot; width=&quot;728&quot; height=&quot;90&quot; align=&quot;center,center&quot; vspace=&quot;0&quot; hspace=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:0;vertical-align:bottom;margin:0;width:728px;height:90px&quot; allowtransparency=&quot;true&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;content&quot; style=&quot;clear: both;&quot;&gt;&lt;canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;500&quot; class=&quot;bezier1&quot; style=&quot;cursor: default;&quot;&gt;&lt;/canvas&gt; &lt;pre id=&quot;code&quot;&gt;canvas = document.getElementById(&quot;canvas&quot;);ctx = canvas.getContext(&quot;2d&quot;)ctx.lineWidth = 6;ctx.strokeStyle = &quot;#0090D2&quot;;ctx.beginPath();ctx.moveTo(100, 250);ctx.bezierCurveTo(150, 100, 350, 100, 400, 250);ctx.stroke();&lt;/pre&gt; &lt;div class=&quot;nav&quot;&gt; &lt;button id=&quot;button&quot;&gt;切换成二次贝塞尔曲线生成工具&lt;/button&gt; &lt;a style=&quot;margin-left: 50px;color: #0090D2;text-decoration: none;&quot; href=&quot;http://j--d.com/&quot; title=&quot;html5前端开发技术分享网站&quot;&gt; html5前端开发技术分享网站&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; &lt;!--&lt;div style=&quot;float: right;margin-right: 10px;margin-top: 50px;&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt;var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot; : &quot; http://&quot;);document.write(unescape(&quot;%3Cspan id=&#x27;cnzz_stat_icon_1254162719&#x27;%3E%3C/span%3E%3Cscript src=&#x27;&quot; + cnzz_protocol + &quot;s11.cnzz.com/z_stat.php%3Fid%3D1254162719%26show%3Dpic1&#x27; type=&#x27;text/javascript&#x27;%3E%3C/script%3E&quot;));&lt;/script&gt; &lt;/div&gt;--&gt; &lt;/div&gt;&lt;div style=&quot;margin:0 auto;margin-top: 50px;&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt;var jd_union_unid=&quot;285262729&quot;,jd_ad_ids=&quot;505:6&quot;,jd_union_pid=&quot;CLfPuNrLKRCJh4OIARoAIP/J24gBKgA=&quot;;var jd_width=960;var jd_height=90;var jd_union_euid=&quot;&quot;;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;./三次贝塞尔曲线绘图工具-GavinJs_files/auto.js.下载&quot;&gt;&lt;/script&gt; &lt;/div&gt; &lt;script src=&quot;./三次贝塞尔曲线绘图工具-GavinJs_files/curves.js.下载&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8.Canvas高级①线性渐变1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; border: 1px solid red; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); //1.创建渐变对象(线性渐变) ,createLinearGradient(x1,y1,x2,y2) var g = cxt.createLinearGradient(0,0,800,0); // 2.设置渐变颜色: 把整个渐变过程视为单位1 , 开始位置0 ,终点为1 g.addColorStop(0,&quot;#ff0000&quot;); g.addColorStop(0.25,&quot;purple&quot;); g.addColorStop(0.5,&#x27;yellow&#x27;); g.addColorStop(0.75,&#x27;pink&#x27;); g.addColorStop(1,&quot;#00ff00&quot;); cxt.fillStyle = g; //设置填充样式为 渐变 //渐变对象可以用于填充, 描边的样式中 cxt.fillRect(0,0,800,800); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ②.线性渐变-描边1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; border: 1px solid red; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); //1.创建渐变对象(线性渐变) ,createLinearGradient(x1,y1,x2,y2) var g = cxt.createLinearGradient(0,0,800,0); // 2.设置渐变颜色: 把整个渐变过程视为单位1 , 开始位置0 ,终点为1 g.addColorStop(0,&quot;#ff0000&quot;); g.addColorStop(0.25,&quot;purple&quot;); g.addColorStop(0.5,&#x27;yellow&#x27;); g.addColorStop(0.75,&#x27;pink&#x27;); g.addColorStop(1,&quot;#00ff00&quot;); cxt.strokeStyle = g; cxt.lineWidth = 20; cxt.strokeRect(50,50,700,700);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ③.径向渐变123456789101112131415161718192021222324252627282930313233343536&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; border: 1px solid red; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); //1.创建径向渐变对象 createRadialGradient(x1,y1,r1,x2,y2,r2) var g = cxt.createRadialGradient(400,400,100,200,400,400); g.addColorStop(0,&quot;red&quot;); g.addColorStop(1,&quot;green&quot;); cxt.arc(400,400,400,0,Math.PI*2); cxt.fillStyle = g; cxt.fill();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ④.图形组合12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; border: 1px solid red; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); //(先 , 新 ) //1.绘制一个蓝色的矩形 (先) cxt.fillStyle = &quot;blue&quot;; cxt.fillRect(250,250,300,300); /** * 设置图形组合方式: (ps中的图层混合模式) * (分上下) * 1. source-over (默认) 新画图形, 在原有图形之上 - &gt; 后来居上 * 2.destination-over 新画图形, 在原有图形之下 -&gt; 先画在上面 * (取重叠) * 3.source-in 只显示新画图形中与原图型交集部分 * 4.destination-in 只显示先画图形中与原新图形交集部分 * * (取不重叠) * 5.source-out 只显示 新画图形中与原图形不交集部分 * 6.destination-out 只显示 先画图形中与新图形不交集部分 - &gt; 实现一个擦除的效果 * * 7.source-atop :绘制原图形形状, 如有与新图形重叠,则新图形显示在上面 * 8.destination-atop:绘制新图形形状, 如有与原图形重叠,则原图形显示在上面 * * 9.lighter : 图形均绘制,但是重叠部分做加色处理 * * 10. xor :新旧图形,重叠部分透明处理 * * 11.copy: 只绘制新图形, 原图形中未与新图形重叠部分透明处理 * * 12.lighten : 变亮 * * 13.darken : 变暗 * * */ cxt.globalCompositeOperation = &quot;hue&quot;; // 2.绘制一个红色的圆形 (新) cxt.arc(550,550,200,0,Math.PI*2); cxt.fillStyle = &quot;rgba(255,0,0,1)&quot;; cxt.fill();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ⑤.绘制阴影1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; border: 1px solid red; margin: 0 auto; &#125; body&#123; background: #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); cxt.beginPath(); cxt.arc(400,400,200,0,Math.PI*2); cxt.closePath(); cxt.fillStyle = &quot;#fff&quot;; cxt.fill(); //设置阴影 cxt.shadowOffsetX = 0; cxt.shadowOffsetY = 0; cxt.shadowColor = &quot;#eee&quot;; cxt.shadowBlur = 100; cxt.globalCompositeOperation = &quot;destination-out&quot;; cxt.beginPath(); cxt.arc(320,340,200,0,Math.PI*2); cxt.fillStyle = &quot;red&quot;; cxt.fill(); cxt.closePath();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ​ ⑥绘制图像123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; border: 1px solid red; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--&lt;img id=&quot;img&quot; src=&quot;img/html5.jpg&quot; alt=&quot;&quot;&gt;--&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); //绘制图像 (图像从哪来??) // var img = document.getElementById(&quot;img&quot;);//获取图像对象 var img = new Image();//创建图像对象 img.src=&quot;img/html5.jpg&quot;; img.onload = function()&#123; //确保图像已经存在, 才开始绘制 //1.使用canvas 绘制图像 drawImage(img,x,y) cxt.drawImage(img,0,0); //2.drawImage(img,x,y,w,h) // cxt.drawImage(img,500,0,300,375); // 3.drawImage(img,sx,sy,sw,sh,dx,dy,dw,dh); cxt.drawImage(img,134,28,233,324,0,380,233,324); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ⑦绘制视频123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; float: left; width: 800px; height: 800px; border: 1px solid red; margin: 0; display: inline-block; /*overflow: hidden;*/ /*vert-align: top;*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;video id=&quot;video&quot; src=&quot;video.mp4&quot; width=&quot;800&quot; controls&gt;&lt;/video&gt; &lt;button id=&quot;screenshoot&quot;&gt;截图&lt;/button&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); var screenshoot = document.getElementById(&quot;screenshoot&quot;); var video = document.getElementById(&quot;video&quot;); // screenshoot.onclick = function()&#123; // //截屏 , 绘制当前时刻的视频画面 // cxt.drawImage(video,0,0); // &#125; setInterval(function()&#123; cxt.drawImage(video,0,0); &#125;,1000/60)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ⑧图像数据12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; border: 1px solid red; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); //图像数据 : canvas画布中所有像素点信息,数据 imageData 800 * 800 = 64万 像素点 //每一个像素点的信息构成由: R G B A 构成 ,数据中就有 256万个数据 var imageData = cxt.getImageData(0,0,800,800); //获取canvas画布中 0 0 位置开始 ,宽高 为800 区域的像素信息 imageData.data[0] = 255;//第一个像素点的R imageData.data[1] = 255;//第一个像素点的G imageData.data[2] = 0;//第一个像素点的B imageData.data[3] = 255;//第一个像素点的A //将图像数据放置到canvas中 (绘制) cxt.putImageData(imageData,0,0); console.log(imageData);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ⑨处理视频反相123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; float: left; width: 800px; height: 800px; border: 1px solid red; margin: 0; display: inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;video id=&quot;video&quot; src=&quot;video.mp4&quot; width=&quot;800&quot; controls&gt;&lt;/video&gt; &lt;button id=&quot;screenshoot&quot;&gt;截图&lt;/button&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); var screenshoot = document.getElementById(&quot;screenshoot&quot;); var video = document.getElementById(&quot;video&quot;); //先将视频绘制canvas - &gt; 然后取出canvas的图像数据 - &gt;(反相)处理 -&gt;放回去 setInterval(function()&#123; cxt.drawImage(video,0,0,800,600); //1.绘制视频 var imgageData = cxt.getImageData(0,0,800,600);//2.取出canvas图像数据 // 3. 处理反相 for (var i=0;i&lt;imgageData.data.length;i+=4)&#123; //处理每一个像素点的RGBA 数据 (反相算法) // imgageData.data[i] = 255 - imgageData.data[i] ; //R // imgageData.data[i+1] = 255 - imgageData.data[i+1] ; //g // imgageData.data[i+2] = 255 - imgageData.data[i+2]; // b // imgageData.data[i+3] = 255; //a // (灰度) 颜色的RGB 值一样即为灰色 var p = (imgageData.data[i] + imgageData.data[i+1] + imgageData.data[i+2]) / 3 * 1.5; imgageData.data[i] = p; //R imgageData.data[i+1] =p; //g imgageData.data[i+2] =p; // b imgageData.data[i+3] = 255; //a &#125; //4.重新绘制回去 cxt.putImageData(imgageData,0,0); &#125;,1000/60)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ⑩绘制文字12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; border: 1px solid red; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); //设置字体样式 类似于css 中的font 样式 cxt.font=&quot;italic bold 50px 微软雅黑&quot;; //设置字体对齐 - &gt; css left / center / right cxt.textAlign=&quot;center&quot;; //设置文字的垂直对齐 top / middle / bottom cxt.textBaseline = &quot;middle&quot;; cxt.fillText(&quot;教育改变生活!&quot;,400,100); cxt.strokeText(&quot;教育改变生活!&quot;,400,400);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 11.clip图像裁剪12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; border: 1px solid red; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); cxt.beginPath(); cxt.arc(400,400,200,0,Math.PI*2); cxt.stroke(); cxt.closePath(); // cxt.font=&quot;56px 微软雅黑&quot;; // cxt.fillText(&quot;教育改变生活!&quot;,400,400); cxt.clip(); var img = new Image(); img.src = &quot;img/clock.jpg&quot;; img.onload = function()&#123; cxt.drawImage(img,0,0); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12.创建平铺1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; border: 1px solid red; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); var g = null; var img = new Image(); img.src = &quot;img/icon.jpg&quot;; // cxt.rotate(Math.PI / 180 *45); img.onload = function()&#123; //1.创建平铺对象 g = cxt.createPattern(img,&quot;repeat-y&quot;); //2.设置填充模式为 平铺对象 cxt.fillStyle = g; cxt.fillRect(0,0,800,800); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 13.文件保存1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 800px; border: 1px solid red; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--&lt;a href=&quot;img/a.png&quot; download=&quot;sss&quot;&gt;下载图片&lt;/a&gt;--&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var canvas = document.getElementById(&quot;canvas&quot;); var cxt = canvas.getContext(&quot;2d&quot;); //设置字体样式 类似于css 中的font 样式 cxt.font=&quot;italic bold 50px 微软雅黑&quot;; //设置字体对齐 - &gt; css left / center / right cxt.textAlign=&quot;center&quot;; cxt.fillStyle = &quot;red&quot;; //设置文字的垂直对齐 top / middle / bottom cxt.textBaseline = &quot;middle&quot;; cxt.fillText(&quot;教育改变生活!&quot;,400,100); cxt.strokeText(&quot;教育改变生活!&quot;,400,400); //双击保存文件 canvas.ondblclick = function()&#123; // toDataURL(图片类型,压缩的比例值) , 默认 0.92 = &gt; 用于实现图片压缩功能 var img = canvas.toDataURL(&quot;image/jpeg&quot;,0.92); //导出base64 编码图片 // console.log(img); var a = document.createElement(&quot;a&quot;); a.href = img; a.download = new Date().getTime(); //模拟点击 a.click(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; base64图片演示12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; base64编码好处: 可以将图片直接放入到css文件 , 或者 html中 避免浏览器额外请求图片 = &gt; 降低http请求次数 不足: 无法复用 , 造成额外的代码冗余,无法充分利用浏览器缓存机制 使用场景: 一般在网页小图标的地方会使用到&lt;/p&gt;&lt;p&gt; 传统的图片引入方式: 可以充分浏览器的缓存机制,如果同一个地址的图片用于多处 ,其实浏览器只会加载一次 不足:产生额外的请求 使用场景: 除了不能使用base64场景都用 下面src里面的一大串就是base64编码&lt;/p&gt;&lt;img src=&quot;img/a.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;img/a.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;img/a.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;img/a.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAMgCAYAAADbcAZoAAAgAElEQVR4XuzdB7QHTV8X9pFETRReQJEiaGgGQpFQpSlVmhQVBUUQkIBSXpEqKFKULoj0HqV3giASpFeR3gNIC51X6cUTTMTz5exwNsu2mX/Ze5/97DnP4eW5Ozs7n917n/nt/Gbm9xUHAQIECBAgQIAAAQIE7iTw++5Uj2oIECBAgAABAgQIECBQBCBeAgIECBAgQIAAAQIE7iYgALkbtYoIECBAgAABAgQIEBCAeAcIECBAgAABAgQIELibgADkbtQqIkCAAAECBAgQIEBAAOIdIECAAAECBAgQIEDgbgICkLtRq4gAAQIECBAgQIAAAQGId4AAAQIECBAgQIAAgbsJCEDuRq0iAgQIECBAgAABAgQEIN4BAgQIECBAgAABAgTuJiAAuRu1iggQIECAAAECBAgQEIB4BwgQIECAAAECBAgQuJuAAORu1CoiQIAAAQIECBAgQEAA4h0gQIAAAQIECBAgQOBuAgKQu1GriAABAgQIECBAgAABAYh3gAABAgQIECBAgACBuwkIQO5GrSICBAgQIECAAAECBAQg3gECBAgQIECAAAECBO4mIAC5G7WKCBAgQIAAAQIECBAQgHgHCBAgQIAAAQIECBC4m4AA5G7UKiJAgAABAgQIECBAQADiHSBAgAABAgQIECBA4G4CApC7UauIAAECBAgQIECAAAEBiHeAAAECBAgQIECAAIG7CQhA7katIgIECBAgQIAAAQIEBCDeAQIECBAgQIAAAQIE7iYgALkbtYoIECBAgAABAgQIEBCAeAcIECBAgAABAgQIELibgADkbtQqIkCAAAECBAgQIEBAAOIdIECAAAECBAgQIEDgbgICkLtRq4gAAQIECBAgQIAAAQGId4AAAQIECBAgQIAAgbsJCEDuRq0iAgQIECBAgAABAgQEIN4BAgQIECBAgAABAgTuJiAAuRu1iggQIECAAAECBAgQEIB4BwgQIECAAAECBAgQuJuAAORu1CoiQIAAAQIECBAgQEAA4h0gQIAAAQIECBAgQOBuAgKQu1GriAABAgQIECBAgAABAYh3gAABAgQIECBAgACBuwkIQO5GrSICBAgQIECAAAECBAQg3gECBAgQIECAAAECBO4mIAC5G7WKCBAgQIAAAQIECBAQgHgHCBAgQIAAAQIECBC4m4AA5G7UKiJAgAABAgQIECBAQADiHSBAgAABAgQIECBA4G4CApC7UauIAAECBAgQIECAAAEBiHeAAAECBAgQIECAAIG7CQhA7katIgIECBAgQIAAAQIEBCDeAQIECBAgQIAAAQIE7iYgALkbtYoIECBAgAABAgQIEBCAeAcIECBAgAABAgQIELibgADkbtQqIkCAAAECBAgQIEBAAOIdIECAAAECBAgQIEDgbgICkLtRq4gAAQIECBAgQIAAAQGId4AAAQIECBAgQIAAgbsJCEDuRq0iAgQIECBAgAABAgQEIN4BAgQIECBAgAABAgTuJiAAuRu1iggQIECAAAECBAgQEIB4BwgQIECAAAECBAgQuJuAAORu1CoiQIAAAQIECBAgQEAA4h0gQIAAAQIECBAgQOBuAgKQu1GriAABAgQIECBAgAABAYh3gAABAgQIECBAgACBuwkIQO5GrSICBAgQIECAAAECBAQg3gECBAgQIECAAAECBO4mIAC5G7WKCBAgQIAAAQIECBAQgHgHCBAgQIAAAQIECBC4m4AA5G7UKiJAgAABAgQIECBAQADiHSBAgAABAgQIECBA4G4CApC7UauIAIFHIJC/iU8qpTxHKeXpSinPVUp5plLKCw7/9zdLKW9cSvmFR9CWtVv866WUNyulfH0p5RtLKd8xtOm/PvB2/Y+llOcrpfzZUsorlVL+eSnlKx74Pc/d3ouWUr6olPIsMz/86lLK3yil/MwjbJdbJkCAwC4BAcguJicROK3Ay5RSvqSU8jQTgXcopXxIKeW3O2X+dCnlk0spv1hK+ZVSyreXUn69lPI9w//Ovz/iyN/E9xj+mav/u0opr19K+cEjbu5KdT5jKeXjSymvPblezN++lPJJV6rnGpf5w6WUvIMvXUp5+VLKy00u+oallE+7RkV3vsbblVL+2UKd/6SU8l6llP/vzvekOgIECNxNQAByN2oVEXh0Avn78A9LKekQjY+fLaX8xVLKN3e26A+WUt6nlJIgZnp8RCnlnUsp/7nz2tco9rdLKR+zcqGXLaV8wzUqOuga+br+qTN1f1Up5Y1KKT990H3NVfs8pZTPKqW80MI9HRmAZKTsg0op/28p5YtLKd80BNRbQfnTllI+oZTyV2ba9GullL90h1Gd5y+lvF4p5QNLKb9xx+ddRxj/+2Gk8X8qpSTI/F9KKRndepFSylOXUn61lPK/lVJ+6Y73pioCBO4oIAC5I7aqCDwygWcopXxKKeXVJvf9fwzpO72dg1ccOsDT9JOMLiQ16P862OnPl1L+7co9HNnpvZTmWYdn+gozF3qI7doKQN59JkC+1GhP+fy3M4Fcfj/GR1LZEozkn28dgpPp9V6ilPIFC+lXX15K+ZullAT5tzhy3686pK7F9l1KKR+8cJ/j+hMwZBT0qUb/Mv/uuUspv3/4d/m/L1BK+QPD//+8pZQ/PvzvBBqpb++R0dXc22/tLeA8AgQel4AA5HE9L3dL4J4CS+lXSdNJB6HnePpSyseWUv7qTOG3GL4Mb31BnhZN5+bThzSdnns6sky+8n7icAOxyf/OF/BLjw8bRpL+n9GF8vf+7w6dz+n1P6eUkpGf3qDy0vtdKv9QA5B8sf+MlZGZjOIlxWqaRpVnkPSrdPrnjlumXyVgSNCU+/ojQ+UZcfk7Q1vGv3cZjcjveN6JI47cU/5OLB1bHwn+ZSnlbe48unOEkzoJPFoBAcijfXRunMBNBf67YR7EP5rUki+zr1VK+baF2tOxSWrV5w1zOcan5e9NOtwfN1M280GePKRetDYscxn+VWuhB3D+dD7J2pfx1tt93VLK508KLXXm0wlNOtDaqE9r/dc6P1/YP7OUkknbc8cRX8qTMpR633zhntaCubUg85bpV7nnfzD8M73t/3tYWOFrRj/4Y0NQ/8rXepCN18lcn69dKLOUGjo+fe79b7wFpxMgcEsBAcgtdV2bwMMXuEbnPasovUEpJR2o9x86ZunUvNMQiNSVlf7UkLLyZyYsOTcd4KSstB6ZT5I89nzZf2xHvvDma3jmu2x9GW9pW30eca3H2ryb8X201DN37mN+HnsWVlgLouOR9MG/Vkr57gXItSDz/xzm4PynSx/CpPwfHUZcsnrb0vHvSylvOkp/TPrUZw+rv135djYvt7XQw1JqaL3w3Pu/WakTCBC4r4AA5L7eaiPwkASSq52AIZ3gS458DU5KyfsNHah6rQQkCQ7yswQhSxPP/14pJSlDralXqSfL5SYVZhrUXNKee5Udz7nY6lS13NPcqMDSvJtLgr+5e3qsz2PvwgovVkr53FJK0v6mx1I6Uz1vK8jMaGN+R3p+D9bej6ReJbjK7/rakVHEpFz9fCllK8Wp5X1sPTfzZ7IYwlI64NZI4S3T2Frb4nwCBBYEBCBeDQLnFbjW3Im3LaVkZai5eR0fOqyklfkk6bhNl/Pt0R9/qf7LwyhLz3WOLDP9yrs036bnHl+nlPKFo4JJp8koxzXmlszdzzhf/7E+jz0LK2Q/mDjGd+74qGHezdKqUlvpV69+w9XVkoKVjwFvtfFC5WNBVr7LeUvLBPe8kwl0/8PwIeKHSyk/McyPyYhRvBL0PGWYDJ8VsNaCsLUljBME3tKxp+3KECAwIyAA8VoQOK/ANTqL+Q9+Uoiyt8T0qB2ybOiX1YLmVl5q1d/7pXp63WcfvgInDWUpCEon9H2HuStLG/Llb+YLD6M9rzKqJCksb70yN2atnXty2vc6TdNP1iae773m2nnpQCbw/L5SyhM5/SqjCFmVabokdbXZs4TxWpB5q/Sr8bPLxPl/sTFamD1g3q2U8q5DEJKlhRMQ1CObI/7A6P/PKlV59tkb52/NvCjj9+Ma71t+dz9yMtI6vu6eQPIa9+EaBAhcKCAAuRBQcQKPVODWncUafGQVpmyqlgmw1zhaOxj5+p+0knw1rSv/TO/jX5dSPmDYEXxtJ/B8RX7LUkqWfp0LYjKqkZ//u2s0dOUaSwsEpEjS4JLKU1dfWksZusZtjlcbeqKmX+W/k1keOnvDXGME7xru02vsXfUpk7sTZExTyMbpkq178KyN7Oy9r70m2cA0I6mZTzZ3XLJC3957cB4BAlcQEIBcAdElCDyBBNK5zVfefAEdH0mfyETxOrk2nfk64Xza/HEqSkYJrpV6lXr2TBTOedlj5M02Ao9vGdJN8vU6m8ltHVlFKsvk5kv20pFUk3wJzjWvnctf60zbsmrY3ApF8f6y4cS1JY+32rr35+NlhK8xora33muetxXUptOblbgygvBQj/FzWLvHuRGxHxx+r75kSJFqbePayM6195ZZ2kQz93zt0ZZWB+cTINAgIABpwHIqgRMIZOOwTyulvPykrUmhSopRvpRmVCG54pkoOj3GwUfSnrLj9lqHvYV0K/0qm6Q93zDisZZq9T3DSEGWqR3vk7HnXvLlNbu1j9OvpuUShORLbDq2twhCXmm49vRr/FcP+zwkTSaBZO4hef+3Oq7R4VubmD0XbC6l4NxqCduteR+3sm25butzGM8HydLLmcM1TqtqqXstfXBrNauWenLu1t4k11zNrfXenE+AQKOAAKQRzOkEnuACS6vf1C+sSd1IDvZfmHGoE84zqTSdhXR+sxnYtY6MpOQ+fmVywXSo/tyQs/6aK5X9YinlvYd9SJJm8rSTnZ1TNEFMAqdcc3ykQ58RkHSAk2q0tUFb6sq+JvlyvpbW1WqzN/1qKdWmtb6181s7fHFNZzf7wNTd7pfSd5aCzaUUnPEcivx3Lat+ZW5KVpX6yc5G75243Xn5qxXrSXPKaE5GJ/IhIe9q77G2elvr+7F1D1uLZtj7Y0vQzwk8IAEByAN6GG6FwMECS+lX9Qtr5hUkyJj7+p/J2/knwcdaznxGBdJ5/48zbV36sr+WXrI1KfVI0nyVz9yT5NzvSfHac6970q+eedhRfi5IXNqhe1x3grkETqlrfGSifeZC/NieGx2dk458drnP5Oak7o2Xe11aUnUpLSrvTuZiTI+6hO3/MASi7zEEi/kKn5G7TM5vGY3au3RtI8VNTl9Lc0qnva5olZWmrn3cM/1qbc+i8ejftdvoegQI3EBAAHIDVJck8EAFttbPv/S265fYfF2d2yshX7XTWfrKmYqWJsVvdXq30jIubdOl5ROEZNQlgVtrutdc3UsjVF9eSvmbw4pFS8utrgV/ta41z73zb+q18kwzLyTziV5w0pgEDJn4n1GifIWfHnOTiTNi9QnDXKTx+XXp1SztmmsmSBof+cKf6yW1cE8g+Bgmndf2raU5Zff4jFZmj5xx0NfyXl36/reWXwo8lz6O1Ovb+6NV2vkEDhYQgBz8AFRP4E4CW5ugXeM2MlKRFaWW9krICEm+TM91Apcm+m51LPLFOx3Yrf0NrtG+S67xnkNKWusKQ+M61zphcUq6UXaEX5r3sWdC8NIoVEs+f9LYkgL290spr7qAlqAhP09ANd2fJIHqa80saZwO9RfNjMwk/SqLA2SE5YVWHtKeZ5Dfk9xP9sCY22zwknfgFmXn0pzShlcrpXz0pA2Zx5Ugcjr6uNW5v8V9L11zKchdG/nbmht2z/tXFwECOwUEIDuhnEbgkQusLZV5jaYlTSurP2Vi+lwwkA5nUreyr8D0WJrXkGv+tdHKW0v3ma/p//gajZi5RlYIyqTyreN7SykvMjN5v5bLbu3vWErJBPHeY2mBgDoBO4Hd3BKrtb7xCllz9/CkUsqHDyMp059nGeUENnV537ny+e9JAskEFtNRiPH5Mc3zSkpQvnhPJ9MvzfVZ2oAundYsdvBBK/tD1Po/ftjPY2new9bcma3NBqcuWx3nuUCr9/1IuaSOZWPIBPtzSwbP3f/Se3XJffSUXQsk1lK9tlYx67kXZQgQuLGAAOTGwC5P4IEI3Dr9KsvCZv+LdFLnOj7fNgQT2QV5ejx/KeVzZpY5rbsyb6UuJQDJV+t82f0vpZTvHFbrSj0/VEr5pVGFdcfl8T2k4761+/Kexzi30VuCl3yZT/u22rFVx1r61T8dOvVJt1k6slv9N6z8PDt85yv59PltjX7kvyPPO3Tskwa2dCRQSgc4z/U/DUsgz23s15J+Ne60rq3ONr6nLx7mhUwDy8x9yQT5LDYwd2ylMc2VWRpRyrlLgdbWe7D086TP5V3b2nMnP88IT30fl96r3vvoLbcUSGxt1Ll3CeLe+1KOAIEbCAhAboDqkgQemMA90q++opTy3CtpK186LBH7CxObjH5kYnS+2I6Px5pWMf6Cng5VRj1+9Arvw1qaTCZYJ2iYzrMYV5ulh19vZbnV7GSf0YFM9J0eS6MfNfB4p2FextomfUnNS/rddwyTwZdWT5ruN1PvZe9k9Sybm1GcrIC1diQQy4T27OKd46WGlKWlFK7MRXrT0epdex7pVmrTtTfNW0q9mrvX7OqeQDDpctnPJ6NLRx9L6VdLc39yv61LEB/dRvUTIDAICEC8CgQIVIGkb2Sjr3wdnds1PB27fzgaXajl5r78T1WXluRcGv34sCEwuXTU4N5PN39TX7+UkgnYWUlq7f63dnW+5r2vjWLMbU5X605HPXNHfnzmZrLKVgKLtaOmW33exGIppWa830y9buteIXv27shoTILedMLzDuZZLY18ZKQk+8p8TeMDWUttWprn0ljF7zl97wT6tD+pWgleMzn/pS+t+MLyax8club+pMrH+nfiQi7FCTx+AQHI43+GWkDgGgJJ38gXyIxGzH3JXprAu6ezl/t7r+Gf8VKoCXjy76cpI+nwZdf1b93RsIeSvz6+1blO9FxTlpaU3dHs3z3lKcOeK2ujDzl5LQBJAJk5KnNf/7N8blaemlvCdm1e0Tjdam7Sc0ZDkjo3PdIpTrA6Plr3CknZZx1WgEpa2fTI+5VRmwRF2aMlwdDXL6D3Bh+53Fpq0953pOVdqOfuXUI4AVhWaGtdGGFtL5qtVet62rP2e5Ln+4U9F1WGAIFjBQQgx/qrncBDEMi+EZm7Mbez+dpeFi2bDb57KWWa75+OX76+TlcbWlsta+r1UPLXx/c114me3ve19i/JsrMZrXrzjRdpKQBZe4aZt5LO33gOzbSaNxsClPG/z3ygBBhzoyY5b2lidmv61dYcioxoZHWsvGf1yIhOVgr79tG/e8lSSnYEnwZxdZQgwVnLHiK59Fb61Z535JK/DWubKE4DsNZ61ibWf8gwF+i3Wi+6cH7a8RGllDeZ+XldejqjJw4CBB6ZgADkkT0wt0ugUWDtP+CNl/o9p6cTleAh+zxsHdMlYJdWXNqa8DyuZ6uTt3VPt/j5Uid6Wtc10q/q/hfZYTyrQK0dS65ZZSwTr6ed77U9W8b1ZFf4dNAz+T3pWBnRSuf+mru/X/KcxumBmZOTuQ7TyecJVD5rMgJ0SfCR+10bmdv7jlzS7pSdG52cC8Ba61kL+q89IjH3bOr9bi3R3dou5xMgcEcBAcgdsVVF4ACBpTkWl95KnfyZjla+Hm8d4wAkf3cy1yRpKNPj7w153Xu+OD/m9KulJWW3HMc/r6sGPeewP8ZTl1LyBTp7b0xXw5oLQNbm7uwdhfoDwxfvrICW3aizBO/cylYt7brGuePOaVa3evnBJoHF9Jh2cq+xg/3art23TL+atm38jLMCWdLelpYg3uO+tRjCG+xctnpPXTknG1kmVW56PNZFKva223kEnvACApAn/CPWwJMLzKXIXIOk7nqe1Yw+fTSJNR2DpGhMj3EAstTx/aohDeynd97gY02/WlvVZ2fTf+e0umrQHx2CuQQAGYVIWtvcfI7xMrxrKTprE8/X7m8tNaelXZeeW/dFycpse46s3pZJ6JnsnLKZk/Qxw6T0ueWh91zzFufU37nfaLh4/hufUa68I1nl7NJFHdaC/munXyW4XVqhayv9roHIqQQIHCEgADlCXZ0E7iNwy/SruvZ+5hCk45G5AtknIaMhH7kSgCx1fNPxyxyUXGPPsdY5yco+1/4SW+9pbUWmvUuCLq3q05J+NjaKRZad/YJSyrPNpBPVc+tGhGlDnl9Sr6ZHnkMWANgzqjUtu7bnxZ5neq1zsjN63qXsNbLnSOe8rgSVkZO8z9kb5lbB+557mjvnFvtdXCMVsKc9e0Ywkt45/rgxrucWFj3tUIYAgU4BAUgnnGIEHoHArdKvph3lpBNl6dnsk5DdwOfmI2QEJJ2J7JCdr8vTOQeZaJoVuPauyLPWOXm/IdVkbdfu3se3tvLT3i/US+lXS0sVt9zrWs58nfi8ttt3UnTy1Tkd8JZjbWWklutc49y04X0aJo4nAMk7mw0K826m7ddaJOAa7ck19ga3tb5sypjd5r9yGBVb+r26xkpsPW3cs3v50ghnb6Dec5/KECBwIwEByI1gXZbAAxLIJOVMDl7apTqTcrMpWjoF+ZuQDmpy+TOXYHp8y5Ciko5NnWic/PrM2cg+CZnbMReA5PrfvLDqVc8mb2s59vVL/y0ewdqO8nu+yq4FMNOJ+j33vxaAJDBLEJhlded2TO/Z6bve40NKv3r1jR3fp655JlkpKyMnNfA6amRg6ZnvDW5TfjrCld/v/E5mon0CmdrGa6UC9rynW5swrgW09v7oEVeGwAMTEIA8sAfidghcUSDpTtnH4d0WNhZMVXVVnOxQnU5XAo+MUkyPTFzNngFJ25nmoGc35QQg+WcpAEkHKh296b4MPasNraVfXZGv6VJ7v1AvBTDX+qpb04nmgsdsCvibpZQXnmlZTxA4vsxDmY+zZ+ngPQ/2qJGBpXtrCU7/1DAnaC7I/KRSytuUUn59mPPyRQtztvYY9Z6zZxPGzC3LZP1Xm6nklh8YetukHAECjQICkEYwpxN4JAL5D3dSMF585X7zH/ikPaVD/+RhHsfcXghZPSc7Rk83lJu79FIAsnQbralXuc5a+tVRj2fPF+q1+SPXSL9K2xPk5blml/K9xyXzPubqWOs8JlDLpOjv3ntzo/Pybr7L8K7ObbyYeSvpXGeZ20uOh5Z+1RKcLm3uGY/p0srXWImtx9kE8h41ZQg8wQQEIE+wB6o5BAaBtS+46XAmJSuBRUZJlr40ZkWlbCiX0ZE9y+Km6pYApHXVq/pwl5bmPPLh7/lCvZZ+9bqllM+/QgPGiwLsudw1lpyd1rMWaOXc1lSvjLC9YiklSwMvBdQ1mP65PY3eOOehpV+1BKdZcjgres2tRJePCP9wWAnrIadfXeERugQBAg9dQADy0J+Q+yPQJ5COSOZkTI98Tc3yrZnDkaAiue9fMjMpPCMidUJuyx0s1Tu9RvLS33jhHtfq+4PDru3ZzfqhHHu/UC+lXyX9KWlvP3aFBuVveoLG/LPnyIhCOqatk863rr21AEKC34y+rS0pm7aspQXWe8ik+QQnc3t8bN3nNX8+3pRx7vcuCzUkDe5WRwLcBCtZEW2u/rxjGYHKsfQuti5hvNSWpRXR7rUJ462MXZcAgSsJCECuBOkyBB6YwNxk5P99+AJavxLn9z9fRKcbx6WT8HrDhmIZIUnHKmk1/3Mp5XmHpV6/duj0TVeaeslhCde5FJlK1DPvo5Zd6+TdcmfktbSiPV+o10YFrj2pdu8o1IcOz79lX4m9r/laKlC9RvalSAA03RgvVnnOmbuUJYGX3qUEsdmz47NvEEDtbef4vLWRuT3vSE+dtcza5p45Z7zB59q7+OXDYhVJ1+o91jYrvOcmjL33rxwBAncQEIDcAVkVBA4QGE9GTgfvHYcVkMYbka11qtdueW0N//GmbkvXuOSr+1In71pfbpfueWmkKOfvSb9as95Kv0paVVYay/4h/2yYSL72fJb2GRmXSec/cwBuEXzUetZW5KrnZN7G25ZSfqCUklSr5xtWZFsLPFI25bJgwnce8Ls1V+XWyNyed+SSpqxNPM/ywlmhrX54WEsFvEYQv7ZZYV0Keq2t+duV0Zq8A1mRL3+/sht67u0nL0FSlgCBhyMgAHk4z8KdELimQJ0LkB2x0+HP6kfPWErJLuRJj8lE7vzsj3RUuraGf67/GQs7caeqjMLka2xPusxaJ+8aX26XKNaWBN2bfrUUwKylX+V5ZSQqK5m94NAxzyZ5a0ee57sOAefaedNOacdrsFlk66t8vUA6mFkm9jlLKa+5cdW8N1lc4aNvHDxtNm5ywlqwtfcdaa2znr822jS3weda+lXrEsZz97y0ItpW+lXel79YSsly0fGcHl9YSnnzUspTeqGUI0Dg4QgIQB7Os3AnBK4hkPSbTED/X1dSVy6tZ26/i/wtyUThzCdIYLN0ZNnffA3+8Y6b2PNFveOyFxXZkz61lOqWihNQJED8reEu0pnM8qkJOv7S5BmuLT+aOjLy8c+HeT17GpU5GBlRucWGjbX+pPB9YCnlrfbc0MY5PYsiXKHaXZdYS3u7dfpVfu8SwM1NPJ+uMreWftW6g/wczCXpV1kdLct8r6VvvmzjHi+7Hp6TCBC4v4AA5P7maiRwK4F77I8x9zU3ncy3LKW8+86gJxOGM0m6deLz3rkNt/Kdu+5W+lTKrKVfZV+UfNl90vD1P6NDcys9rX093rPfy9y99y4E0Or7TMPk6OkeMHuvk4nbGfVIGs44hXBv+Vuft7Xy2J53pPces+N5ApwEq9NjbsnjtXexdQf5uXteS79a26hzz0aWe/YP6XVUjgCBOwsIQO4MrjoCNxTo2QOi9XbGX/zz9yOb2mVJ363UmXE9PZPQtzp5re24xvl7V69aWhEo5TP6kT1bklqylg6XFLM3mOzF0us/bnvvUsh7/XKPCQd6YrEAACAASURBVEAy6vVP9xYanfejQ0pZUsZuOV+l49Z+t8jayNzed6Sn/thmNbiMes0d44nn9edLqYD5nbxG+tVrD8sszwVDWZ3r+xbudc9GltfaZLLHWhkCBK4sIAC5MqjLEThQICtUZUWgzBfoPfJVPF/bf2hYFjZfUX+5lPLDQwcwOyjn6P3qXu+r9ev7Y02/Wps/0vKMPmGYrJ25PDny5TvLKSe1aS1lZU8drftybF0z70ZSAJMalA0R53bk3rrG3M+/Yph8njS+7x/ey7370/TUt7fM2sjcnhS9vfVMz8sSxdnzI/OupsfcfIm1VMBrpF+tjcBubdS5FLj0/r3oNVWOAIE7CQhA7gStGgJ3ENi7B8fSrWx1ElIuE8GTUpJ0q7mJoi3NTGpNVsXJfiVbHcmlTt61vtwu3ffa0qp7Umv2pJasmX3PkBefif2/MAr8snJUFhJYOuLy4aWUby2lfOTC/IBx2SyPmoBmz27343KZs/LMpZQXKKXk/XuFUkqWYr7HkcnrSQlMGzOnKO9TjLJS0n8dFjqYpvnt+dJ+j3tvraOm6tVyCfIyfygjZ9NjaWf73lXvWu917vy19Kuc/+zDPJaM0EyPPOO3LqV8446/E9e4V9cgQOAOAgKQOyCrgsCdBDL5/E1KKb86dMzSGctIxi+VUn5+WD0mOfT5Ip2VrKZfztc6CQk8XnmYu7G0G/W4mQkq0qlY6yTn/D17OaSzlcm0adv0uMaX26XH86zDLvHpVE+PdIaSEpX7Xzt6d23/ulLKBwwbRv7nUkpS0JLnn5StrRGudMSzh0Z2Vv/9pZT3GYKLrdcw70SW5p1rUwKNpxv258iSrxnhSKBxy8UOtu536+fTUbZ7zJHauqeen0/ftfx3O8vUZqPQudGv8Y7n4/rWlpLuua+9ZTKKupZ+Va+TvxdZwe1Vh78bSV/L5PoafO+tz3kECDwCAQHII3hIbpFAo0D2U0inPelS45GFdCIzZ+O9SylZUWl8LHUSMjk6Hd98Hd/q+OZ6+fqazQ0/cfhqmRWQto6k1GQk5HsXTlzbVbt34mw69Fn9qa4+Na56zamet2e/hJ7J1wkCsjJVOp35ip/nmP0Q9vqns5bN+carjK19XZ6Sj782P/XwrqRDeOlo19yjTfCYI3Ngrn3MzTNKMPzppZSXvnZlN75elqXNe15XK0vK1b9YSG1Lp/2NhjTK8W1dKxWwp6m3XgWs556UIUDgYAEByMEPQPUEbiDQ09Gay1VvnXfxLcMeH/9uCHz2dMDXvrpXmjcrpWQOxPRY2xBxi/WSFbXyZT1BQVJ/lo6MGL39sFv81r2ks/y5wyTtbMhXg8ZnG0Zgsgnh1pF7yqhHJurOrRSVDd0+aceIVOrJcrcZTfuZYUQkAdG1jszjyDylzFHIqFz+G5R7y6aCCXSudcxtdrk1z+BadV/7OuPllxM4J6h/m5lK8h5l+ebMC5kel6YCXtKmW2/CeMm9KUuAwEECApCD4FVL4IYCrYFDOq/pkGckYnxsrbJTz03H56OGPUCmcwjWvtZmN+50FJPLv3SspV+tbYi4xXtJALJn/4zXX+gIju8rbgkKksv/YzP57Xu/Wn/ykBq3trdKrpV5I++5MWk9AcyTh+Ag97pnV/U16zzbrGD1WcOoTtIB5466C3pWdcrcmp4NMut18y7mGY1XzdraqXzrfTnq5189/G4mGMyxtlfG2u72Syux3bpdt96E8db37/oECNxIQAByI1iXJXCgQHK9v76h/rmvxbV4duNOxyZfj+eOjHok5ecrh5ShuXPmvr5nJ+t89d7aEX0t/SppSem8b01gn7unpLRkb4nWIx3pdNC3Jmuv3XfanLSUTBL/iY0bWMvb32M/vnxSy2L2/gt1zgWErROXE3BklCP/pPP8Ix37vSTtL6M+b1pKSce5ZZWvaQBVm/ocw1yCa63I1fre9J4/Tr9aC+bT0c+8kKRSTo+9gWzvPa6Vk351C1XXJPAEEBCAPAEeoiYQmAjsTTVJZzFpQp+20UmcGy3IqMmHDis0be3PkL8zyfNP0JH0sLkv1EsP8RbpV6mrJwBpWSlq7ot7TbVK4LN3J/js7ZL5NOON5vLcMo8nu0Zv2U9dM6KUgDH/jI88y8zdmV5va+L2N5VSMmE+Ae+3l1J+riPgWPsFTspR5h4lPSuB7EusBCRrywn3LgZw5B+XvC957gnmcuRZZNL/aw2TusfzcjLvI7/Hc8H4WvpVfv8TxF9yrAV3e1aKu6RuZQkQeKQCApBH+uDcNoEVgeTvZ4Wc8VGXLP0vQ27/lw6jFk/ZITnuwOQ66bDky+bWKMD00i9VSslyopnAvafjnC/fWUI2navpcUn6Veumhr07cY/TXjKvIru/f0fHiE1Wpso8jNjnuWbjuVb7sV+Co6RjZc5IjJOWlXkFWW1r7shSr3kGGc3IqEuWBs7qalllrXU3+x2v2+op6YRnVC6d7+yDkX+ea1jt628tjABcWudDLJ+UtRikg59Rqrngsd730tLD19pZfCmd8ZabMD7EZ+KeCBBoEBCANGA5lcBJBfJ3IpNe0/nLXiHpeN7jSOcyk7Oz7Ov0uOTL7dMOk9ozkXx8TIO07x7mxXznwmpZWwYZvcjIQlZ7+ryFyeFb18jP89U795oRj62UrT3XyzlJx0rH8Q8NKXb3DiT23qfzCBAgQOAJKCAAeQI+VE0iQODBCCT/vi6f+mBuyo0QIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAAAECBAgQIEDgSAEByJH66iZAgAABAgQIECBwMgEByMkeuOYSIECAAAECBAgQOFJAAHKkvroJECBAgAABAgQInExAAHKyB665BAgQIECAAAECBI4UEIAcqa9uAgQIECBAgAABAicTEICc7IFrLgECBAgQIECAAIEjBQQgR+qrmwABAgQIECBAgMDJBAQgJ3vgmkuAQLfAHy6lPHsp5cdLKb/RfZWHUTDt+I+PvB1pw1OXUr73YZC6CwIECBDYKyAA2SvlPALnFPgbpZSXWGj6x1/Q+fszpZQ3KKV8fynl10opv15K+ZGhnu87kDqd2pce6s895niuUspfKKV8x/D//80L2n1g03636j9WSvnS4f/7mVLKt5dSvnXwP9J+y+b5SykvVEp53lLKa5RSnqqU8vWllL+7VfAB/vxfD+/U0q29TinlCx/gfbslAgQIXEVAAHIVRhch8IQVSMf0rWe+lH/P8PW5ZyQgIwlfM1z3uQe5P15K+RNDZ/8XSinp5B9xJOBK4PHvSyk/PLT754fRgtzPOw0d9q844uauVOc/LqX8YCnl00opCUb+dCklz+FlSilvVEp5xlF7r1Rl92X+9hAQ5n348FJKAqTvHALA5yilvMXBAUgdEWtpYMrkGSy94wlO3vTGz+AFSinvX0p5m2FEr+X+r3Vu3r28a/VIcFmP/D34IUHYtahdh8DDExCAPLxn4o4IPBSBdMQTfEw7Sq9USnn5Uso/6rzRdCpzfOykfAKTzyqlvMuBIwxp82uutC0BSo503h/jkY7nB5RSXm8mqFx6Lke284tLKf+slLIU8P12KeWo/47lXfjUUkru8auHwDSBeVLb1o44/+xC53orOLnGs3jtUsp7llI+uJTyKqWUt2pIxcso1NzxTKWUZ575Qf2wUH80Hq36N6NRz/w8QX89Mjqavw9Gga7xxF2DwAMUOOoP9wOkcEsECEwE8rU/X8qnnYB/MnS4ekYB0gH+5FLKn53p9KRDlw7LPz3wSeT+1r6qJ/h6kRvdYzqfb3fFtue5TZ/Rhw7Pc/rva1rW3HO54i01X+rDSikftxKQHhWA5Fl9/vAe/6FhFClBeVL1EoR8YynlGxbue22EYy04acabFEiA//eHeUzvMARKeZ/zgWEahOT3IO2YHhmFmjt+pZTyAzM/+LlSSkYQ67F3vs7Wc49/2rN2PGVHMHipqfIECHQKCEA64RQjcAKBpF+9+uQ/4vmPfuZrZPLvUvpVOi9LHY1PKqV81ORrZygv6QCn0/Z8V3oeTzdc540Xrpe2/cuhc3mNKn91NNqSgC//fzqulx65x78ySa+pox/pJE+PcVrWpXVfs/xWRzTzV+4dNOV3IO/w3HucttfO+wvO/B5sjXDM/c5dwzP1vtdwP9MAfy4IuXSU89J73gos8/OlYCh1P7mU8sorI2eX3p/yBAhcKCAAuRBQcQKPXCAdjaRPTI+MRDztTCpSzs9X+k+fFMhXznxVf8dhdCCd6Q+anJPUj3QK5iYN58t8yremXKQz+HU3mDOyFEClvsw9uMaR4C5H7RBeq/OZzuZHzkxyzpf3ufS2tcCktZ3xyQTqax1JxVlLyUuA8hOllEymv8aRkYuscrZ2JOB9tpU0vQRzPz2TYphrLo0q5mdLKY+XtivXzfuQ0Y+lUcuMPo7TsY5MNdwK0rbSJOvHjIxUOggQeKACApAH+mDcFoE7CNTRjDdcqOu7Zr7g5j/+deJ4Lfaqw1f7pxlSUZLekSDjSaWUfzCMlNSJ59MRlVwjQU1GHHomnt8yJerWj2A8GnTNzufcXI50KLN61Ny8nQQmSasb5+D3tj3PIwHINa5V72HuPaw/S31zcw967j/zOdZG9nLNtTk0e97ltSBzLTjpaU8tk3crz/31N+Z6pP6MLOTDQQK7zHO65nPc24at3+ktp7zreY7TOWZ763ceAQJ3EBCA3AFZFQQeqMC10izSgc3KVfl78pajTk46wq81rLTzV4ev1NPJ2zUwmaYL7SVbSunaW/6o86Zfabc6VS33mecxXt2o1pVAcTpBOqNS7z5M9G6pY3rulw3XzkhWRseO6Lhecv9bX9Vz7a1FEurIUxZumBtF2QoyrzUCNudQRziWUgtrmTqilPks11qJazxfI4bjDxj5aDFOn8xKbC9aSslHkaWFHpJ2N/cu1zZkUYClZ3DJO6IsAQJXFBCAXBHTpQg8MoF89U5n9ZLOYjoXP1ZK+ZRJ8DHusGX/jKRDLK289DEdbnX5zuxn8RhTLdLxf547pV+tpbflPtIJ7D3ypTmBZp7BY059I9xF8AAAIABJREFU2bO8chy/eaVjnGA4CywspTkdkX41fq75fc9k8Wlq5PicpFAm7e2Fh5GsPN/pMQ0a6s/raOf4/PpOZL+WHNPJ6tkD6EdHBfK3ZG1p7630rIxQvXPnaGrv74ByBAh0CAhAOtAUIfAEEKhzJy7tvNd8+OwpMO441Im66ZBlzsi1UnzGX6rTec6KVdP5KGuPJxPo00Gc6+TknjMqNNfpmrtmnS+Q+9hbpl4nnbxqUnP0s9xsyzHX7mn61SXpbXvuZZwuMw2q9pR/KOdk9OHlVjq/dX+YpU0P634lH7jSoAQocymIKVLTn77kApCtVZ/yfn90KSX3MQ2S6u9r5tNkKez8XmXPlfy+TI9p0JD9OzIiMZdCee13Ymup6GuOJF7wKBQlQGBLQACyJeTnBJ6YAkuTyWtrp53bpcnFzzqzJG2+euYra4KPpFusTdht1R1/qd6T/5/A4M2HtI58Gc3KRdPgo7bt7YfO19KE5nqt7MCdVLM6clQ7dkkl+ZCGBtUUk3y1HW/CtnWJzOXIsTSfo6ZfXZretnUf+fl4FO2xpsNtpSImQEzHfWm1rXyVz7uzdfzkyvLNccyiD71HVn16yR2jmXNpYvl3nzu8uz3726x1+q/9TuRvSlIG51Lc6vu+Fkj2+ipHgMCVBQQgVwZ1OQKPRGBuMnluPf8+aRLTzu14cnE64kmbSod+uqRn7cxkxZ2sjLW06V0v09aX6nrdaVCRZWmn8x/2nFOvVyfyftGw+dxcEJPVmv5k48ZuPQ5L6ULT1a+2UoZ66h6XGadc5X/nC3zmEPQcc+k7GXV4iZmL/dRCRz7t7Tmea+h8z6VOpV0Zleido9RzP61lWlPfxpPS83udTQkzerF3j47p/S3NXWm9r61253r5PZ5bRjpltwLJrev7OQECdxQQgNwRW1UEHoHA0iaD9Ut3OikZRcj/XQs+vqmU8jWllDe5oGMz5do7UTgdkXwlTSrJXOCR6yYFqo54LJ0zrr9uPJfO/9oGjDUV5z12LOfa8zqsfeVN3UmZyVfsrZShnrqnZcbpNXuWJ84oT1aaeu/h2eR6zzl07ufSd9KxzfszPrKSUwKQ6QpHdYJ3TYHKdV+3YcPIubkHNS3p8zqWh76G795r9KQ55V3JyOD3l1LqpoR76xuftzaxvue+1u5h63pHrtzVY6cMgVMLCEBO/fg1nsD/T2Bpk8E6X+QvD6ka2edgul9HXZ40P0tq0i2+vq/twJ4AIV+pExRlZGYpqHjFIfDIxPh0WKajIhVkbqfl7JeSDm7maqzNO0kAlJGfawZf9b7WvvLWHbbzvLJL99pKQdd49fem1+TLdVKEsrpR7PKM6r0tpe8sBZvTFb5qO8bXSdkEoD8ypDVNd/ne2/a8w0ujLXuvcY/z1p5Dtc/7OB21S5D6BRuTvrfu/57pV2sBxrVHW7ba7ecECFwoIAC5EFBxAo9IIF8Q04FdOrILeCahzqVfpQOTlKp0IKcjALnml5dSsvzlxw2rKqUTODdht25UuHQPWd1qHBTUoKieP92nIQFFlhZ9huGr+NIE85p2kvSNbyul/NxKKkfqyqpev7xiFYe1Dev2jpi0vj5LQVhdHShzUzLyMzfpvy4ju5TCMr6XuV2802HNCEY96upmS22oKW555h88Wj2qvodvW0pZSt+Za+fSBoupv17npYaUogTLeT65578+WZZ4j3nueW4jzj1l73nOWse7pkPmfcgHgrVALN7v1nnj09/ZXKam5PVcMjucT/921L8DS30We3/0SCtD4EABAciB+KomcGeBuuHc2jKXCTKmowLpTOTr/9zP0oR0bnJk5OEbhmVZ5ybs1i/Tc8vxpgOR3denaV1L/77S5atogp+1HdTn0oOSqrS14/Wljydu6Xh/98bSp3vrWRqhSvmk1PxsKeXFVnbhXtuhu97DkvfaRpJz919HmpKGNzfxP5OJ459O8jT9aqmdSysg1TSgOP/pmeWgEyAn3W4ueJ679xhkhGa8p83eZ3Tv85bSkmqb64hkRiqWgpC19+re7Vma37Q1v8PeH/d+UuojcKGAAORCQMUJPBKBW6+PXzsxGV1YSj3KV+q5ybxLnds9nd4EIBl16Z1Ae+vHlza83zCaMpcG01L/VvpVUo7yN31pqdhs4La0klPuo07yzfObBqFbgWBtR96zdCKzkMHac6mjZtk1fRo8LrVzLf0qqXFLq5zl3vaOSNVli5eCj1wny0q3HEt7h+TdeN+WC82cm437suneeC+fBCWZWF5HgWqxPJesSJeRp/Gx1bm/8Babii8tMrG2T8ut/7Y1NcDJBAjsExCA7HNyFoHHLnDr9fHT6flXKzsYr20gttS5He8xseT/0AOQet/pPGfDtaXgYM/7tZR+lRGATPqf2wxyHBhkb4e1+vOOZAnipd3ql/awSB3pBGZSc5Zdrl/d59qUTnd2uc5oRja7m0vfWUq/ynWXJqtnfslzbIxq1eWSl0ak9gQfWa429zHePG/t2cU8vxdzCxfUleUSqF1yjIPvpI7NjQKNg5DfnozIrc2tuuS+WsuuLTKxFjzf+m9bazucT4DADgEByA4kpxB4Aggs5dpfq2mZCJuv3ksd3HRQ5zrAa6Mc6bRnadu10Y3WACT1JRha6hynA73nSGdpemQPkGlaV+p6r2FuzXSzxj311HPW0mTSAcs8h7VJ50v+9fp1EYGW9LiUHQceWylOScvKSEXmJKRDmbk7LelXSTGbjpbUTmuumRGmjAaspdYtBSFbwUddEWttp/Pp89xKbbp2xz/vwZ8opbzrysTy2v4vHQLNrXtseUcvPXdplGNtpa2HdP+Xtl95AqcSEICc6nFr7EkF6hfyvXs0/GopZa6zvJZ+ktSetQ5wRkieZWb51LXRj6TnbI0Y1L0ikoLyNKWUbAZYj+zvMJ1wnYnTX7/wHiSA+oGd78h3Tc7LHJnMMxh//c9Sv/kiPd60cFwsowDZT2XvkeVr5zYf3JP/vhWAZMWndO7ndsjOPI7p6EfStTJpOQHbVuBR35unHwKQBJRLX63X0q/edCY1bNxpndtkb842ndZMyM77kqAlG/glGFpKu6rBx7+dGR1ae3ZrqU236Djnmp+9MQKV+63n5bnlSBC4toP7UhsT6M3NJ3v+vS/05Lx8xJjbRLDOb5qb5/WQ0sc6m60YgXMKCEDO+dy1+lwCdRL5Wqtrpyx/E+Y6YuOJvJmMXo/st5AUk7lVk8b1JVDIMU7vuXT0I9ebbqg4DgyWJs3f6unXeQbZBT7BWFYUWxv1WJrT0HJ/dSRmPAdgrvxaAFJTgeaCvbW5Hwl8suHk0gjVON0qcxLGHcjW1a/W0q/Gnda9QUjOy94fCT7SxrX5Kr3L8a6NcNyq49zS/o8cRqJad2DPanlvVEqZrkiX966uyrUU5K+9298384Ei568F2BmRSju23v+W3ynnEiBwBwEByB2QVUHggQuk05BO89zmgrn1pUmtLWkpc6lSl45+5N4uWT70lo9lbnL1uL61JWVb7isjAHOrTE2vsZYCl/SluVS32plcmri+NkdnvNHj9P6WUmqWRgVa9wrZ6oTnvrPaWt39ey2NLyNY+e/kdHW2rWe0NcJx7fSr8f2kfWnb2rK7eR+yV04CyLWNNefauRY8XXs53LXfk62d0beekZ8TIHCggADkQHxVE7iDwN71+F95oSOytW/H3Jr9c82advK2Vr6aWy1ret2tTt4deH9PFXvvaWlJ2dZ7zkjC3MaQ0+uk0//nZjrSuY8nLXSw8+U/ndOlJY7T1q+brKy1Z6PHuhrT9Kt1lmGe6+ynjZ85TJAftyujTEtzMpaCkLQ3K0dlo8I6V2QpANma0L32rO6dfjW9l7TzWYd2Tn+29EFh77u3FjxdY1RvfB9LqZs551q/Q3vb7TwCBK4oIAC5IqZLEXiAAmv/Ab/kdmvnM9fYs+N2Vt4Z/71Z2il973KvqfdWaSyXuOxZuSvXv0ZHLUHFRw8d89ccbrpOsJ9OxM65sR2nWdW0urmJ52sTf8c+dQ5G0t3yv5P/n7kF0zky4zKvP2zyN+ecgCfLCdcjc2symrR0JKVvaV+bvG91YnqWFc7X/qQPTSdpz42wXBJ85F6PSL+aGiU4y6pdNYDM72zSK9dWydp699cC7GuN6o3vIW3I/JS5NL+kZs0tGb3VBj8nQOABCAhAHsBDcAsEbiiQiZ3vcYNN92pHO7f+g6NOTv59OqPTDsM4AElQlBGO6QpIGa35kpkJz0s8t0xj6X0kuacEF2s56dfqqNWOcyzzRT9HOpxz+7DU1bgy2TrHWppSOplLaVlTlwQqycHPM//qYTWunvz/Xu+lck8elvjNHKXcX+YXLKUYTucn1eAjK0W9ROeNJdCbmyNRg5MsQTwOtPZWszYiNb1GTaHLfiAJ0mqa5Z6UvaX7WQv6rz0isbbL+94Aea+r8wgQuLOAAOTO4KojcEeBW+ZIZwTj04eOTTrC6dimU7vUAa5pLumoJvd87svl0j4Uc2RrX2LXltq9Fn86tNOjjgq9yEYlSx21urLU3ntMKlFWp0oHM+k2r1FKearR3IbpdWoQuDV3Zy0ta+7e0ilNx3hts7i9bbrGedPOae4vx9Jch3EAMh75SBCWpZXHiy7svb9fXwn6M/+i58iCBglwWyZcxyIrpz3zzlS9rfu6Z/rV2mjiQ3nXtrz8nACBBQEBiFeDwBNX4NpfJKvU9Mtk9nTIaEYCi6UOcA1A0nH4vJl5BWv7UCx1el9+YVnatDujLD1fmLfehizt+wsLG+K1pF/NLSmbe37xYfRh6z7y89rJHe/ynXSlpRWdks6SkZKMmCxNrE6HNefMpWVt3dPSLtZb5a7989aN6WoAkmWia3pS3vGMnEyXcb72ve693tpowNY10r6kxM2lMWW0rrWNcyM7dVWxrXsZ/3xpWel6zlKws3eeVcu9OJcAgTsLCEDuDK46AncUmHYu/k4p5VNncubzH/T3ndlzY+78dISS3vJro4nLdSWqTGRPIDKX8lX3IMleG9O9LFpSfrY6J/n5NeZXLD2mtc5t0t2S3rKVfrW0pOye8kv3lQ5g5n2sreiU55RRkJw7t9RyTYHbswDA9D7WdrG+4yv/O1W1brqZDvrblVK+f+Ryq+C91yLB6fM0rMaVNmVzyszHyfs4N0/mWqmAPW3akz6Zd3Uu2Nkb6PfclzIECNxJQAByJ2jVEDhAoAYLL7qyX0NdjjOpJj88BAc/OqR6ZOJuPRIk5Ot6UlQ+eLKfRzpH6eAkxWU62byWT8f4ZScrJtWftXb2tibCZn+HvZsutj6WmvY0tsk19n6hXtpUbW/5rfud22+llsnP3mFl0YAEQHOjU1t15ucPJSWmZ27A3C7otwxi93hOz2kJTuu7lCAzK59l0n9WEfvaUso3jy7c+nvXc99zZfaMYKwFtPb+uNaTcB0CBwoIQA7EVzWBGwnUYCEdzszT+IKFL6B1p+4EFJlsO96penxrWVo1K9EkJ35rAutaAJIVi6ajA62pV7mvtS+gezZdvJR9LpVl7xfqdGyX0q9avnAvtWEtAFnbtDCd0WdbSGnb8qpLKn/8MDKW879sZtfy/Ps45av2pUc2v5z7qp/RpYyALC0dPFdv3pnfHF3vyJGBpfvLhPituUW17HSFubTvpYbUu+crpbz18Ht4VJC1Z/W6BLT5W5JFKcZH3rWMsLamjV36vilPgMCVBQQgVwZ1OQIPQKB+YXzGhU5gTbnK73+Cgizlmv/gTyfpJjjIv0/aVFI5pku7zjV1KQBJndMOY0/qVercs9LUvR/Dni/U8XznhfkjKZ/N7pZ2Fd/bnp70lLXlePfUmw7uq4xOTKDz5QtBQAKQBA9vuOfCo3OyR0iC4E9ZWJa1TqyP31aQvFX1USMDS/e1N7hN+RrQz3XQ61yhbCx55ByXPelXOWdph/ald2vrufo5AQIPSEAA8oAehlshcEWBpfXz67KpSblK8LE0p6FO5M4X5ZZVdzIhfWnn7Gnzcu2fLqV8bEO796401XDJi0/dmz61ZH3N1cqmy+1uNa7uJZKVtPYEmFvXy89zDx9RSql7k0zLpHP5Uw3PPSN1dTQv7+z0qG3+xoZrrrWjZ2J2vV4CzLld0/duCLp0Xy+58/cw9z63q32um5GRjAzlQ8NakJW9XK5x5H2a++iQxROWlii+Rr2uQYDAIxAQgDyCh+QWCXQIpIOR/9DXDls67tmILZ218S7QcxN2pzna42Vt87+fe7if7575Yr82CXrcjHQo0/kdb4y3p5lrX/hzvaxSdasjy7HOLeW69wv10uTovZtFJhXuFXakSS2NQs113LPSU1JyrhV81DryHsyl3OXneYc+e1gWdi24HY/AJWiZzrvJteocprzbS8vs3up9mF53bRRs7ztyyb3md+p5F96P/N5kDlf9fVtKBYxnPl5cspdLNnt8o5UJ5Eur113SdmUJEHhkAgKQR/bA3C6BnQLjna+nox41oEhnfW5DwHRWkuZQj+8YdUiSjvUDw2pacyleewKQS1J+6v4jcx3XdPAzsnOLI1/hM1IzN7dgT/rV2uTotc0i8+X8z5dS3n5Y4vgzdqyEtOcZ1D1b6nyAa5vlGafT/bYLFx4vHTyX+vfmQ6C7NgKXOjLacM3Rm16HrVGwPe9Ib90pV0fR5vbXqXN06upmsV9aia11CeO5e16b47En/apeM23K35inLASfl3gpS4DAwQICkIMfgOoJXFkg//F/plLK05RSPmaYLzFd9nYcUCQff9oBzH/402lZ+io+Dm6mt7+0ylM9b20H7i2KI3dGXhq92Op41ja1pl/lS/SrlVIS+CToqJs3JsVt7Uv/3hGBtCed0JbJ2lvPZ/rzL94YXYldFkDISFp26c6918Ajc46W2pl3Mys8Zc+O8Whe6/1d8/y1EY6978gl9zOdeD6+1jTdau13tHUJ47l7Xtu/4+s2UjTrAhoJuDPimL188qEkf9N6loe+xFRZAgRuKCAAuSGuSxM4QCBfWjMR92eGzcfqLeQ/5nMpLD23uNTBqJ3fta/qSe/Iij5zufxb97LWyUsH/+VutPlgUkoy8jOXLrY3tWapYzftHCbNKqkySXPLiEs64TWPfm3VonTcMrE797Nn3k4C1ezZ8lYLq0ltPYs9P6+7cGcZ2LkVq3KN3HfuIefkHV0LPHJ+Hc3Liltze9rsua9bnHNk+tXa6Np44vn4PZpbia1nCeOp5doSu1sLJIwXEkjAPf57VVPD9s4vu8Uzdk0CBK4oIAC5IqZLEXgAAnvz/3tvtX7NnXYE6qT15OKvreSUTk46nD0d37VOXjpa11jedcllKYDbs3rVWseuThp+zlLKW5RSsgfL3NyJ2rGb+5udztn7l1K+qLFTnqAtI2UZRbjVkffiWXfUkTasvTfjOUxZDevS1cKu2d6tEY5bpl9trSQ3nnieNq+txHaP9Ku873PpkzVNbG0uzzXu75rP3bUIELhAQAByAZ6iBB6YwFrn4lq3Ov3iX1cg+omhE7z0pXtcfzoSv9q4YtFWJ+9a7Wu5zt7Vq5Y6TrHLponfNuyx8jkraW95tglQxqMwtVO+ttHkVnsyXyQdwp4Rqa1r159n1Cud8N5J4nnnEiTVldv21nuv845Mv0qA96SFeUHTiefxWOvE3yP9amkvk0ygz1LLcyuI1ee4ld55r+etHgIEriAgALkCoksQeCACe9OBlm63Tk5PvvUzDyfVzeuShpSUnRwvOHyBTn3pFGylzUzrq6sgbY2WjMtd2rZbPKK9q1ctdezS6cqozefvSI+r59Yli+vmkJemItVn0foM93jm2lnSNcvxvkZHDn8CvHcbgq60f2nzwT33cstz1kbB9r4jPfc3l15VrzOdeF7//dK7eK30q6U5HlvpV3uW796aU9RjqAwBAgcJCEAOglctgRsIzH3drCvJpLoXGurMl8afnfnqXVen+uphDklO/67Rfda0l1zzycOSvu+wo/M819Q6GX1vx3ctjSVpJrc80smfS/lZW72q3s/cV+iWe62TcjMZ/eOGghkJyUIC2Zl+LRWp7oC9NdG8roqUyeDZlHLPKNZSGxJwvGwp5aWHgPXDhxGWvEc9aVO1DS8+BCMZsfn+Usp/GNLVWpcPTsCc3cCveWS+ztLO3HlHcvzyFSp878nv2trvxNw+H2tBxjXSm9aCjLXV62oQvLa7eQK5V+5YtvsK7C5BgMAtBAQgt1B1TQLHCIw7Oy9TSklqzr8ZTcyuuddvN+wJMk2J2cpVryszZS+KT99I20mndqtzWIOQpP/kekvHntWvMi/g2kcM0/FZ2lU6e2isdZpyP+l4LQUwa/ebNr9xKeWvlVK+pJSSuT0ZRUjQMZ2gO3edOjr1LMOKUVubSdbJ4HnG77Hj2aXOBBt1tKzu6XJpwLH1DHN/CaSz30XSeWKSL+NZLSmBya8N+9/k/69H3RCvzqPJCN41j+y3s/Su534vPTI/KAHF+F1b20dnacL2VvpV/l5cesxtmLiVPlk3F12aYP6Qllu+1Ed5AgQGAQGIV4HAE0cgnc5MYs6RuQVzX7LzJT2dhOmKTmudhL3Lo1bJ6b4ja8LpfOSr+9rX963Vr37wBsvJvkQp5aOGZWTnOu/pzGWlsbW5E3H7gB1BytinWqczVtOtsjTt3sCjpi09fSklo1Px/dxSyqvvHKmqo2B1z5PxnjEJZjJ6kGVR0xlOsFH3hekd4bjGb19dgCAd9UyqT1pbgqPcZ+657hOytj/FNe7jVteYjmas7fmRe8hE76xUN31vrzHHo6eNe9In68hU5vnUYC7PNUvv5oPHLTbL7GmLMgQIXElAAHIlSJch8IAE8nU0S5RmcvM3jO4rX/TzNT1pLNMleecmgbYGHuP9GTI6kH+yNO5WSs87llL+ZCnlXRfOXUt1SqdqTx3Tx5MRhRyxmB5xyqpXS8vZLq0ENr5O634nmdORvQ9+cTRhu45izG0uN/e6LU3Wzr9/3WFEZc9rmnchwctXDZ2/7Ir9fcPIQgKNayzpXFOrMnrwlXtuqvGcutFi7GrqV8smeI3V3fT06fLLGVXL6OVcat3SbujXmOPR28itkdV63bynCTiyi3qOT7lgye7ee1WOAIE7CQhA7gStGgJ3FMjX+Uzq/KZSynOM6l0aFckp6eSM9waoaRH5El6/xK81oa6Glc5eRg4SdGytbJM63reU8lMrq9+srTSVTlUmOE83WtxDXZcrnkuR2epgz+XXT+vcs9Ff2p82JPDIyFXmeIznSaTtCRhfbKNB41GPpY350vnODvZbq12N012y0V9GEPY8/z3meUdyzQRDzzB0oDNSkZGLzAW6ViBS95PI6ls1zXArzWfP/R9xTg1ka/rV2lyItUnp15jj0dP+rfSrnmsqQ4DAE0BAAPIEeIiaQGAikK/6087sGtJSikT+fTqkb7shXNN2phPK11a7Gm86trb05toqQjXQ6lnetXe/lLQ1czOyE/fayM5ah2+823NSqxJkLE3QTid6ad+L8XW2lqitHfDc15JXbVsNYhKc5fy0t/dIp/hVSymvVUrJf2/y1T4bUY7nTNQlhhOI5L0db77YU2++uH/jJHDaWoWpp557lBkHu1upV2n3OOga399DTr+6h6M6CBB4YAICkAf2QNwOgSsITEcz1i6ZL/CZg7E0ATQdmqRSzc2DGK+GtfTlvc4Hmc5BqDu2rwUfue9bpF/luj0BSMtk2HS8P2IYoan+08Bj72TyuVGImrL1NTsnpece6mpXmRMyTd9ZCqzilDkVW2l043dsT9Ax904mEMl78teHEbmsxpb3rqXupPPlv2vT9yojQEub4F3hV+5mlxinX22lXtWFAKY3szZSmGeV9/LS4ykLc4z2pl9dWr/yBAg8MgEByCN7YG6XwA6BPZ3rdDrecFhdp07SXeoUTr+C17kemdD+waWUL9joJKZzmz1E6u7nS53Eaf3T9JPxzy+ZUDy3qd8a654Up7ny49GLnoChBg3jQKZeZy5la8er8TudzTrp/4OGAmujOlujabFJml+Wok1Ht86fmRvp2HN/OSf3mIUSXn609G4CkR8e5qIsBSR1DsF0dKqufrW3/od0XuZB5Hen/i7kdzuB2deWUr55uNGtkZGlkcLqksUELjmyJHfP6leX1KksAQKPXEAA8sgfoNsnMBFI5/r9N5a1rV9K33k0X2MNMsucZtPAzCF5nWHOQlJ+tgKP8TUzH+RVSinfU0p52p3zNtbmWlwyobimFi0t3VuXls1+KekE5/8m0NqaPzE1rIFX9oDI39qWtLjxtTKfJ53IdLAvuU695jgI+aFh4u9SStl49+m6IlaWwa3BxlMNy+BmfkkmqK/NM+r9Za1L76bOdHYT2MU0QcnPDZPis3FmRj2WRvJ6635o5erk/UzWzopknzlsDPp5KyvBLS3UcEkQX13W5njsWf3qofm6HwIE7iQgALkTtGoI3Emgpr9kdaGlo3XJ1HRU0pnI1+29y8HO1Z1OdPZg2Jo/Ucsm/WRtn43W1KB63ToCsuTzk8MSu+ncZnng6Yphex9lnQNTl7TdW256XtwSCO3dtHFvPXueR557Nj7MkUAsK2LV0YiMwvTa7L3HufPyjidIzKhL7ulPDEvunm2p1vEmjUsLMdQUyPFqeNU0yxTnQ0LPHKp6jbwf2aF+6cjo2NZ+QJe8C8oSIPBIBQQgj/TBuW0CdxRIR/pdSimfeIXORK7VktN/x2bepKprtDcdzVt19LfuL3VncvhRwcZNHsqJLprnl2Bt6bjFiNWJeDWVAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINA1C6DSAAAaQ0lEQVQsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAECBAgQIECAQLOAAKSZTAECBAgQIECAAAECBHoFBCC9csoRIECAAAECBAgQINAsIABpJlOAAAECBAgQIECAAIFeAQFIr5xyBAgQIECAAAECBAg0CwhAmskUIECAAAECBAgQIECgV0AA0iunHAECBAgQIECAAAECzQICkGYyBQgQIECAAAECBAgQ6BUQgPTKKUeAAAEC/639OiQAAABgENa/9TNwvQCYOQgQIECAAIEsYEAymYAAAQIECBAgQIAAgVfAgLxyOgIECBAgQIAAAQIEsoAByWQCAgQIECBAgAABAgReAQPyyukIECBAgAABAgQIEMgCBiSTCQgQIECAAAECBAgQeAUMyCunI0CAAAECBAgQIEAgCxiQTCYgQIAAAQIECBAgQOAVMCCvnI4AAQIECBAgQIAAgSxgQDKZgAABAgQIECBAgACBV8CAvHI6AgQIECBAgAABAgSygAHJZAICBAgQIECAAAECBF4BA/LK6QgQIECAAAECBAgQyAIGJJMJCBAgQIAAAQIECBB4BQzIK6cjQIAAAQIECBAgQCALGJBMJiBAgAABAgQIECBA4BUwIK+cjgABAgQIECBAgACBLGBAMpmAAAECBAgQIECAAIFXwIC8cjoCBAgQIECAAAECBLKAAclkAgIECBAgQIAAAQIEXgED8srpCBAgQIAAAQIECBDIAgYkkwkIECBAgAABAgQIEHgFDMgrpyNAgAABAgQIECBAIAsYkEwmIECAAAECBAgQIEDgFTAgr5yOAAECBAgQIECAAIEsYEAymYAAAQIECBAgQIAAgVfAgLxyOgIECBAgQIAAAQIEsoAByWQCAgQIECBAgAABAgReAQPyyukIECBAgAABAgQIEMgCBiSTCQgQIECAAAECBAgQeAUMyCunI0CAAAECBAgQIEAgCxiQTCYgQIAAAQIECBAgQOAVMCCvnI4AAQIECBAgQIAAgSxgQDKZgAABAgQIECBAgACBV8CAvHI6AgQIECBAgAABAgSygAHJZAICBAgQIECAAAECBF4BA/LK6QgQIECAAAECBAgQyAIGJJMJCBAgQIAAAQIECBB4BQzIK6cjQIAAAQIECBAgQCALGJBMJiBAgAABAgQIECBA4BUwIK+cjgABAgQIECBAgACBLGBAMpmAAAECBAgQIECAAIFXwIC8cjoCBAgQIECAAAECBLKAAclkAgIECBAgQIAAAQIEXgED8srpCBAgQIAAAQIECBDIAgYkkwkIECBAgAABAgQIEHgFDMgrpyNAgAABAgQIECBAIAsYkEwmIECAAAECBAgQIEDgFTAgr5yOAAECBAgQIECAAIEsYEAymYAAAQIECBAgQIAAgVfAgLxyOgIECBAgQIAAAQIEsoAByWQCAgQIECBAgAABAgReAQPyyukIECBAgAABAgQIEMgCBiSTCQgQIECAAAECBAgQeAUMyCunI0CAAAECBAgQIEAgCxiQTCYgQIAAAQIECBAgQOAVMCCvnI4AAQIECBAgQIAAgSxgQDKZgAABAgQIECBAgACBV8CAvHI6AgQIECBAgAABAgSygAHJZAICBAgQIECAAAECBF4BA/LK6QgQIECAAAECBAgQyAIGJJMJCBAgQIAAAQIECBB4BQzIK6cjQIAAAQIECBAgQCALGJBMJiBAgAABAgQIECBA4BUwIK+cjgABAgQIECBAgACBLGBAMpmAAAECBAgQIECAAIFXwIC8cjoCBAgQIECAAAECBLKAAclkAgIECBAgQIAAAQIEXgED8srpCBAgQIAAAQIECBDIAgYkkwkIECBAgAABAgQIEHgFDMgrpyNAgAABAgQIECBAIAsYkEwmIECAAAECBAgQIEDgFTAgr5yOAAECBAgQIECAAIEsYEAymYAAAQIECBAgQIAAgVfAgLxyOgIECBAgQIAAAQIEsoAByWQCAgQIECBAgAABAgReAQPyyukIECBAgAABAgQIEMgCBiSTCQgQIECAAAECBAgQeAUMyCunI0CAAAECBAgQIEAgCxiQTCYgQIAAAQIECBAgQOAVMCCvnI4AAQIECBAgQIAAgSxgQDKZgAABAgQIECBAgACBV8CAvHI6AgQIECBAgAABAgSygAHJZAICBAgQIECAAAECBF4BA/LK6QgQIECAAAECBAgQyAIGJJMJCBAgQIAAAQIECBB4BQzIK6cjQIAAAQIECBAgQCALGJBMJiBAgAABAgQIECBA4BUwIK+cjgABAgQIECBAgACBLGBAMpmAAAECBAgQIECAAIFXwIC8cjoCBAgQIECAAAECBLKAAclkAgIECBAgQIAAAQIEXgED8srpCBAgQIAAAQIECBDIAgYkkwkIECBAgAABAgQIEHgFDMgrpyNAgAABAgQIECBAIAsYkEwmIECAAAECBAgQIEDgFTAgr5yOAAECBAgQIECAAIEsYEAymYAAAQIECBAgQIAAgVfAgLxyOgIECBAgQIAAAQIEsoAByWQCAgQIECBAgAABAgReAQPyyukIECBAgAABAgQIEMgCBiSTCQgQIECAAAECBAgQeAUMyCunI0CAAAECBAgQIEAgCxiQTCYgQIAAAQIECBAgQOAVMCCvnI4AAQIECBAgQIAAgSxgQDKZgAABAgQIECBAgACBV8CAvHI6AgQIECBAgAABAgSygAHJZAICBAgQIECAAAECBF4BA/LK6QgQIECAAAECBAgQyAIGJJMJCBAgQIAAAQIECBB4BQzIK6cjQIAAAQIECBAgQCALDKaBYhHwAfHPAAAAAElFTkSuQmCC&quot; alt=&quot;&quot;&gt;&lt;/body&gt;&lt;/html&gt; 9.见缝插针游戏案例index.html代码12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;见缝插针&lt;/title&gt; &lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .container&#123; width: 700px; margin: 20px auto; height: 700px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;700&quot; height=&quot;700&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;script src=&quot;js/play.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268/** * 见缝插针: * 1.转动小球 * 1) 大圆及关卡 * 初始转动小球绘制时需要一定的角度 , 如果从等待小球区域上的球插进需要绘制数字 = &gt; 对象 * 每个小球 = &#123; angle : 0 , numStr:1 &#125; * * 2) 大圆上的小球 * * 2.等待小球 * * 因为是游戏: 一切的数据要灵活 , 各个小功能都需要重复的被调用 = &gt; 需要一定封装(提高复用性) * *///截取地址上的参数// var url = document.URL;// var index = url.split(&quot;#&quot;).slice(-1)*1 - 1;var index = window.location.hash.substring(1);index = index&lt;1?1:index;console.log(index);/***********************游戏的初始模拟数据(废弃)***********************************/var GameData = [ &#123; level:1, ballNum:3, waitNum:5, speed:1 &#125;, &#123; level:2, ballNum:4, waitNum:6, speed:1.5 &#125;,&#123; level:3, ballNum:5, waitNum:7, speed:1.5 &#125;,&#123; level:4, ballNum:5, waitNum:8, speed:1.5 &#125;,&#123; level:5, ballNum:5, waitNum:8, speed:2 &#125;,&#123; level:6, ballNum:6, waitNum:8, speed:2 &#125;];/***********************游戏的界面基本配置***********************************/var centerX = 350; // 大圆的中心xvar centerY = 200; //大圆的中心yvar bigRadius = 50;//大圆的半径var radius = 10; //小球的半径var line = 80;//大圆至小球之间的间距// var index = 0;//游戏数据中的关卡索引值var isOver = false;//游戏是否结束//游戏数据var level = null;//关卡var ballNum = null;//转动小球数量var waitNum = null;//等待小球数量var speed = null;// 转动的速度 = &gt; 角度var balls = null;//用于存储转动小球数组var waitBalls = null;//用于存储等待小球数组var timer = null;//动画ID/***********************游戏的实现业务流程***********************************/var canvas = document.getElementById(&quot;canvas&quot;);var cxt = canvas.getContext(&quot;2d&quot;);//配置全局位移 , 字体居中 cxt.translate(centerX,centerY); cxt.textAlign=&quot;center&quot;; cxt.textBaseline = &quot;middle&quot;; //定义一个绘制大圆的函数 function drawBig()&#123; cxt.save(); cxt.beginPath(); cxt.arc(0,0,bigRadius,0,Math.PI*2); cxt.closePath(); cxt.fillStyle = &quot;#000&quot;; cxt.fill(); //绘制关卡数字 cxt.fillStyle=&quot;#fff&quot;; cxt.font=&quot;50px 微软雅黑&quot;; cxt.fillText(level,0,0); cxt.restore(); &#125; //定义一个方法 绘制转动小球 function drawBall()&#123; balls.forEach(function (item) &#123; cxt.save(); cxt.rotate(Math.PI / 180 * item.angle); //为下一次绘制 ,重新计算角度 item.angle += speed; //优化: 角度控制在360度以内 ,因为再多视觉没有区别, 但是程序绘制计算还是会根据角度的计算绘制 -&gt; 造成资源浪费 item.angle%=360; cxt.beginPath(); cxt.moveTo(0,-bigRadius); cxt.lineTo(0,-(bigRadius + line)); cxt.closePath(); cxt.stroke(); cxt.beginPath(); cxt.arc(0,-(bigRadius + line + radius),radius , 0 , Math.PI * 2); cxt.closePath(); cxt.fill(); //绘制小球上的数字 if(item.numStr!=&quot;&quot;)&#123; cxt.fillStyle=&quot;#fff&quot;; cxt.font=&quot;bold 12px 微软雅黑&quot;; cxt.fillText(item.numStr,0,-(bigRadius + line + radius)); &#125; cxt.restore(); &#125;) &#125; //定义一个方法 绘制等待小球 function drawWait()&#123; //清除之前的小球 ,然后才重新绘制 var h = canvas.height; var distance = h - centerY - (bigRadius + line + (2 * radius) + (2 * radius)); var y = bigRadius + line + (2 * radius) + (2 * radius); //开始清除区域y坐标 cxt.clearRect(-radius,y,2 * radius,distance); waitBalls.forEach(function (item , index) &#123; cxt.save(); cxt.beginPath(); cxt.arc(0,bigRadius + line + (2 * radius) + (2 * radius) + radius + (index * 3 * radius) , radius , 0 , Math.PI*2); cxt.fill(); cxt.fillStyle = &quot;#fff&quot;; cxt.font=&quot;bold 12px 微软雅黑&quot;; cxt.fillText(item.numStr,0,bigRadius + line + (2 * radius) + (2 * radius) + radius + (index * 3 * radius)); cxt.closePath(); cxt.restore(); &#125;) &#125; //定义一个动画方法 function animte()&#123; cancelAnimationFrame(timer);//清空之前的动画函数 var w = bigRadius + line + 2 * radius; //需要清除的矩形的宽度 //清除之前的绘制区域 cxt.clearRect(-w,-w,2 * w,2 * w); drawBig(); drawBall(); //使用递归实现动画 timer = requestAnimationFrame(animte); &#125; //定义一个根据当前关卡位置 ,生成游戏数据函数 function createData()&#123; level =index;//关卡 var base = parseInt(index / 4);//基数 var obj = &#123; ballNum:3, waitNum:5, speed:1 &#125; for (var i=1;i&lt;index;i++)&#123; if(i%4==0)&#123; obj.speed +=0.5; obj.speed = obj.speed&gt;=30?30:obj.speed; &#125;else if(i%3==0)&#123; obj.ballNum+=1; &#125;else if(i%2==0)&#123; obj.waitNum+=1; &#125;else&#123; obj.waitNum+=1; &#125; &#125; console.log(obj,base); ballNum = obj.ballNum;//转动小球数量 waitNum = obj.waitNum;//等待小球数量 speed = obj.speed;// 转动的速度 = &gt; 角度 &#125; //定义一个游戏初始化方法 function initGame()&#123; createData();//生成游戏数据 balls = [];//用于存储转动小球数组 waitBalls = [];//用于存储等待小球数组 //准备转动小球数据 (初始数据): for (var i=0;i&lt;ballNum;i++)&#123; var angle = 360 / ballNum * i; //计算初始状态下每个转动小球的角度位置 balls.push(&#123; angle:angle, numStr:&quot;&quot; &#125;) &#125; //准备等待小球的数据(初始数据) for (var i=waitNum;i&gt;0;i--)&#123; waitBalls.push(&#123; angle:&quot;&quot;, numStr:i &#125;) &#125; //绘制各种小球 drawBig(); drawBall(); drawWait(); animte(); canvas.onclick = null; //绑定单击事件 : 把等待区域的小球 插入到 转到小球区域 canvas.onclick = function () &#123; if(waitBalls.length==0)return; if(!isOver)&#123; //计算会碰球的夹角 var a = Math.asin(2 * radius / (bigRadius + line + radius)) / Math.PI * 180; // console.log(a); //循环判断是否有撞球: 判断每个转动小球是否有在碰球角度范围: 180 - a &lt;= x &lt;= 180 + a for (var i=0;i&lt;balls.length;i++)&#123; if(balls[i].angle&gt;= (180 - a) &amp;&amp; balls[i].angle&lt;= (180 + a))&#123; // console.log(&quot;碰球了&quot;,balls[i].angle); alert(&quot;游戏失败,请重新开始!&quot;); isOver = true; &#125; &#125; //判断游戏是否成功 if(!isOver)&#123; var tmp = waitBalls.shift();//删除等待数组的第一个 // console.log(tmp); tmp.angle = 180; //追加到转动小球数组中 balls.push(tmp); drawWait(); if(waitBalls.length==0)&#123; alert(&quot;本关已经通过,马上进入下一关&quot;); index++; initGame(); &#125; &#125; &#125; &#125; &#125;/***********************游戏接口调用********************************/ initGame();//游戏初始化 // //首先绘制 , 使用定时器 // var timer = setInterval(function()&#123; // // &#125;,1000 / 60); window.onhashchange = function () &#123; console.log(&quot;hash发生变化!&quot;); index = window.location.hash.substring(1); initGame(); &#125; requestAnimationframe动画12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box&#123; position: absolute; left: 0; width: 100px; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt; /** * 以前jQ 动画的原理是使用的setTimeout (按照时间间隔触发 , 延迟一些卡顿) * * requestAnimation H5新增(W3C 在后期不打算继续更新 , 如果要考虑使用还的做兼容性) * 好处: * 1.不需要设置时间 , 浏览器会自动设置最佳更新频率 ,并且浏览器已经做了优化 * * 2.动画不是按照时间间隔实现, 而是与系统时间同步 ,保障动画实时流畅 * * 3.该方法的动画 可以在元素不可见,隐藏时停止渲染 * * 4.当前浏览器页面不可见,标签页失去焦点时间动画会挂起, 减少CPU / GPU 资源损耗 * * * 阅读资料: https://www.w3cplus.com/javascript/requestAnimationFrame.htmls * */ var d = 1200; var s = 0; var box = document.getElementById(&quot;box&quot;); var timer; function animate()&#123; s+=10; box.style.left =s + &#x27;px&#x27;; timer = window.requestAnimationFrame(animate); if(s&gt;=d)&#123; cancelAnimationFrame(timer); &#125; &#125; animate();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 10.数据可视化svg矢量图的绘制123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 400px; height: 400px; margin: 50px auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- svg绘图其实和canvas差不多，就是使用的标签不一样，还有canvas是写在js里面，而svg是写在行内会canvas也就会了svg，但是svg绘图都不会直接手写代码，而是用AI等矢量图绘图软件来绘制，这样会更加的高效 --&gt;&lt;div class=&quot;container&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;300px&quot; height=&quot;100px&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;300&quot; height=&quot;100&quot; fill=&quot;pink&quot; stroke-width=&quot;1&quot; /&gt; &lt;circle cx=&quot;0&quot; cy=&quot;50&quot; r=&quot;15&quot; fill=&quot;blue&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot;&gt; &lt;animate attributeName=&quot;cx&quot; from=&quot;0&quot; to=&quot;300&quot; dur=&quot;1s&quot; repeatCount=&quot;indefinite&quot; /&gt; &lt;/circle&gt; &lt;/svg&gt;&lt;/div&gt;&lt;img src=&quot;img/a.svg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;img/c.svg&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;svg width=&quot;400&quot; height=&quot;400&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;50&quot; stroke=&quot;green&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot;&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Echarts 百度的ECharts目前在国内使用的比较多，所以总结了一些相关知识；官网地址，详细的可以参考：http://echarts.baidu.com/index.html 特性介绍 ECharts，一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的 Canvas 类库 ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。 ECharts 3 中更是加入了更多丰富的交互功能以及更多的可视化效果，并且对移动端做了深度的优化。 基本使用​ html代码(需要自己去Echarts官网下载相应的版本，查看文档，引入其js来编写代码，当然，你感觉自己牛逼就自己用原生的canvas画) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;&lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var main =document.getElementById(&quot;main&quot;); //1.使用echarts 初始化生成canvas var myChart = echarts.init(main); //2.指定图表的配置项和数据 var option = &#123; title: &#123; text: &#x27;ECharts 入门示例&#x27; &#125;, tooltip: &#123;&#125;, legend: &#123; data:[&#x27;销量&#x27;] &#125;, xAxis: &#123; data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;] &#125;, yAxis: &#123;&#125;, series: [&#123; name: &#x27;销量&#x27;, type: &#x27;pie&#x27;, data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // var option = &#123; // title: &#123; // text: &#x27;多雷达图&#x27; // &#125;, // tooltip: &#123; // trigger: &#x27;axis&#x27; // &#125;, // legend: &#123; // x: &#x27;center&#x27;, // data:[&#x27;某软件&#x27;,&#x27;某主食手机&#x27;,&#x27;某水果手机&#x27;,&#x27;降水量&#x27;,&#x27;蒸发量&#x27;] // &#125;, // radar: [ // &#123; // indicator: [ // &#123;text: &#x27;品牌&#x27;, max: 100&#125;, // &#123;text: &#x27;内容&#x27;, max: 100&#125;, // &#123;text: &#x27;可用性&#x27;, max: 100&#125;, // &#123;text: &#x27;功能&#x27;, max: 100&#125; // ], // center: [&#x27;25%&#x27;,&#x27;40%&#x27;], // radius: 80 // &#125;, // &#123; // indicator: [ // &#123;text: &#x27;外观&#x27;, max: 100&#125;, // &#123;text: &#x27;拍照&#x27;, max: 100&#125;, // &#123;text: &#x27;系统&#x27;, max: 100&#125;, // &#123;text: &#x27;性能&#x27;, max: 100&#125;, // &#123;text: &#x27;屏幕&#x27;, max: 100&#125; // ], // radius: 80, // center: [&#x27;50%&#x27;,&#x27;60%&#x27;], // &#125;, // &#123; // indicator: (function ()&#123; // var res = []; // for (var i = 1; i &lt;= 12; i++) &#123; // res.push(&#123;text:i+&#x27;月&#x27;,max:100&#125;); // &#125; // return res; // &#125;)(), // center: [&#x27;75%&#x27;,&#x27;40%&#x27;], // radius: 80 // &#125; // ], // series: [ // &#123; // type: &#x27;radar&#x27;, // tooltip: &#123; // trigger: &#x27;item&#x27; // &#125;, // itemStyle: &#123;normal: &#123;areaStyle: &#123;type: &#x27;default&#x27;&#125;&#125;&#125;, // data: [ // &#123; // value: [60,73,85,40], // name: &#x27;某软件&#x27; // &#125; // ] // &#125;, // &#123; // type: &#x27;radar&#x27;, // radarIndex: 1, // data: [ // &#123; // value: [85, 90, 90, 95, 95], // name: &#x27;某主食手机&#x27; // &#125;, // &#123; // value: [95, 80, 95, 90, 93], // name: &#x27;某水果手机&#x27; // &#125; // ] // &#125;, // &#123; // type: &#x27;radar&#x27;, // radarIndex: 2, // itemStyle: &#123;normal: &#123;areaStyle: &#123;type: &#x27;default&#x27;&#125;&#125;&#125;, // data: [ // &#123; // name: &#x27;降水量&#x27;, // value: [2.6, 5.9, 9.0, 26.4, 28.7, 70.7, 75.6, 82.2, 48.7, 18.8, 6.0, 2.3], // &#125;, // &#123; // name:&#x27;蒸发量&#x27;, // value:[2.0, 4.9, 7.0, 23.2, 25.6, 76.7, 35.6, 62.2, 32.6, 20.0, 6.4, 3.3] // &#125; // ] // &#125; // ] // &#125;; //3.在图表实例中 ,使用 数据 并且绘制 myChart.setOption(option);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 笔记数据可视化实现技术领域: 1.canvas = &gt; 绘制出来 2.Svg =&gt; xml格式的 =====================================常见用于制作canvas数据可视化工具: 图表库: 1. charts (精简) 2.Echarts(功能多) 3.go.js (流程图 , ERP图 , 树状结构图...) 4.three.js = &gt; 3d 场景 (物理引擎)","categories":[],"tags":[{"name":"HTML5+css3","slug":"HTML5-css3","permalink":"https://1314xulujin.github.io/tags/HTML5-css3/"}]},{"title":"BFC块格式化上下文","slug":"BFC块格式化上下文","date":"2019-11-15T23:32:14.000Z","updated":"2020-06-21T13:10:21.234Z","comments":true,"path":"2019/11/16/BFC块格式化上下文/","link":"","permalink":"https://1314xulujin.github.io/2019/11/16/BFC%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"什么是BFC？为什么这个概念一直被提起？？为什么每一个人都解释不清BFC？？？ 什么是BFC？BFC 全称为 块格式化上下文 (Block Formatting Context) 。 从这个概念里你能看出来什么吗？ 这个名字给我们的信息只有 “块” “格式化” “上下文” 。我们大概可以了解到这个东西是对上下文起作用的。 那里的上下文？？ HTML文档！ 它大概的作用，貌似是格式化上下文？？可能不是我们通常意义中的格式化。 我们没有从这个名字中得到太多有用的信息，仅仅知道它是一种功能，针对于 HTML文档 起作用。 那我们去看看官方是怎么解释的。 MDN： 一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。 一个块格式化上下文由以下之一创建： 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素具有 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 具有overflow 且值不是 visible 的块元素， display: flow-root column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。 块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。 我们发现一个什么问题！貌似看不懂哎！！ 为什么会产生这样的原因？？ 你能解释一下什么是桌子吗？？ 仔细想想，发现好像并不能合理的解释它。 BFC 也是如此，只有特性(功能)，没有定义。 I know it when i see it. BFC 特性(功能) 使 BFC 内部浮动元素不会到处乱跑； 和浮动元素产生边界。 使 BFC 内部的浮动元素不会到处乱跑 HTML 没有产生 BFC CSS 在正常的文档流中，块级元素是按照从上自下，内联元素从左到右的顺序排列的。 如果我给里面的元素一个 float 或者绝对定位，它就会脱离普通文档流中。 没有产生 BFC 此时如果我们还想让外层元素包裹住内层元素该如果去做？？ 让外层元素产生一个 BFC 。(产生 BFC 的方法 MDN 文档里有写) 产生 BFC 这就是 BFC 的第一个作用：使 BFC 内部的浮动元素不会到处乱跑。 和浮动元素产生边界 HTML CSS 没有产生 BFC 一般情况下如果没有 BFC的话，我们想要让普通元素与浮动元素产生左右边距，需要将 maring 设置为浮动元素的宽度加上你想要产生边距的宽度。 这里的浮动元素的宽度为 200px ，如果想和它产生 20px 的右边距，需要将非浮动元素的 margin-left 设置为 200px+20px 。 产生了 BFC 总结不要试图去讲解 BFC 的定义！！ 如何说明 BFC ，举例子！！不要试图去讲定义！！ I know it when i see it.","categories":[],"tags":[{"name":"BFC","slug":"BFC","permalink":"https://1314xulujin.github.io/tags/BFC/"}]},{"title":"函数柯里化及其使用到的案例","slug":"函数柯里化","date":"2019-11-14T07:42:20.000Z","updated":"2020-06-21T13:10:21.352Z","comments":true,"path":"2019/11/14/函数柯里化/","link":"","permalink":"https://1314xulujin.github.io/2019/11/14/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"","text":"函数柯里化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; /** * 定义: * 在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数， * 并且返回接受余下的参数且返回结果的新函数的技术。 * * 好处: * 1.实现参数单一传入 实现参数复用 * 2.缓存函数执行的参数 ,减少重复计算 = &gt; 延迟计算 (延迟处理某些任务,因考虑到后面还有其他的任务) * * 使用场景: * 1.比如说再一些需要动态传参的场景下使用,就是函数需要执行的参数可能还不能确定 * 2.多次操作任务, 可以先把前面的任务暂存 ,等到最后一次执行时,先判断之前的任务是否还具有执行的意义,如果没有意义就不执行 * 3.浏览器的兼容性的检测, 按照常规,会写一个兼容性处理方法,(不使用柯理化,需要每次调用都要检测一次) ,柯理化后就可以优化整个流程,每次页面加载只检测一次 * 调用方式: curry(a)(b)(c)(d) */ //封装一个加法计算的函数 // function add(a,b)&#123; // return a+b; // &#125; // // //原来的想法 // var num1 = add(10,20); // var num2 = add(10,30); // // //定义一个柯理化函数 ((柯理化)) // function curryAdd(a)&#123; // return function(b)&#123; // 闭包 // return add(a,b); // &#125; // &#125; // // var first = curryAdd(10); // console.log(first(20)); // =&gt; 30 // // // console.log(first); // //使用柯理化之后 // var num3 = first(20); // var num4 = first(30); //实现一个可以计算多个数字的之和的方法 // function add()&#123; // // console.log(arguments); // //为了避免计算错误 ,判断是否带有参数 // if(!arguments.length)&#123; // return 0; // &#125; // var args = [].slice.call(arguments); //为了借数组的方法 // return args.reduce(function (item,total) &#123; // return total+=item; // &#125;) // // // console.log(args); // //arguments 伪数组 ,就是传入方法中的参数的集合 // // console.log(arguments.length); // &#125; // var num = add(10,20,50,3,50,60,40,50,30); // var num = add(); // function fn()&#123; // // &#125; //柯理化后 // function curryAdd(fn)&#123; // var nums = [];//用于缓存调用时存储进来的参数 // return function fn(a)&#123; // if(arguments.length)&#123; // var args = [].slice.call(arguments); // // nums.push(a); // nums = nums.concat(args); // console.log(nums); // return fn; // &#125; // //如果执行该方法时,已经不带参数 ,则直接计算所有存储的参数 ,一次计算(合并计算) // console.log(&quot;不带参数时,表示该计算结果了!&quot;); // // return add.apply(null,nums); // &#125; // &#125; // // var ss = curryAdd(); // ss == fn // ss(10); //可能后面还有数字需要一起计算 ,所以此时的函数暂时先不计算 ,可以把参数暂时缓存nums中 // ss(20)(10,50)(50,10); // console.log(ss()); //缓存功能 //传统做法: 不足就是 ,每次通过addEvent() 做兼容性的绑定时间 ,都会把内部的判断逻辑执行一次 ,如果需要绑定三个事件 ,就需要执行三次 兼容性检测 // function addEvent(type,el,fn,capture = false)&#123; // if(window.addEventListener)&#123; // el.addEventListener(type,fn,capture); // &#125;else if(window.addachEvent)&#123; // el.addachEvent(&quot;on&quot; + type,fn); // &#125; // &#125; //柯理化之后的 : 使用addEvent 函数做兼容绑定事件 ,只需要检测一次兼容性,后面就直接使用缓存的结果去绑定事件 ,如果绑定三个事件,其实只检测一次兼容性 var addEvent = (function()&#123; if(window.addEventListener)&#123; return function(type,el,fn,capture)&#123; var capture = capture || false; el.addEventListener(type,fn,capture); &#125; &#125;else if(window.attachEvent)&#123; return function(type,el,fn)&#123; el.attachEvent(&quot;on&quot; + type,fn); &#125; &#125; &#125;)(); console.log(addEvent) // addEvent(&quot;click&quot;,document.getElementById(&quot;box&quot;)); // addEvent(&quot;click&quot;,document.getElementById(&quot;box&quot;)); // addEvent(&quot;click&quot;,document.getElementById(&quot;box&quot;));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 函数柯里化复习版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //首先定义一个相加的方法方便下面调用 // function add(a,b)&#123; // return a+b; // &#125; // // 一个最简单的例子 // function curryAdd(a)&#123; // return function(b)&#123; // return add(a,b); // &#125; // &#125; // // console.log(curryAdd(10)); // var first = curryAdd(10);//这个10代表a是第一层 // console.log(first(50));//50已经是第二次调用就是第二层 //实现多个数字相加(利用到数组的方法reduce)，但是没使用函数柯里化每次都会出结果，相当于计算重复了多次 function add()&#123; console.log(arguments);//arguments是伪数组，浏览器自带 if( !arguments.length )&#123; return 0; &#125; var args = [].slice.call(arguments);//arguments是伪数组没有数组的方法，利用call方法借用数组的slice方法 return args.reduce(function(item,total)&#123; return total +=item; &#125;); &#125; // console.log(add(10,50,80)); //然后利用到函数柯里化来实现多个数字相加 function curryadd(fn)&#123; var nums = [];//定义一个空的数组来存储写入需要相加的数字 return function fn(a)&#123; if( arguments.length )&#123; var args = [].slice.call(arguments); // nums.push(a); nums = nums.concat(args);//因为nums是外面一层变量加了return可以返回出去，所以把里面的数字合并给nums console.log(nums); return fn; &#125; return add.apply(null,nums) &#125; &#125; var adds = curryadd(); adds(10,10)(10);//柯里化把需要计算的数字先存好 console.log(adds());//最后一次计算，提高性能 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"函数柯里化","slug":"函数柯里化","permalink":"https://1314xulujin.github.io/tags/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"}]},{"title":"对象的call方法和数组的apply方法","slug":"对象的call方法和数组的apply方法","date":"2019-11-14T07:42:20.000Z","updated":"2020-06-21T13:10:21.370Z","comments":true,"path":"2019/11/14/对象的call方法和数组的apply方法/","link":"","permalink":"https://1314xulujin.github.io/2019/11/14/%E5%AF%B9%E8%B1%A1%E7%9A%84call%E6%96%B9%E6%B3%95%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84apply%E6%96%B9%E6%B3%95/","excerpt":"","text":"对象的call方法和数组的apply方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt; &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script&gt; &#x2F;&#x2F;其实在js中 , 方法也是一个对象 , 那么在方法类型的对象中 , 会具有 apply() , call() 方法 function abc()&#123;&#125; console.dir(abc); &#x2F;** * apply() 与 call() 方法 的作用: * 相同: 在某一对象的方法中,使用指定的对象身份去执行该方法 . &#x3D; &gt; &quot;借鸡下蛋&quot; * * 不同点 : 传参数方式 * apply : 以数组传参 * call : 逐个参数传递 * * 在实现一个对象中自身没有的方法,通过一定手段或者方式可以从其他对象中执行到该方法的手段 即可视为继承. *&#x2F; var obj1 &#x3D; &#123; name:&quot;张三&quot;, sing:function (a,b,c,d) &#123; console.log(&quot;我是:&quot;+this.name,&#39;我能唱歌!&#39;,&#39;拿手歌曲:&#39;,a,b,c,d); &#125; &#125; &#x2F;&#x2F;调用obj1 的 sing 方法 &#x2F;&#x2F; obj1.sing(); var obj2 &#x3D; &#123; name:&quot;李四&quot;, dance:function()&#123; console.log(&quot;我是:&quot;+this.name,&quot;我能跳舞!&quot;); &#125; &#125; &#x2F;&#x2F; obj2.dance(); var songList &#x3D; [&#39;中国话&#39;,&#39;我和我的祖国&#39;,&#39;我的中国心&#39;,&#39;追光者&#39;]; &#x2F;&#x2F;call(用哪个对象的身份去执行,执行该方法的参数) 上场 - &gt; 调用call() 方法 &#x2F;&#x2F; obj1.sing.call(obj2,&#39;中国话&#39;,&#39;我和我的祖国&#39;,&#39;我的中国心&#39;,&#39;追光者&#39;); &#x2F;&#x2F; &#x3D; &gt; 我是:李四 我能唱歌! obj1.sing.apply(obj2,songList); obj2.dance.call(obj1); &#x2F;&#x2F; &#x3D; &gt; 我是:张三 我能跳舞! &#x2F;&#x2F;使用场景1: var arr &#x3D; [10,20,30,40,50,60,80,0,20,60]; &#x2F;&#x2F; console.log(Math.max(arr)); &#x2F;&#x2F; 因为内置的Math.max等方法 ,只支持参数一个个传递 ,所以如果直接传数组会无法识别&#x3D; &gt; NaN console.log(Math.max.apply(null,arr)); &#x2F;&#x2F;使用ES6语法 console.log(Math.max(...arr)); &#x2F;&#x2F;使用场景2: 在一些复杂的业务场景下,为了实现对象方法的引用(继承) : &#x2F;&#x2F; 就是A中本身没有abc方法 ,但是B有 ,那么怎么办,就可以通过apply&#x2F;call方法 实现在A对象的身份情况下执行到B &#x2F;&#x2F; 中的abc方法(可以稍微理解为A中有abc方法了,虽然也不是有)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; apply方法复习版12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0,minimum-scale&#x3D;1.0,maximum-scale&#x3D;1.0&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt; &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;script&gt; &#x2F;&#x2F;Math.min(20,30,50);Math.min传参方式是直接写一串数字，每个用逗号隔开，检测出最小的一个数字。 var arr &#x3D; [10,20,50,30,520];&#x2F;&#x2F;如果想传进去一个数组，则必须用到apply方法 console.log(Math.min.apply(null,arr));&#x2F;&#x2F;这样也可以比较出数组中最小的一个数字 &#x2F;&#x2F;ES6新增 ... 这三个点通俗叫展开 console.log(Math.min(...arr));&#x2F;&#x2F;和上面用到apply效果一样 &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[],"tags":[{"name":"call和apply","slug":"call和apply","permalink":"https://1314xulujin.github.io/tags/call%E5%92%8Capply/"}]},{"title":"Web Worker的原理","slug":"WebWorker处理大量计算js脚本","date":"2019-11-11T08:27:25.000Z","updated":"2020-06-21T13:10:21.262Z","comments":true,"path":"2019/11/11/WebWorker处理大量计算js脚本/","link":"","permalink":"https://1314xulujin.github.io/2019/11/11/WebWorker%E5%A4%84%E7%90%86%E5%A4%A7%E9%87%8F%E8%AE%A1%E7%AE%97js%E8%84%9A%E6%9C%AC/","excerpt":"","text":"Web Workerweb worker 是运行在后台的 JavaScript，不会影响页面的性能。 = &gt; 单独在后台再开一个线程用于处理任务 ,不影响浏览器前台的js线程 简而言之: WebWorker 就是让原本单线程JS 实现多线程的操作 当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。 = &gt; js引擎单线程 可以把一些计算复杂,庞大的运算逻辑通过worker去处理 这样就不会影响到前台页面的渲染 注意: 后台线程的任务中无法操作DOM , 只要是跟浏览器前台页面交互的东西都无法完成 没有使用webworker的代码（浏览器会先计算再进行渲染（单线程处理任务暂停页面渲染））12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是一个问候语!!!!!&lt;/h1&gt; &lt;script&gt; var sum = 0; for(var i=0;i&lt;10000000000;i++)&#123; sum*=i; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用webworker把大量计算的js单独写一个js文件我们命名为task.js1234567891011121314151617181920//taks.js 是需要在后台程序执行的一个脚本文件this.onmessage = function (e) &#123; sum+=e.data; console.log(e);&#125;var sum = 1;for(var i=1;i&lt;1000000000;i++)&#123; sum+=i;&#125;function abc()&#123; console.log(&quot;执行了一个Abc方法 &quot;);&#125;abc();//向前台发送执行结果postMessage(sum); 然后在页面中调用的时候需要实例化一个worker对象1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这是一个问候语!!!!!&lt;/h1&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt; //页面 (前台) 调用 H5 提供提供的worker = &gt; 相当于创建一个线程 var worker = new Worker(&quot;task.js&quot;); //在后台的线程中执行task.js 的代码 console.log(worker); /** * worker 中提供的 * -事件 * onerror : 后台线程执行错误触发的事件 * onmessage : 后台线程执行完可以调用一个方法给前台的js发送消息用来传值 * * -方法 * postMessage() 后台线程向前台发送消息 * terminate() 取消任务 , 如需终止 web worker，并释放浏览器/计算机资源，请使用 terminate() 方法 * * */ worker.onerror = function (e) &#123; console.log(&quot;后台线程执行task任务失败!&quot;,e); &#125; worker.onmessage = function (e) &#123; console.log(&quot;后台线程发消息过来了!&quot;,e); document.getElementById(&quot;box&quot;).innerHTML=&quot;计算结果为:&quot;+e.data; &#125; worker.postMessage(&quot;这是一个结果&quot;);//向task.js执行线程发送数据&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样页面会先渲染出来，需要大量计算的js则会交给另一个线程处理","categories":[],"tags":[{"name":"Web Worker","slug":"Web-Worker","permalink":"https://1314xulujin.github.io/tags/Web-Worker/"}]},{"title":"websocket基础","slug":"websocket通信基础","date":"2019-11-11T08:15:25.000Z","updated":"2020-06-21T13:10:21.316Z","comments":true,"path":"2019/11/11/websocket通信基础/","link":"","permalink":"https://1314xulujin.github.io/2019/11/11/websocket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/","excerpt":"","text":"websocket基础websocket 通信协议特点:​ 1.不受浏览器同源策略限制​ 2.长连接协议​ 3.双向通信协议(只要通信连接了,那么就会一直保持,除非有一端 主动断开,那就断开连接) http / https / ftp 通信协议http协议特点 : (单向通信)​ 1.http协议是一种无状态协议。（每次访问服务器时，没有办法识别身份）​ 2.短连接协议（每次通信完毕就断开了）​ 3.http协议是一种单向通信协议（只能由客户的端主动向服务器发出请求，然后接受响应，服务器端不能主动给客户端发送消息）​ 4.每次发起HTTP请求时，都会将浏览器缓存的cookie发送给服务器端。​ 5.每次只能处理一个请求（两张图片，就是两个请求）​ 6.简单、快捷、高效 =====================================================================================电脑上的二维码图片 : 识别结果 = &gt; https://login.weixin.qq.com/l/IbliFrl0WQ== 打开手机微信扫描后就会先解析二维码 ,然后进行二维码地址的访问 =&gt; https://login.weixin.qq.com/l/IbliFrl0WQ== 因为手机上的微信是已经登录过的 ,所以通过手机微信浏览器访问这个地址的时候 ,服务器那边就知道是谁在访问 .此时还携带了一个与打开页面相同标识的参数 : IbliFrl0WQ== 所以此时 : 微信的登录服务器 会把 IbliFrl0WQ== 映射到 张三或者李四某一个账户 电脑版前端页面怎么知道有没有扫描,或者是哪微信个账号扫过码??? 传统的方式 : 由pc页面 使用ajax 请求微信服务器 ,会带上一个标识码 IbliFrl0WQ== ,去查询服务器上哪个账户与它曾经关联过, 如果查询到有关联的账户,就会把该账户的各种数据(微信的基本信息和联系人)返回,如果没有的话,还需要继续等待,稍后继续询问服务器是否有人扫码 ,直至有确认有人扫码登录了 (当然为了安全考虑,微信会设置标识码的存活时间5分钟左右,如果超时就会换一个) ========================================================================生活例子: 小明本来想去买套房, 今天去售楼处问了一下 ,本来想买一套120平 , 但是目前剩余只有80平 或者200平 , 但是售楼处的小姐跟他说,可能会有后期(没有明确时间)有增加房源 ,然后小明就会回家 … 最终有没有房源,只有售楼处才清楚, 如果真要去解解决这个问题,应该让售楼处 有房源的时候主动通知小明 (比较好的方案) 过两天 再去售楼处问问有没有房 , 没有 再过两天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 再过十天 再去售楼处问问有没有房 , 没有 ======================================================================比如网页的数据需要实时更新 怎么实现? 1.使用ajax ,设置每隔1s请求一次 = &gt; 轮询 请求频率高 ,性能低,极度浪费服务器的资源 ,请求的时间间隔不一 2.websocket 协议: 只要连接上了 ,服务器数据有更新,自动推送到客户端 节约大量的http请求资源 ,效率高, 实时性强 websocket协议使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; /* Websocket 构造函数 ,提供ws协议的使用 , 实现双向通信(全双工通信) WebSocket协议的目标是在一个独立的持久连接上提供全双工双向通信。客户端和服务器可以向对方主动发送和接受数据。在JS中创建WebSocket后，会有一个HTTP请求发向浏览器以发起请求。在取得服务器响应后，建立的连接会使用HTTP升级将HTTP协议转换为WebSocket协议。也就是说，使用标准的HTTP协议无法实现WebSocket，只有支持那些协议的专门浏览器才能正常工作。 WebSocket是应用层协议，是TCP/IP协议的子集，通过HTTP/1.1协议的101状态码进行握手。也就是说，WebSocket协议的建立需要先借助HTTP协议， 在服务器返回101状态码之后，就可以进行websocket全双工双向通信了，就没有HTTP协议什么事情了。 需要提前准备一个ws协议 的后台 Websocket 对象 属性: readyState : 当前连接状态 = &gt; CLOSED: 3 CLOSING: 2 CONNECTING: 0 OPEN: 1 url : 连接地址 protocol :协议 事件: onclose: 关闭连接事件 onerror: 连接错误事件 onmessage: 消息事件 (后端主动发送消息过来触发的事件) onopen: 连接成功 方法: close() 关闭连接 send() 发送消息 */ var ws = new WebSocket(&quot;ws://172.16.4.1:8000&quot;); //连接事件 - 成功 ws.onopen = function()&#123; console.log(&quot;已经建立连接...&quot;); &#125;; //连接失败事件 ws.onerror = function()&#123; console.log(&quot;连接建立失败...&quot;); &#125;; //消息事件 ws.onmessage = function (e) &#123; console.log(&quot;后端发消息来了...&quot;,e.data); &#125; //关闭连接事件 ws.onclose = function () &#123; console.log(&quot;关闭连接事件!&quot;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面用服务器搭建了一个群聊（可以使用接口来获取信息也可发送信息）1234567891011121314151617181920212223242526272829303132333435363738地址已经封装在js中了 ,后台会返回一个js脚本只需要引入脚本即可ws : http:&#x2F;&#x2F;m.lby.link:8888js地址: http:&#x2F;&#x2F;m.lby.link:8888&#x2F;socket.io&#x2F;socket.io.js可以直接使用已经封装好的js脚本库 io对象&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;m.lby.link:8888&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;------------------------------消息发送方----------------------------------------- var txt &#x3D; document.getElementById(&quot;txt&quot;); var socket &#x3D; io.connect(&#39;http:&#x2F;&#x2F;m.lby.link:8888&#39;);&#x2F;&#x2F;获取监听 var send &#x3D; function()&#123; &#x2F;&#x2F;emit 发射 ,其实就是触发服务端监听的client事件 var data &#x3D; &#123; username:&quot;张三&quot;, msg:txt.value &#125; socket.emit(&#39;client&#39;,data);&#x2F;&#x2F;发送给服务端数据 &#125;-----------------------------消息接收方------------------------------------- var container &#x3D; document.querySelector(&quot;#container&quot;); var socket &#x3D; io.connect(&#39;http:&#x2F;&#x2F;m.lby.link:8888&#39;);&#x2F;&#x2F;获取监听 socket.on(&#39;server&#39;,function(data)&#123;&#x2F;&#x2F;监听服务端发送过来的事件 container.innerHTML+&#x3D;&quot;&lt;br&#x2F;&gt;&quot;+data.username + &quot;:&quot; + data.msg; &#125;);---------------------------统一发送的数据格式规范------------------------------发送的数据格式 : json 对象 &#123; username:&quot;发送者姓名&quot;, msg:&quot;发送的消息&quot;, sex:&quot;男&quot;, timestamp:new Date().getTime() &#125; 在线智能机器人对话123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt; &lt;title&gt;在线智能对话&lt;&#x2F;title&gt; &lt;style&gt; body&#123; font-family:&quot;微软雅黑&quot;; font-size: 12px; &#125; .container&#123; position: relative; width: 60%; margin: 0 auto; padding: 15px 0; border: 1px solid #ccc; border-radius: 5px; overflow: hidden; height: 90vh; &#125; #chat-box&#123; height: 90%; overflow: auto; padding-bottom:20px; &#125; .chat&#123; position: relative; padding: 15px; width: 100%; max-width: 60%; margin: 5px 0; border-radius: 5px; &#125; .chat.other&#123; float: left; background:#2aabd2; &#125; .chat.self&#123; float: right; background: #48ca09; &#125; .chat.system&#123; width: auto; max-width: 80%; color: #999; margin: 0px auto; background: none; text-align: center; &#125; .chat.system span&#123; background: #f1f1f1; &#x2F;*display: inline-block;*&#x2F; padding: 4px 8px; border-radius: 5px; &#125; .chat .date&#123; position: absolute; top: 3px; left:0px; color: #fff; text-align: left; padding-left: 20px; font-size: 12px; &#125; .chat .info&#123; padding-top: 10px; color: #333; &#125; .msg-box:after&#123; content: &quot;&quot;; display: block; clear: both; &#125; #send-box&#123; position: absolute; bottom: 0; padding: 5px 10px; width: 100%; background: #2aabd2; &#125; #send-box input&#123; padding: 5px 8px; border: 1px solid #ccc; width: 50%; &#125; #send-box button&#123; border: 0; padding: 6px 10px; cursor: pointer; &#125; #send-box button:hover&#123; background: red; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;div id&#x3D;&quot;chat-box&quot;&gt;&lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;send-box&quot;&gt; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;msg&quot;&gt; &lt;button class&#x3D;&quot;send&quot;&gt;发送&lt;&#x2F;button&gt; &lt;button class&#x3D;&quot;close&quot;&gt;断开&lt;&#x2F;button&gt; &lt;button class&#x3D;&quot;reconnect&quot;&gt;重新连接&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;js&#x2F;jquery-v1.12.0.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;js&#x2F;moment.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;** * 每次发完消息, 滚动最后一条记录 : 滚动距离 &#x3D; 最后一条消息 距离聊天窗口容器的顶部距离(包括滚动距离) * *&#x2F; var ws &#x3D; null;&#x2F;&#x2F; ws 实例对象 &#x2F;&#x2F;定义一个连接方法 function connect()&#123; ws &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;172.16.4.1:8000&quot;); &#x2F;&#x2F;绑定一些事件 ws.onopen &#x3D; function () &#123; writeSystemMessage(&quot;已经与服务器建立连接...&quot;); &#125; ws.onclose &#x3D; function () &#123; writeSystemMessage(&quot;您已经与服务器断开连接...&quot;); &#125; ws.onmessage &#x3D; function (e) &#123; writeChatMessage(e.data,&quot;other&quot;); &#125; ws.onerror &#x3D; function () &#123; writeSystemMessage(&quot;网络异常,请重新连接...&quot;); &#125; &#125; &#x2F;&#x2F;定义一个生成系统消息的方法 function writeSystemMessage(msg)&#123; var str &#x3D; $(&quot;&lt;div class&#x3D;&#39;msg-box&#39;&gt;&lt;div class&#x3D;&#39;chat system&#39;&gt;&lt;span&gt;&quot;+moment(new Date()).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)+&quot; &quot; + msg+&quot;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&quot;); $(&quot;#chat-box&quot;).append(str); scrollLastMessage(); &#x2F;&#x2F; console.log(msg); &#125; &#x2F;&#x2F;定义一个写入聊天信息的方法 function writeChatMessage(msg,role)&#123; &#x2F;&#x2F; msg 消息 , role 发送消息角色 var str &#x3D; $(&quot;&lt;div class&#x3D;&#39;msg-box&#39;&gt;&lt;div class&#x3D;&#39;chat &quot;+role+&quot;&#39;&gt;&lt;div class&#x3D;&#39;date&#39;&gt;&quot;+moment(new Date()).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)+&quot;&lt;&#x2F;div&gt;&lt;div class&#x3D;&#39;info&#39;&gt;&quot;+msg+&quot;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&quot;); $(&quot;#chat-box&quot;).append(str); scrollLastMessage(); &#125; &#x2F;&#x2F;定义一个滚动到最后一条消息位置 function scrollLastMessage()&#123; &#x2F;&#x2F;先获取最后一条消息距离网页顶部的距离 var topH &#x3D; $(&quot;.msg-box:last&quot;)[0].offsetTop; &#x2F;&#x2F;给消息盒子设置滚动距离 $(&quot;#chat-box&quot;).scrollTop(topH); &#125; &#x2F;&#x2F;进入聊天页面 ,自动连接 connect(); &#x2F;&#x2F;绑定发送消息事件 $(&quot;.send&quot;).click(function()&#123; if(ws.readyState&#x3D;&#x3D;1)&#123; var msg &#x3D; $(&quot;#msg&quot;).val(); writeChatMessage(msg,&quot;self&quot;); &#x2F;&#x2F;向服务器发送消息 ws.send(msg); $(&quot;#msg&quot;).val(&quot;&quot;); &#125;else&#123; writeSystemMessage(&quot;网络异常,请尝试重新连接...&quot;) &#125; &#125;) &#x2F;&#x2F;绑定断开连接 $(&quot;.close&quot;).click(function()&#123; if(ws.readyState!&#x3D;3)&#123; ws.close();&#x2F;&#x2F;关闭连接 &#125; &#125;) &#x2F;&#x2F;重新连接 $(&quot;.reconnect&quot;).click(connect); &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://1314xulujin.github.io/tags/websocket/"}]},{"title":"css3弹性盒子布局","slug":"css3弹性盒子布局","date":"2019-11-04T08:08:58.000Z","updated":"2020-06-21T13:10:21.265Z","comments":true,"path":"2019/11/04/css3弹性盒子布局/","link":"","permalink":"https://1314xulujin.github.io/2019/11/04/css3%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80/","excerpt":"","text":"CSS3弹性盒布局方式 风起云涌Hal关注 12018.01.09 17:26:02字数 866阅读 78,971 一、CSS3弹性盒子弹性盒子是CSS3的一种新布局模式。 CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。 引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。 二、浏览器支持表格中的数字表示支持该属性的第一个浏览器的版本号。 紧跟在数字后面的 -webkit- 或 -moz- 为指定浏览器的前缀。 属性 Basic support (single-line flexbox) 29.0 21.0 -webkit- 11.0 22.0 18.0 -moz- 6.1 -webkit- 12.1 -webkit- Multi-line flexbox 29.0 21.0 -webkit- 11.0 28.0 6.1 -webkit- 17.0 15.0 -webkit- 12.1 三、CSS3 弹性盒子内容弹性盒子由弹性容器(Flex container)和弹性子元素(Flex item)组成。 弹性容器通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器。 弹性容器内包含了一个或多个弹性子元素。 注意： 弹性容器外及弹性子元素内是正常渲染的。弹性盒子只定义了弹性子元素如何在弹性容器内布局。 弹性子元素通常在弹性盒子内一行显示。默认情况每个容器只有一行。 以下元素展示了弹性子元素在一行内显示，从左到右: 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;FLEX&lt;/title&gt; &lt;style&gt; .flex-container &#123; display: flex; flex-direction: row; flex-wrap: wrap; width: 1200px; height: 640px; background-color: lightsteelblue; &#125; .flex-container .flex-item &#123; width: 320px; height: 240px; margin: 10px; background-color:lightsalmon; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;flex-container&quot;&gt; &lt;div class=&quot;flex-item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;flex-item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;flex-item&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 四、CSS3 弹性盒子常用属性 属性 描述 flex-direction 指定弹性容器中子元素排列方式 flex-wrap 设置弹性盒子的子元素超出父容器时是否换行 flex-flow flex-direction 和 flex-wrap 的简写 align-items 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式 align-content 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 justify-content 设置弹性盒子元素在主轴（横轴）方向上的对齐方式 1. flex-direction 属性决定项目的方向。 注意：如果元素不是弹性盒对象的元素，则 flex-direction 属性不起作用。 1.flex-container &#123; flex-direction: row | row-reverse | column | column-reverse; &#125; 属性值 值 描述 row 默认值。元素将水平显示，正如一个行一样。 row-reverse 与 row 相同，但是以相反的顺序。 column 元素将垂直显示，正如一个列一样。 column-reverse 与 column 相同，但是以相反的顺序。 2. flex-wrap 属性flex-wrap 属性规定flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。 值 描述 nowrap 默认值。规定元素不拆行或不拆列。 wrap 规定元素在必要的时候拆行或拆列。 wrap-reverse 规定元素在必要的时候拆行或拆列，但是以相反的顺序。 1.flex-container &#123; flex-wrap: nowrap | wrap | wrap-reverse; &#125; 可以取三个值：（1） nowrap (默认)：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3. flex-flow 属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 1.flex-container &#123; flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt; &#125; 4. align-items属性align-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。 值 描述 stretch 默认值。项目被拉伸以适应容器。 center 项目位于容器的中心。 flex-start 项目位于容器的开头。 flex-end 项目位于容器的结尾。 baseline 项目位于容器的基线上。 5. justify-content属性justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。 值 描述 flex-start 默认值。项目位于容器的开头。 flex-end 项目位于容器的结尾。 center 项目位于容器的中心。 space-between 项目位于各行之间留有空白的容器内。 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 五、弹性子元素属性 属性 描述 order 设置弹性盒子的子元素排列顺序。 flex-grow 设置或检索弹性盒子元素的扩展比率。 flex-shrink 指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。 flex-basis 用于设置或检索弹性盒伸缩基准值。 flex 设置弹性盒子的子元素如何分配空间。 align-self 在弹性子元素上使用。覆盖容器的 align-items 属性。 1. order属性1.flex-container .flex-item &#123; order: &lt;integer&gt;; &#125; ：用整数值来定义排列顺序，数值小的排在前面。可以为负值，默认为0。 2. flex-grow属性1.flex-container .flex-item &#123; flex-grow: &lt;integer&gt;; &#125; ：一个数字，规定项目将相对于其他灵活的项目进行扩展的量。默认值是 0。 3. flex-shrink属性1.flex-container .flex-item &#123; flex-shrink: &lt;integer&gt;; &#125; ：一个数字，规定项目将相对于其他灵活的项目进行收缩的量。默认值是 1。 4. flex-basis属性1.flex-container .flex-item &#123; flex-basis: &lt;integer&gt; | auto; &#125; ：一个长度单位或者一个百分比，规定元素的初始长度。auto：默认值。长度等于元素的长度。如果该项目未指定长度，则长度将根据内容决定。 5. flex属性flex 属性用于设置或检索弹性盒模型对象的子元素如何分配空间。 flex 属性是 flex-grow、flex-shrink 和 flex-basis 属性的简写属性。 1.flex-container .flex-item &#123; flex: flex-grow flex-shrink flex-basis | auto | initial | inherit; &#125; 值 描述 flex-grow 一个数字，规定项目将相对于其他元素进行扩展的量。 flex-shrink 一个数字，规定项目将相对于其他元素进行收缩的量。 flex-basis 项目的长度。合法值：”auto”、”inherit” 或一个后跟 “%”、”px”、”em” 或任何其他长度单位的数字。 auto 与 1 1 auto 相同。 none 与 0 0 auto 相同。 initial 设置该属性为它的默认值，即为 0 1 auto。 inherit 从父元素继承该属性。 6. align-self属性123.flex-container .flex-item &#123; align-self: auto | stretch | center | flex-start | flex-end | baseline | initial | inherit;&#125; 值 描述 auto 默认值。元素继承了它的父容器的 align-items 属性。如果没有父容器则为 “stretch”。 stretch 元素被拉伸以适应容器。 center 元素位于容器的中心。 flex-start 元素位于容器的开头。 flex-end 元素位于容器的结尾。 baseline 元素位于容器的基线上。 initial 设置该属性为它的默认值。 inherit 从父元素继承该属性。 取值同 align-items。","categories":[],"tags":[{"name":"css3","slug":"css3","permalink":"https://1314xulujin.github.io/tags/css3/"}]},{"title":"Ajax数据交互","slug":"Ajax数据交互","date":"2019-10-22T01:38:47.000Z","updated":"2020-06-21T13:10:21.231Z","comments":true,"path":"2019/10/22/Ajax数据交互/","link":"","permalink":"https://1314xulujin.github.io/2019/10/22/Ajax%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/","excerpt":"","text":"Ajax数据交互 何为数据交互? =&gt; 前后端数据的交互 (前端向后端发起数据请求 ,由后端响应数据给前端) Ajax : 在浏览器与服务器之间异步加载数据 . (web2.0重要技术) 可以在不重载整个页面的情况下 ,更新页面的某一块内容 因涉及后端数据交互 ,所以需要有后端服务.(后台 / 服务器环境) 准备工作: 搭建一个本地开发测试(服务器)环境搭建一台本地的web服务器 ,让自己的pc充当为一台本地的服务器(其实就是一台性能比普通电脑更高的电脑,24小时不关机,给其他的pc或终端提供服务使用). 目前主流的服务器的操作系统: windows server 2008 (窗口式操作) Linux (centOS ) Unix 常见的服务: ​ web服务:搭建网站提供给互联网用户访问 ​ smtp服务: 提供电子邮件发送服务 ​ ftp服务: 提供文件共享服务(传输) 常用于搭建web服务的软件: IIS 微软 因特网信息服务 (运行在windows服务器上) Apache (linux , windows) Nginx (linux) (推荐 ,服务器首选) Nodejs (linux , windows) Tomcat (linux , windows) 在真实项目的上一般会选用Linux操作系统(nginx / apache)的服务器 (小型,或者个人项目可能会使用IIS的windows服务)12345678910111213本地的开发测试环境 ,可以使用一些集成的环境 &#x3D; &gt; XAMPPXAMPP集成: 1.Apache (阿帕奇服务) 2.PHP (后端语言) 3.Mysql (数据库) 4.FileZilla ( FTP 服务 ) 5.Tomcat (运行java web的服务) 安装完 XAMPP 打开控制面板 ,start 启动 apache 服务 ,服务默认会运行在80端口 , 访问方式:​ (本地) http://localhost (localhost 是本地的主机名称 , 只能访问当前设备上的服务) http://127.0.0.1 (所有的网络设备 ,都有一个本地的回路地址 : 127.0.0.1 ) 可以访问其他的网络设备提供的服务 172.16.4.1 (可以使用为当前网络下 ,可以被访问的其他设备的web服务) http://class4 (class4名称是当前运行apache服务的计算机名) 相当于 www.baidu.com 安装目录下的 : htdocs (存放网站程序的目录) web服务默认会以网站根目录下 ,文件名为 index的文件作为当前站点的首页 使用FTP 上传 文件 至服务器 ftp 地址 : ftp://class4 账号: wt18 密码: 123456 浏览器的地址栏 , 输入 www.baidu.com 然后按回车 =&gt; 发生了什么事情? 互联网上通信 , 只能通过 IP 地址进行寻址 .1.按下回车 : 先对需要访问的域名进行解析 = &gt; DNS (域名解析 ) 将域名解析为对应的 ip 地址 ​ 解析: 1. 本地解析 (优先使用) 2. DNS服务解析 2.地址解析成功之后 , 就直接进行http请求访问… 经常在开发场景中 , 需要模拟多站点通信 , apache 运行配置多个虚拟主机 : 配置本地的解析文件 : C:\\Windows\\System32\\drivers\\etc\\hosts (在很多软件破解时也会使用到) 配置一个本地域名 m.com 配置一个本地域名 s.com 12127.0.0.1 m.com127.0.0.1 s.com 2.配置apache 的虚拟主机找到apahce 的安装目录 (E:\\xampp\\apache\\conf\\extra\\httpd-vhosts.conf) 参考配置如下: 12345678910111213#配置 s.com&lt;VirtualHost*:80&gt; ServerAdmin admin@s.com DocumentRoot &quot;&#x2F;xampp&#x2F;htdocs&#x2F;s.com&quot; ServerName s.com&lt;&#x2F;VirtualHost&gt;#配置 m.com&lt;VirtualHost*:80&gt; ServerAdmin admin@m.com DocumentRoot &quot;&#x2F;xampp&#x2F;htdocs&#x2F;m.com&quot; ServerName m.com&lt;&#x2F;VirtualHost&gt; 所有的配置 ,修改完之后 ,都需要重启 apache 服务 生效. 搭环境与不搭环境的区别: ​ http服务环境: http://m.com ​ 没有环境: file:///E:/xampp/htdocs/s.com/index.html jQuery 中的ajax:(万能)ajax()12345678910111213141516171819ajax(&#123; url:&quot;请求的服务器的url地址&quot;, //[必须] type:&quot;get&quot;,// post , put , delete 请求方式 (method 也可以 , 效果一样) data:&quot;需要发送给服务器的数据&quot;, dataType:&#x27;服务器返回的数据类型&#x27;,//text , html ,css , script , json , jsonp async:true,//(默认为true) 是否异步操作 beforeSend:function()&#123;//开始发送请求执行 执行 &#125;, complete:function()&#123;//请求过程结束(完成, 无论成功失败) &#125;, success:function(data)&#123;//请求成功的回调函数 , data 请求成功的数据 &#125;, error:function(error)&#123;//请求失败 执行 &#125;&#125;) 异步: 在同一时刻 ,在执行一个任务时 ,也可以继续执行其他任务同步:在同一时刻,同时只能处理一个任务 (V8引擎 , 每次同时只能处理一个js任务) ,如果该任务还未执行完毕,那么下一个任务,就要等待该任务执行完之后才能进行. 注意:浏览器js引擎是单线程应用,每次只能执行一个任务 , 如果此时为同步请求 ,(请求时间稍长一些就更明显) ,会导致js 引擎运行暂停(堵塞) 造成 = &gt; “页面假死” 页面假死 : 1.页面的交互无响应 (右键无反应 , 包括浏览器中的一些事件处理都将失去反应) 2.暂停渲染 post() : 通过http post方式发起请求1post(请求服务器地址[必须],发送的数据,请求成功回调函数,服务器返回数据类型) get() :通过http get方式发起请求1get(请求服务器地址[必须],发送的数据,请求成功回调函数,服务器返回数据类型) getScript() : 通过http get请求方式 ,获取服务器上的一段 js脚本 ,并运行1getScript(请求服务器地址[必须]) load() : 使用在jQ对象上 ,直接把请求的内容显示到对应的DOM上getJSON() : 使用get 请求 ,获取服务器上的json数据 (主流 )JSON : 是JavaScript 对象的表示方式 ,用于数据交换格式. 123456789101112131415161718192021222324//json格式 ,就是组键值对关系 = &gt; 对象的形式 (通过对象属性方式调用 .属性名)&#123; &quot;键名1&quot;:键值1, &quot;键名2&quot;:键值2, &quot;键名3&quot;:键值3 &#125;//数组形式 (使用时候 ,用下标找到对应的对象 )[ &#123; &quot;键名1&quot;:键值1, &quot;键名2&quot;:键值2, &quot;键名3&quot;:键值3 &#125;,&#123; &quot;键名1&quot;:键值1, &quot;键名2&quot;:键值2, &quot;键名3&quot;:键值3 &#125;,&#123; &quot;键名1&quot;:键值1, &quot;键名2&quot;:键值2, &quot;键名3&quot;:键值3 &#125;] (已经逐步淘汰)XML: 是一种互联网应用交换数据格式 (xml是扩展型标记语言 ,类似于html) XML与JSON的区别1详见 : https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;243deb64bcb5 需要具备一定的数据结构设计能力. ( 对后端提供的数据要求 , 编写模拟数据)模拟数据 , 数据结构与真实的后端接口数据格式一致 ,但是是本地模拟使用,用于在前后端开发时 ,后端暂未将后台的接口数据开发完时,提供前端本地开发模拟使用. 1234567891011121314151617181920212223242526272829轮播图: 每张轮播图需要的数据 : 1. 图片的地址 2.图片的跳转链接地址 &#123; picUrl:&quot;图片地址&quot;, url:&quot;点击的超链接跳转地址&quot; &#125; [ &#123; picUrl:&quot;图片地址&quot;, url:&quot;点击的超链接跳转地址&quot; &#125;,&#123; picUrl:&quot;图片地址&quot;, url:&quot;点击的超链接跳转地址&quot; &#125;,&#123; picUrl:&quot;图片地址&quot;, url:&quot;点击的超链接跳转地址&quot; &#125;,&#123; picUrl:&quot;图片地址&quot;, url:&quot;点击的超链接跳转地址&quot; &#125;,&#123; picUrl:&quot;图片地址&quot;, url:&quot;点击的超链接跳转地址&quot; &#125; ]例举京东单个商品展示列表 : 商品的6款型号图片 \\ 价格 \\ 商品的标题 \\ 评价的数量 \\ 店铺的名称 \\ 商品的跳转链接 \\ 店铺的链接 \\ 评价的跳转链接 \\ 是否二手在售 ,跳转地址 \\ 商品的特性 \\ 商品的SID \\ 是否广告 \\ 客服的地址 渲染:1.后端渲染:​ 服务端在返回 html 之前，在特定的区域，符号里用数据填充，再给客户端，客户端只负责解析 HTML ​ 2.前端渲染(客户端渲染):​ html 仅仅作为静态文件，客户端端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，然后根据 html 上的 JavaScript，生成 DOM 插入 html。 前端渲染不利于SEO优化(内容需要在客户端通过js生成,所以爬虫抓取的时候是没有内容的,或者内容不多)https://www.jianshu.com/p/0719c6102639 1京东左侧导航分类 接口地址:https:&#x2F;&#x2F;dc.3.cn&#x2F;category&#x2F;get?&amp;callback&#x3D;getCategoryCallback 发送数据:GET请求方式123通过请求的地址中传递发送给后台的数据 &#x3D; &gt; QueryString (查询字符串)http:&#x2F;&#x2F;m.com&#x2F;api&#x2F;?name&#x3D;张三&amp;age&#x3D;20&amp;sex&#x3D;男 POST请求方式12通过post特定方式传输 格式可以为 QueryString &#x2F; 表单数据 (字符串) [注意] : 前后端数据交互中 , 没有json对象的概念 (php没有json对象的概念的,因为json是js中对象的表示形式) 虽然php中不存在json对象 ,但是为了更方便于前端js交互 ,后端有 json字符串(长得像json格式的字符串)的概念. (但是数据的类型其实就是字符串) 1一般的后台返回的数据格式 ,其实就是字符串类型数据 (只不过外观长得像json) &#x3D; &gt; json 字符串 前端处理json字符串格式数据:123456&#x2F;&#x2F;1.json序列化 &#x3D; &gt; 将json字符串 , 解析为json对象 (方便js使用)JSON.parse()&#x2F;&#x2F;2.json反序列化 &#x3D; &gt; 将json对象 ,转换为json字符串 (一般在发送对象格式数据给后台 , 进行对象格式数据的存储之类操作)JSON.stringify() 1.原生ajax (基础的原理)1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;*原生ajax : XMLHttpRequest 对象 &#x3D; XHR * 属性: readyState: 请求过程状态 0:未初始化 1:正在建立连接 2:发送数据 3:接收数据 (并没有接收完毕) 4:接收数据完成 ,请求结束 response: 响应内容 responseText: 响应文本内容 responseType: 响应内容类型 responseURL: 响应服务器地址 responseXML: 响应XML内容 status: 0 http响应的状态码 statusText: http响应的状态文本提示内容 timeout: 0 超时时间 * * 方法: * abort() 取消请求 * open() 建立连接(打开连接) * send() 发送数据 * setRequestHeader() 设置请求包头 * getResponseHeader() 获取响应包头 * getAllResponseHeaders() 获取所有响应包头 * * 事件: * onabort: 取消事件 onerror: 请求错误事件 onload: 请求成功 onloadend: 请求结束 onloadstart: 开始请求 onprogress: 请求的进度 onreadystatechange: 请求过程状态改变事件 ontimeout: 请求超时事件 upload : 用于上传文件时使用 (H5文件操作再说) * * * *&#x2F; http协议 HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 HTTP协议的特点 ： http协议是一种无状态协议。（每次访问服务器时，没有办法识别身份） 短连接协议（每次通信完毕就断开了） http协议是一种单向通信协议（只能由客户的端主动向服务器发出请求，然后接受响应，服务器端不能主动给客户端发送消息） 每次发起HTTP请求时，都会将浏览器缓存的cookie发送给服务器端。 每次只能处理一个请求（两张图片，就是两个请求） 简单、快捷、高效 http协议约定浏览器端与服务器端之间的通信规范:从浏览器发起请求(数据包) : Request : (告知服务器,我需要什么,你要做什么)1234HTTP请求由状态行、请求头、请求正文三部分组成：1.状态行：包括请求方式Method、资源路径URL、协议版本Version；2.请求头：包括一些访问的域名、用户代理、Cookie等信息；3.请求正文：就是HTTP请求的数据。 服务器响应客户端请求(数据包): Response:(告知浏览器,我给了你什么,你该怎么玩)12345HTTP响应由三部分组成：状态行、响应头、响应正文；状态行：包括协议版本Version、状态码Status Code、回应短语；响应头：包括搭建服务器的软件，发送响应的时间，回应数据的格式等信息；响应正文：就是响应的具体数据。备注：我们主要关心并且能够在客户端浏览器看得到的是三位数的状态码，不同的状态码代表不同的含义，其中 常见的请求 / 响应包头:123456789Accept : 定义客户端可以处理的媒体类型，按优先级排序 - &gt; (告诉服务器,我能接受那些格式的文件)Accept-Encoding : 定义客户端可以理解的编码机制。例如：Accept-Encoding:gzip,compress (能处理的编码方式)Accept-Language 定义客户端乐于接受的自然语言列表。Cache-Control 一个用于定义缓存指令的通用头标。例如：Cache-Control: max-age&#x3D;30Connection 一个用于表明是否保存socket连接为开放的通用头标 keep-aliveContern-Type 标明发送或者接收的实体的MIME类型。例如：Content-Type: text&#x2F;html(告诉服务器,我发送的数据内容类型)Host 被请求资源的主机名。If-Modified-Since 如果包含了GET请求，导致该请求条件性地依赖于资源上次修改日期。(用于校验文件是否最新,做缓存优化)Server 一种标明Web服务器软件及其版本号的头标。 HTTP常见请求状态码1234200 ok &#x3D; &gt; 请求数据成功304 &#x3D;&gt; 请求内容与之前请求过的内容一样(暂未修改)404 &#x3D;&gt; 服务器找不到请求的网页500 &#x3D;&gt; 服务器内部错误 HTTP请求状态码12345678910111213141516171819202122232425262728293031323334353637383940414243442**开头 （请求成功）表示成功处理了请求的状态代码。200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。201 （已创建） 请求成功并且服务器创建了新的资源。202 （已接受） 服务器已接受请求，但尚未处理。203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204 （无内容） 服务器成功处理了请求，但没有返回任何内容。205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。3** 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。4**开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。400 （错误请求） 服务器不理解请求的语法。401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403 （禁止） 服务器拒绝请求。404 （未找到） 服务器找不到请求的网页。405 （方法禁用） 禁用请求中指定的方法。406 （不接受） 无法使用请求的内容特性响应请求的网页。407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 （请求超时） 服务器等候请求时发生超时。409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415 （不支持的媒体类型） 请求的格式不受请求页面的支持。416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417 （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。5**开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。500 （服务器内部错误） 服务器遇到错误，无法完成请求。501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 模拟一个http通信过程:1234567891011121314151617小B(浏览器) &#x2F; 小S(服务器)小B: 小S ,你在吗?小S:在的小B:最近手头有点紧,能不能借个100块钱救急?小S:微信转账100 ....过了一会(10天 ,也可能是5s后)小B:小S ,你在吗?小S:在的小B:能不能借100块给我?小S:支付宝转账100... 3.跨域 / 浏览器同源策略跨域:请求域与当前域中 , 只要有: 【端口 , 协议 , 域名】 任何一项不同 ,则视为跨域.12345678当前站点(域):http:&#x2F;&#x2F;localhost:63342&#x2F;目标请求站点(域):https:&#x2F;&#x2F;tcc.taobao.com (域名, 协议 ,端口都不同)目标域:http:&#x2F;&#x2F;localhost:8080 端口与当前域不同 ,属于跨域目标域:http:&#x2F;&#x2F;lobaidu.com:63342 域名与当前域不同 ,属于跨域目标域:https:&#x2F;&#x2F;localhost:63342&#x2F; 协议与当前域不同 ,属于跨域 跨域的来源 = &gt; 浏览器的同源策略12345678同源策略的目的是为了维护用户数据信息安全而定制的浏览器规则.同源策略限定范围: http 请求 , cookie , 本地的存储类功能(localStorage , sessionStorage ,indexDB)因为存在浏览器同源策略，所以才会有跨域问题。那么浏览器是出于何种原因会有跨域的限制呢。其实不难想到，跨域限制主要的目的就是为了用户的上网安全。域之间域名\\协议\\端口都相同则视为同源.浏览器对: script &#x2F; link &#x2F; img 三个标签引入资源没有限定 1Access to XMLHttpRequest at &#39;https:&#x2F;&#x2F;tcc.taobao.com&#x2F;cc&#x2F;json&#x2F;mobile_tel_segment.htm?tel&#x3D;13800138000&#39; (redirected from &#39;http:&#x2F;&#x2F;tcc.taobao.com&#x2F;cc&#x2F;json&#x2F;mobile_tel_segment.htm?tel&#x3D;13800138000&#39;) from origin &#39;null&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. 解决跨域的方案:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556571.jsonp 解决方案: 在ajax的请求中 ,设置 dataType属性 为 jsonp, 即可. 原理:因为浏览器中对于scrpt &#x2F; img &#x2F; link 标签的http请求 ,不作同源策略限制 ,所以就可以利用同在网页中加载js脚本的方式 ,引入一段跨域的脚本(返回的是一个方法 ,方法中是调用的方式 ,并且带有数据内容的实参)需要在请求的时候 , 带上一个 callback 参数 ,来告知后台, 需要返回一个指定名字的函数 (需要后台支持) 特性: jsonp的请求方式只能为get请求 , 不适用于需要使用post请求的场景. 动态创建 &lt;script&gt;&lt;&#x2F;script&gt; 引入需要请求的数据地址 ,以脚本方式调用,获取返回的数据------------------------------------------------------------------------------------2.cors (跨域共享) 原理: 就是通过服务器的响应包头 ,设定允许本次请求 ,浏览器收到请求后,就会放行. 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。比如，站点 http:&#x2F;&#x2F;domain-a.com 的某 HTML 页面通过 &lt;img&gt; 的 src 请求 http:&#x2F;&#x2F;domain-b.com&#x2F;image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。 实现 : 以php为例: php文件中添加: header(&quot;Access-Control-Allow-Origin:*&quot;);https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Access_control_CORS(问题点)OPTIONS 方法的“预检请求” 用于检测服务端是否支持对应的包头字段 ,及请求类型 ,如果确认可以,才会正式发起对应的get &#x2F; post请求 header(&quot;Access-Control-Allow-Origin:*&quot;); header(&quot;Access-Control-Allow-Methods:POST,GET,OPTIONS&quot;); header(&quot;Access-Control-Allow-Headers:*&quot;);------------------------------------------------------------------------------------3.proxy(代理跨域) &#x3D; &gt; 就是避免跨域 (大型的项目的生产环境,开发环境都是使用的非常多)常见http代理 : apache &#x2F; nginx &#x2F; nodejs (webpack-dev-server)反向代理:指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。代理跨域理解: 比如现在当前域为: http:&#x2F;&#x2F;m.com , 需要请求的目标域为 http:&#x2F;&#x2F;s.com&#x2F;api ,如果说使用代理解决跨域 ,就会把请求的目标地址 ,转换成本地的地址 ,由对应的服务器代理去请求真实的目标地址把请求地址改为 : http:&#x2F;&#x2F;m.com&#x2F;api 就不跨域了 , 数据的话还是在原来的http:&#x2F;&#x2F;s.com&#x2F;api 中 ,我们跨域通过服务器软件 ,配置代理 ,来实现,通过服务器的请求完成即可.使用xampp配置反向代理为例:1.找到之前配置虚拟主机的文件 ,打开, 在对应的虚拟直接配置中 ,添加一条代理即可.&lt;VirtualHost *:80&gt; DocumentRoot &quot;&#x2F;xampp&#x2F;htdocs&#x2F;s.com&quot; ServerName s.com ProxyPass &#x2F;api http:&#x2F;&#x2F;m.com&#x2F;api&lt;&#x2F;VirtualHost&gt;2.需要配置httpd.conf 的开启代理模块 (#去掉) 第139行： LoadModule proxy_module modules&#x2F;mod_proxy.so第142行： LoadModule proxy_connect_modulemodules&#x2F;mod_proxy_connect.so第145行： LoadModule proxy_ftp_modulemodules&#x2F;mod_proxy_ftp.so第147行： LoadModule proxy_http_modulemodules&#x2F;mod_proxy_http.so————————————————原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;u011637739&#x2F;article&#x2F;details&#x2F;80718127最后 重启 apache 服务即可 ,开启反向代理------------------------------------------------------------------------------------4.(H5)websocket &#x2F; postMessage------------------------------------------------------------------------------------5.iframe https协议 ​ 什么是HTTPS： HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议。 ​ 它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的 安全版。 它是由Netscape开发并内置于其浏览器中，用于对数据进行压缩和解压操作，并返回网络上传送回的结果。HTTPS实际上应用了Netscape的安 全全套接字层（SSL）作为HTTP应用层的子层。（HTTPS使用端口443，而不是象HTTP那样使用端口80来和TCP/IP进行通信。）SSL使 用40 位关键字作为RC4流加密算法，这对于商业信息的加密是合适的。HTTPS和SSL支持使用X.509数字认证，如果需要的话用户可以确认发送者是谁。 https协议通俗比喻故事(天地会暗语) ​ HTTPS的全称是Secure Hypertext Transfer Protocol（安全超文本传输协议），是在http协议基础上增加了使用SSL加密传送信息的协议。我们还是用天地会接头的例子来讲，大家可能觉得每 次天地会接头都是使用“地震高岗，一派西山千古秀！”这类妇孺皆知的接头暗号，这样的组织还有什么安全性可言？只要说出了暗号那么就可能获得天地会的相关 秘密。事实上并不是这样的，如果仅仅是靠一个妇孺皆知的接头暗号进行信息保密，天地会可能早被清兵围剿了，何来那么多传奇故事呢？他们之间的交流除了使用 了接头暗号外，可能还是用了“黑话”，就是一些仅仅只有天地会成员才能听懂的黑话，这样即使天地会成员之间的交谈信息被泄露出去了，没有相关揭秘的东西， 谁也不会知道这些黑话是什么？同样HTTPS协议就如同上面天地会的信息交谈一样，它也将自己需要传输的超文本协议通过SSL加密，让明文变成了“黑话” 即使传输的信息被人捕获，捕获的人也没办法知道其实际内容。 HTTPS和HTTP的区别： https协议需要到ca申请证书，一般免费证书很少，需要交费。 ​ http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的。 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 HTTPS解决的问题： 1 . 信任主机的问题. 采用https 的server 必须从CA 申请一个用于证明服务器用途类型的证书. 改证书只有用于对应的server 的时候，客户度才信任次主机。所以目前所有的银行系统网站，关键部分应用都是https 的，客户通过信任该证书，从而信任了该主机，其实这样做效率很低，但是银行更侧重安全。这一点对我们没有任何意义，我们的server 采用的证书不管自己issue 还是从公众的地方issue，客户端都是自己人，所以我们也就肯定信任该server。 2 . 通讯过程中的数据的泄密和被窜改 ​ 1）一般意义上的https, 就是 server 有一个证书. ​ a) 主要目的是保证server 就是他声称的server. 这个跟第一点一样. b) 服务端和客户端之间的所有通讯，都是加密的. ​ i. 具体讲，是客户端产生一个对称的密钥，通过server 的证书来交换密钥，一般意义上的握手过程。 ii. 加下来所有的信息往来就都是加密的，第三方即使截获，也没有任何意义，因为他没有密钥，当然窜改也就没有什么意义了。 2）少许对客户端有要求的情况下，会要求客户端也必须有一个证书。 ​ a) 这里客户端证书，其实就类似表示个人信息的时候，除了用户名/密码， 还有一个CA 认证过的身份，个人证书一般来说上别人无法模拟的，所有这样能够更深的确认自己的身份。 ​ b) 目前少数个人银行的专业版是这种做法，具体证书可能是拿U盘作为一个备份的载体。","categories":[],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://1314xulujin.github.io/tags/ajax/"}]},{"title":"OOP思想(面向对象思想)","slug":"OOP思想-面向对象思想","date":"2019-10-18T05:38:53.000Z","updated":"2020-06-21T13:10:21.253Z","comments":true,"path":"2019/10/18/OOP思想-面向对象思想/","link":"","permalink":"https://1314xulujin.github.io/2019/10/18/OOP%E6%80%9D%E6%83%B3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/","excerpt":"","text":"OOP思想应该怎样来理解？ https://blog.csdn.net/qq157962718/article/details/50990154 https://www.cnblogs.com/xiaosongluffy/p/5072501.html https://blog.csdn.net/sinat_37212928/article/details/72874598 它强调对象的“抽象”、“封装”、“继承”、“多态”。 OOP思想浅谈 收藏07年11月27号在校内举办了第一次技术讲座，主题是Java now and future.和以往的同主题的讲座不同，我在讲座里面着重讲了一下我对OOP思想的理解并对比了Java和C++的区别，这也是很多编程爱好者所津津乐道的话题，至于大家喜欢哪种编程语言我个人觉得主要决定于自己的性格，当初喜欢Java也是因为其跨平台的特点，和外向兴趣广泛的我一样，能让生活充满更多的乐趣和颜色。 ​ 下面浅谈下我对OOP思想的理解，OOP思想中很重要的有五点，类，对象，还有面向对象的三大特征：继承，多态和封装。 ​ 类：对现实世界事物的抽象表示，包括事物的状态信息（成员变量）和行为信息（成员方法）。我们要让我们的计算机程序设计更有意思，也更有逻辑性，则我们的程序中对事物的描叙就必须符合真实情况，同时符合人类的思维习惯。因此，我们如果在计算中要描叙人这个事物，也是一类事物，我们就必须把该事物的所有特点包含进来，用成员变量描叙人的基本属性，如：身高，体重，年龄，性别等。这样就可以描叙一个“静态”的人了，所谓静态的意思也就是该人并不参与任何社会活动，没有任何行为。但是这样并不符合现实意义，那样我们必须为人添上行为，让他参加社会活动有自己的行为。所以我们需要用成员方法来描叙人的活动，如：吃饭，洗澡，睡觉等。 ​ 对象：对抽象事物的具体表示，使其具有自身的特点。类好比一个大的集合，里面的元素都有共同的特点，但是比较每个元素又可以发现每个有其自身的特点，对象就是这样，它是一个类的具体化，也是实例化，类是泛指，而对象是特指。虽然人都有身高，体重，年龄，同时有行为有吃饭，洗澡，睡觉等，但是当具体到某个人的时候就会有不同，例如：老人和小孩的年龄就有不同，所以，从类到对象是我们把现实事物进行计算机描叙的过程，同时也是一个从抽象到具体的过程，这很符合我们的真实思维逻辑。 ​ 下面浅谈一下面向对象的三大特征的基本思想。 ​ 多态：用一种解决方案来解决对一类问题，对于不同的事物解决途径和结果不同。在C++中实现多态性有三种方法，分别是：虚函数，函数重载和运算符重载。这三种方法大家都可以看到我们解决问题的初衷是一样的，都是利用同名函数，同名的运算符号，这抽象出来也就是解决问题的方法，但是对于不同的事物的反应却是不同的，例如：当用一个getPadNumber()方法来得到普通自行车和双人自行车的坐垫数量的时候，返回的结果是一个和两个，这就是具体的事物返回的结果不同。 ​ 继承：让抽象出来的事物具有本应该具有的联系。我们能用类来描叙一个抽象的事物，同时能用对象来描叙具体的事物，但是这些事物都是独立的，彼此之间没有应该有的联系，这样的孤立设计并不符合现实逻辑，让事物之间的联系得到描叙，我们就需要继承，例如：发明自行车的人并不是一开始就发明了多人自行车，这些都是从双轮自行车演变和发展而来，但是他们都有共同的特点，有轮子，有车架子，等等。让我们用继承的关系把这两个现实的抽象联系起来，这样我们就能设计出不孤立的类，而是和其他类有联系的类。 ​ 封装：让抽象的事物保护自身的状态，防止非其他事物对其进行错误的状态改变操作。我们抽象完一个事物后，可能在特定的条件下，其本身的状态需要改变，但是这个改变并允许其他的事物来进行，这样的改变只允许这个事物认同的操作域来进行，可以是该事物本身，也可以是它信任的其他事物。这样我们就能对我们抽象完的每个事物进行自身数据的保护。 以下有几个案例创建对象-字面量创建1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //1. 使用字面量方式创建对象 var obj = &#123; name:&quot;张三&quot;, run:function () &#123; console.log(&#x27;我能跑&#x27;); &#125; &#125; obj.run();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建对象-使用new Object1234567891011121314151617181920212223242526&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //回顾数组 , 日期 , 正则 , 数字 , 字符串对象, 布尔对象 ... // var arr = new Array(); // var date = new Date(); // var reg = new RegExp(); //不足: 创建使用单一 ,过程繁琐 ,不能很好支持创建多个对象 var obj = new Object(); //创建一个对象 , 空对象 obj.name = &quot;张三&quot;; obj[&#x27;run&#x27;] = function()&#123; console.log(&#x27;我能跑!&#x27;); &#125; console.log(obj);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建对象-工厂模式12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //3.工厂模式 = &gt; 批量大量操作 : 其实就是把创建对象的过程封装成一个方法 //工厂模式属于23中设计模式的一种 详情见:http://c.biancheng.net/design_pattern/ //可以解决批量声明对象的繁琐过程和重复代码问题 //但是 使用工厂模式批量创建的对象都是Object , 无法 像js中内置的Array , Date , RegExp ... 一样 ,容易辨别什么对象 //检测数据类型 : typeof = &gt; number , string , null , undefined , boolean object //检测对象的类型 instanceof 检测对象是由哪个类(模具)创建出来的 var arr = new Array(); console.log(arr instanceof Array); // = &gt; true , 可以理解为arr是不是由Array 这个模子刻出来的 function createObj(index,len)&#123; var obj = new Object(); obj.index = index; obj.len = len; obj.autoplay = function () &#123; console.log(&#x27;这是一个自动播放的函数!&#x27;); &#125; return obj; &#125; //批量创建对象 var slide1 = createObj(1,5); var slide2 = createObj(3,12); var slide3 = createObj(4,9);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 面向对象编程思想12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; /* 面向过程 : 就是把需要解决问题的事务分解成一个个的步骤 , 然后按所需要的步骤一个个执行(调用方法) 面向过程一样可以解决实际的问题, 但是这种思想,方式不利于项目的维护, 变更 ,扩展 不能很好实现代码的灵活复用或者业务解耦 ,容易造成代码冗余 面向对象 : 把构成问题的事务,分解成各个对象 ,每个对象只负责各自部分(实现代码业务解耦) 使用生活例子理解: 面向过程 : 像刀耕火种的时代, 从耕地 , 农活 , 收割 , 打谷 ,做饭 , 衣服 ,纺织 ... (一个人全部流程实现) 面向对象 : 现代社会 , 把日常生活工作 分配到不同岗位或行业领域,每个领域有各自的职责任务 (把任务分解,各自独立, 互不影响) */&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 面向对象-混合模式(原型+构造模式)1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; /** * 无论是单纯的构造函数(浪费一些内存) , 还是单纯的原型(参数无法自定义),都只能解决某一些问题,还不是最终完美的方案 * 理想方案: 该独立的独立 ,该共享的就共享 ,实现功能和内存的优化 * 混合模式 = 构造函数 + 原型 * * 一般做法: 属性通过构造函数添加 (不同) , 方法就通过原型添加 (一样) */ function Cat (name,type)&#123; this.name = name; this.type = type; &#125; Cat.prototype.catchMouse = function () &#123; console.log(&quot;我能抓老鼠!&quot;); &#125; var cat1 = new Cat(&quot;小花&quot;,&quot;波斯猫&quot;); var cat2 = new Cat(&quot;小黑&quot;,&quot;加菲猫&quot;); console.log( cat1.catchMouse === cat2.catchMouse); // true 说明内存地址一样 //其实在js内置的构造函数中 ,也是把一些方法添加到对应的原型上的&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原型的常规妙用1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //其实在js内置的构造函数中 ,也是把一些方法添加到对应的原型上的 (一般不会去修改原来的方法, 如果需要改善 会直接新增方法) Array.prototype.push2 = function () &#123; console.log(this) ;// this = &gt; arr console.log(arguments); for (var i =0;i&lt;arguments.length;i++)&#123; this.push(arguments[i]*arguments[i]); &#125; &#125; var arr = []; // = &gt; 等价于 new Array() 就是一个构造函数的实例化过程 // arr.push(1,2,3); arr.push2(1,2,3); // = &gt; 预期: [1 ,4, 9] console.log(arr); var arr2 = []; arr2.push2() // 可以把一些常用的方法 ,添加到对应构造函数的原型上,从而实现方便的调用 // Math 数学对象, 不是一个函数 ,更不是一个构造函数,所有没有原型,无法通过原型修改&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"OOP面向对象思想","slug":"OOP面向对象思想","permalink":"https://1314xulujin.github.io/tags/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/"}]},{"title":"js中的跨域及其解决的办法","slug":"js中的跨域问题解决","date":"2018-12-05T09:40:25.000Z","updated":"2020-06-21T13:10:21.274Z","comments":true,"path":"2018/12/05/js中的跨域问题解决/","link":"","permalink":"https://1314xulujin.github.io/2018/12/05/js%E4%B8%AD%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"js中的跨域及其解决的办法一、什么是跨域？在了解跨域之前，首先要知道什么是同源策略（same-origin policy）。简单来讲同源策略就是浏览器为了保证用户信息的安全，防止恶意的网站窃取数据，禁止不同域之间的JS进行交互。对于浏览器而言只要域名、协议、端口其中一个不同就会引发同源策略，从而限制他们之间如下的交互行为： 1.Cookie、LocalStorage和IndexDB无法读取； 2.DOM无法获得； 3.AJAX请求不能发送。 跨域的严格一点的定义是：只要协议，域名，端口有任何一个的不同，就被当作是跨域。 如下表所示： URL 说明 是否允许通信 http://www.a.com/a.jshttp://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.jshttp://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.jshttp://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.jshttps://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.jshttp://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.jshttp://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.jshttp://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.jshttp://www.a.com/b.js 不同域名 不允许 特别注意两点： 第一，如果是协议和端口造成的跨域问题“前台”是无能为力的， 第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 “URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。 二、为什么浏览器要限制跨域访问呢？原因就是安全问题：如果一个网页可以随意地访问另外一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。比如下面的操作就有安全问题： 1.用户访问www.mybank.com，登陆并进行网银操作，这时cookie啥的都生成并存放在浏览器； 2.用户突然想起件事，并迷迷糊糊的访问了一个邪恶的网站www.xiee.com； 3.这时该网站就可以在它的页面中，拿到银行的cookie，比如用户名，登陆token等，然后发起对www.mybank.com的操作； 4.如果这时浏览器不予限制，并且银行也没有做响应的安全处理的话，那么用户的信息有可能就这么泄露了。 三、为什么要跨域？既然有安全问题，那为什么又要跨域呢？ 有时公司内部有多个不同的子域，比如一个是location.company.com ,而应用是放在app.company.com , 这时想从 app.company.com去访问 location.company.com 的资源就属于跨域。 四、解决跨域问题的方法：1.跨域资源共享（CORS）CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 只需要在后台中加上响应头来允许域请求！在被请求的Response header中加入以下设置，就可以实现跨域访问了！ 如下所示： 1234567//指定允许其他域名访问&#x27;Access-Control-Allow-Origin:*&#x27;//或指定域//响应类型&#x27;Access-Control-Allow-Methods:GET,POST&#x27;//响应头设置&#x27;Access-Control-Allow-Headers:x-requested-with,content-type&#x27; 2.通过jsonp跨域JSONP是JSON with Padding（填充式json）的简写，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON，例如： 1callback(&#123;&quot;name&quot;,&quot;trigkit4&quot;&#125;); JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。 JSONP的原理：通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。（即用JavaScript动态加载一个script文件，同时定义一个callback函数给script执行而已。） 在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是http://example.com/data.php，那么a.html中的代码就可以这样： function dosomething(jsondata){ //处理获得的json数据 } js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。 12345&lt;?phpcallback = _GET[&#x27;callback&#x27;];//得到回调函数名data = array(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);//要返回的数据echo callback.&#x27;(&#x27;.json_encode($data).&#x27;)&#x27;;//输出?&gt; 最终，输出结果为：dosomething([‘a’,’b’,’c’]); 如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。 $.getJSON('http://example.com/data.php?callback=?,function(jsondata)'){ //处理获得的json数据 }); JSONP的优缺点：JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。 JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 CORS和JSONP对比：CORS与JSONP相比，无疑更为先进、方便和可靠。 （1）JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求； （2）使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得说句，比起JSONP有更好的错误处理； （3）JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS； 3.通过修改document.domain来跨子域上面的jsonp是来解决ajax跨域请求的，那么如果是需要处理 Cookie 和 iframe 该怎么办呢？这时候就可以通过修改document.domain来跨子域。两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie或者处理iframe。比如A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 12345document.domain = &#x27;example.com&#x27;;//现在，A网页通过脚本设置一个 Cookie。document.cookie = &quot;test1=hello&quot;;//B网页就可以读到这个 Cookie。var allCookie = document.cookie; 注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。 123Set-Cookie: key=value; domain=.example.com; path=///这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 不同的iframe 之间（父子或同辈），是能够获取到彼此的window对象的，但是你却不能使用获取到的window对象的属性和方法(html5中的postMessage方法是一个例外，还有些浏览器比如ie6也可以使用top、parent等少数几个属性)，总之，你可以当做是只能获取到一个几乎无用的window对象。首先说明一下同域之间的iframe是可以操作的。比如http://127.0.0.1/JSONP/a.html里面嵌入一个iframe指向http://127.0.0.1/myPHP/b.html。那么在a.html里面是可以操作iframe里面的DOM的。 var iframe = document.querySelector(\"iframe\"); iframe.onload = function(){ var win = iframe.contentWindow; var doc = win.document; var ele = doc.querySelector(\".text1\"); var text = ele.innerHTML=\"123456\"; } 如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。如果两个窗口一级域名相同，只是二级域名不同，那么document.domain属性，就可以规避同源政策，拿到DOM。 4.使用window.name来进行跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。比如：有一个页面a.html,它里面有这样的代码： 1234window.name = &quot;我是a页面设置的&quot;;setTimeout(function()&#123; window.location = &quot;http://127.0.0.1/JSONP/b.html&quot;;&#125;,1000) b.html页面的代码：1console.log(window.name); ​ a.html页面载入后1秒，跳转到了b.html页面，结果b页面打印出了：1我是a页面设置的 可以看到在b.html页面上成功获取到了它的上一个页面a.html给window.name设置的值。如果在之后所有载入的页面都没对window.name进行修改的话，那么所有这些页面获取到的window.name的值都是a.html页面设置的那个值。当然，如果有需要，其中的任何一个页面都可以对window.name的值进行修改。注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。利用window.name可以对同域或者不同域的之间的js进行交互。那么在a.html页面中，我们怎么把b.html页面载入进来呢？显然我们不能直接在a.html页面中通过改变window.location来载入b.html页面，因为我们想要即使a.html页面不跳转也能得到b.html里的数据。答案就是在a.html页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取b.html的数据，然后a.html再去得到iframe获取到的数据。 5.使用HTML5的window.postMessage方法跨域上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。举例来说，父窗口http://a.com向子窗口http://b.com发消息，调用postMessage方法就可以了。a页面： document.getElementById('frame1').onload = function(){ var win = document.getElementById('frame1').contentWindow; win.postMessage(\"我是来自a页面的\",\"http://127.0.0.1/JSONP/b.html\") } b页面通过监听message事件可以接受到来自a页面的消息。 1234window.onmessage = function(e)&#123; e = e || event; console.log(e.data);//我是来自a页面的&#125; 子窗口向父窗口发送消息的写法类似。 window.opener.postMessage(‘我是来自b页面的’, ‘http://a.com&#39;);//父窗口和子窗口都可以通过message事件，监听对方的消息。通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。下面是一个例子，主窗口写入iframe子窗口的localStorage。父窗口发送消息代码： var win = document.getElementsByTagName(‘iframe’)[0].contentWindow;var obj = { name: ‘Jack’ };// 存入对象win.postMessage(JSON.stringify({key: ‘storage’, method: ‘set’, data: obj}), ‘http://b.com&#39;);// 读取对象win.postMessage(JSON.stringify({key: ‘storage’, method: “get”}), “*”);window.onmessage = function(e) { if (e.origin != ‘http://a.com&#39;) return; // “Jack” console.log(JSON.parse(e.data).name);};子窗口接收消息的代码： window.onmessage = function(e) { if (e.origin !== ‘http://bbb.com&#39;) return; var payload = JSON.parse(e.data); switch (payload.method) { case ‘set’: localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case ‘get’: var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, ‘http://aaa.com&#39;); break; case ‘remove’: localStorage.removeItem(payload.key); break; }}; 6.通过WebSocket进行跨域web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用) web sockets原理：在js创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 只有在支持web socket协议的服务器上才能正常工作。 12345var socket = new WebSockt(&#x27;ws://www.baidu.com&#x27;);//http-&gt;ws; https-&gt;wsssocket.send(&#x27;hello WebSockt&#x27;);socket.onmessage = function(event)&#123; var data = event.data;&#125; 7.图像ping（单向）什么是图像ping：图像ping是与服务器进行简单、单向的跨域通信的一种方式，请求的数据是通过查询字符串的形式发送的，而相应可以是任意内容，但通常是像素图或204相应（No Content）。 图像ping有两个主要缺点：首先就是只能发送get请求，其次就是无法访问服务器的响应文本。 使用方法：123456var img = new Image();img.onload = img.onerror = function()&#123;alert(&quot;done!&quot;);&#125;;img.src = &quot;https://raw.githubusercontent.com/zhangmengxue/Todo-List/master/me.jpg&quot;;document.body.insertBefore(img,document.body.firstChild); 然后页面上就可以显示我放在我的github上某个地方的照片啦。 与类似的可以跨域内嵌资源的还有: (1)标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。上面jsonp也用到了呢。 (2) 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type消息头。不同浏览器有不同的限制： IE, Firefox, Chrome, Safari (跳至CVE-2010-0051)部分 和 Opera。 (3) 和 嵌入多媒体资源。 (4), 和 的插件。 (5)@font-face引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。 (6) 和 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。 8.使用片段识别符来进行跨域片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#flag的#flag。如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符。在父窗口写入： 1234document.getElementById(&#x27;frame&#x27;).onload = function()&#123; var src = &quot;http://127.0.0.1/JSONP/b.html&quot; + &#x27;#&#x27; + &quot;data&quot;; this.src = src;&#125; 子窗口通过监听hashchange事件得到通知。1234567window.onload = function()&#123; console.log(&quot;b.html加载完成&quot;) window.onhashchange = function()&#123; var message = window.location.hash; console.log(message)//#data &#125;; &#125; 同样的，子窗口也可以改变父窗口的片段标识符。1parent.location.href= target + &quot;#&quot; + hash;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://1314xulujin.github.io/tags/javascript/"}]},{"title":"javascript+jQuery","slug":"javascript-jQuery","date":"2018-10-22T02:11:02.000Z","updated":"2020-06-21T13:10:21.267Z","comments":true,"path":"2018/10/22/javascript-jQuery/","link":"","permalink":"https://1314xulujin.github.io/2018/10/22/javascript-jQuery/","excerpt":"","text":"第一章：初识javascript1,javascript的三种使用方式：①在元素中，通过交互的事件使用脚本。 ②内部脚本。 ③外部脚本。 代码如下： 123456789101112131415161718192021222324&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--1.在元素中,通过交互的事件使用脚本--&gt; &lt;button onclick=&quot;alert(123)&quot;&gt;按钮&lt;/button&gt; &lt;!--2.内部脚本--&gt; &lt;script type=&quot;text/javascript&quot;&gt; //执行的脚本代码 &lt;/script&gt; &lt;!-- 3.外部脚本--&gt; &lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; alert(121231);&lt;/script&gt; 2,javascript的执行原理：①浏览器客户端向服务器端发送请求：一个用户在浏览器的地址栏中输入要访问的页面（页面中包含javascript程序）。 ②数据处理：服务器端处理某个包含javascript的页面。 ③发送响应：服务器端将含有javascript的HTML文件处理页面发送到浏览器客户端，然后由浏览器客户端从上到下逐条解析HTML标签和javascript，并将页面效果呈现给用户。 使用客户端脚本的好处有以下两点。 ①包含javascript的页面只要下载一次即可，这样能减少不必要的网络通信。 ②javascript程序由浏览器客户端执行，而不是由服务器端执行，因此能减轻服务器端的压力。 3，变量的赋值和声明：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;title&gt;无标题文档&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;script&gt; &#x2F;&#x2F;变量: &quot;变量是个筐 ,啥都往里装&quot; (用于程序中存储数据的 - 存储在计算机的内存中) &#x2F;&#x2F;变量在使用的时候 ,需要声明 , 赋值 过程. &#x3D; &gt; 开房的流程 &#x2F;&#x2F;1.(预约 &#x3D; &gt; 入住) 先声明 ,后赋值 (使用var 关键字来声明变量) var width,a,b,c,d;&#x2F;&#x2F;声明变量 ,width 变量名称(房间号 - &gt; 对应到计算机内存中某一个地址) width &#x3D; 10; &#x2F;&#x2F;2.直接声明并赋值 (直接酒店办理并入住) var height&#x3D;20,f&#x3D;20,g &#x3D; 20; &#x2F;&#x2F;3.(不建议使用)直接赋值 (没有办理入住手续,直接入住) square &#x3D; 30; &#x2F;&#x2F;alert(width); &#x2F;** 变量命名规范: 1.不能使用特殊字符 ,只允许使用 字母 , 数字 ,下划线 $ 2.不能以数字开头 ,可以使用字母 ,下划线 $ 开头 3.不能使用关键字 , 保留字作为变量名 4.建议使用驼峰命名法 ,命名(多个单词组合,从第二个单词开始每个单词首字母大写) 5.起名要做到见名识义 (如果不规范好,只要代码稍微多一点,就会搞混淆) *&#x2F; var a123 &#x3D; 10; var studentName&#x3D;&#39;张三&#39;; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 4,变量命名的规范：①不能使用特殊字符，只允许使用字母，数字，下划线，$。 ②不能以数字开头，可以使用字母、下划线、$开头。 ③不能使用关键字，保留只作为变量名。 ECMA-262描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是ECMAScript的全部关键字（带*号的上标的是第5版新增的关键字） 关键字： break do instanceof typeof case else new var catch finally return void contine for switch while debugger* function this with default if throw delete in try ECMA-262还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定用途，但是它们可能在将来被用作关键字。以下是ECMA-262第3版定义的全部保留字； 保留字： abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public 第5版把在非严格模式下运行时的保留字缩减为下列这些： class enum extends super const export import 在严格模式下，第5版还对以下保留字施加了限制： implements package public interface private static let protected yield ④建议使用驼峰命名法，命名（多个单词组合，从第二个单词开始每个单词首字母大写）。 例：var studentName=”张三”; ⑤起名要做到见名识义（如果不规范好的话，只要代码稍微多一点，就会搞混淆）。 5,数据类型：一，五个基本数据类型 ①underfined（未定义类型）未定义，变量声明未初始值时，会被默认赋予underfined值。 ②null（空类型）与上面一个类型相似也可以说是相等。 ③number（数值（数字）类型）整数，小数–可用于数学计算。 ④boolean（布尔类型）：只有两种结果true（真）/false（假）–条件判断 ⑤string（字符串类型）：一组被引号（单/双引号）括起来的文本。 二，常用的三个引用类型 ①object （对象类型）对象拥有方法，属性有length，可用for in 循环遍历对象，（for（index in Data）中index为键名，Data[index]为键值） ②array （数组类型 用typeof检测出也是对象类型）数组只有一个属性是长度length，方法有常用的20种见初始javascript第15条。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //数据类型: 变量存储时内容数据的类型 var width; /** 数据类型: 1.undefined 未定义 ,变量声明未初始值时,会被默认赋予undefined 值 2.null 空值 ,与undefined 相等 3.number 数字类型:整数,小数 - &gt; 可以用于数学计算 4.boolean 布尔值类型 : 只有两种结果 true(真) / false(假) - &gt; 条件判断 5.string 字符串类型 :一组被引号(单/双引号)括起来的文本 **/ var height = 10;//因为height 存储的值为数字 10 ,所以height 就是数字类型 var section = &#x27;10&#x27;; //字符串类型的数据 var a =&quot;20&quot;;//字符串类型 var b = a; var c = &quot;apple&quot;; //typeof() / 或者typeof 关键字 用于检测数据类型 alert(typeof a); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6,运算符：1，算术运算符：+ - * / %(求余) ++（自身+1） –（自身-1）。 2，赋值运算符：= 、+=、-=、*=、%=。 3，比较运算符（返回布尔值类型：true/false）：&gt; &lt; ==（等于） ===（全等于） &gt;= &lt;= !=(不等于) !===（不全等于）。 4，逻辑运算符：并且（&amp;&amp;） 或者（||） 非（!） 口诀：与或非。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /** 运算符: 1.算术运算符: + - * / %(求余) ++(自身+1) --(自身-1) 2.赋值运算符: = 、+= 、-= 、*= 、 %= 3.比较运算符(返回布尔值类型:true / false): &gt; &lt; == ===(全等于) &gt;= &lt;= !=(不等于) !==(不全等于) 4.逻辑运算符 : 并且(&amp;&amp;) 或者(||) 非(!) **/ var a = 10; var b = 20; var c = a / b; //alert(c); // 5 / 2 = 2······1 （1就是余数） var d = a % 3; // 10 / 3 = 3 ·······1 //a++; var e = a++;//a 会先把值赋值给e ,然后a 悄悄自己+1 ,e =10 ,a = 11 var f = ++a;//a 会先自身+1 ,然后再赋值给f a = 12 ,f = 12 a+=10;// 等价于 a = a + 10; = &gt; 累加 a = 22 b-=3; //等价于 b = b - 2; =&gt; 累减 b = 17 var g = &#x27;22&#x27;; //如果比较的是一个字符串类型的数字 ,那么就会转换成数字来进行比较大小 //alert(a == g);//true //alert(a === g);//===全等于: 需要值相等,数据类型也相等才会成立 //alert(true &amp;&amp; false); //alert(true || false);//多选一 ,只要有一个成立即成立 //需求: 如何表示 一个值的取值范围在 50 - 100 之间 var h = 49; //alert(50&lt;=h &amp;&amp; h&lt;=100); //alert(!!!true); //alert(0==false); //alert(1==true); alert(!0); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7,字符串拼接：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // + 除了在数字类型数据中起到相加功能以外 ,在一些字符串类型数据中可以起拼接作用 //var a = &#x27;10&#x27;; //var b = 20; //var c = a + b; //此处如果使用 * / - 这些,在计算时 ,会自动将数字的字符串转换成数字类型后进行计算 - (弱类型转换) //字符串与字符串拼接 或者 与 变量拼接 要使用 + 连接 //alert(c);//1020 var a=&quot;小明&quot;; var b = 20; var c = &quot;千里之行，始于足下。&quot;; //把上的文字拼成一段文字 ：【 小明说：我今年20岁，我喜欢的一句话是:&quot;千里之行，始于足下。&quot;】 //在控制台alert()弹出以上文字，注意标点符号必须要一样。 //alert(a + &quot;说:我今年&quot; + b + &#x27;岁,我喜欢的一句话是:&quot;&#x27; + c + &#x27;&quot;&#x27;); //alert(a + &quot;说:我今年&quot; + b + &quot;岁,我喜欢的一句话是:\\&quot;&quot; + c + &quot;\\&quot;&quot;); // \\&quot; 转义双引号 ,因为&quot; 在js中的作用是用于括起一组字符串的 ,如果\\&quot; 转义后就不具有括起字符就是字符串的功能,就会变成一个普通的双引号字符 //需求 : 直接在浏览器窗口弹出 【&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;】 //alert(&quot;&lt;a href=\\&quot;http://www.baidu.com\\&quot;&gt;百度&lt;/a&gt;&quot;); // alert(&#x27;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#x27;); var url = &quot;http://www.baidu.com&quot;; var title = &quot;百度&quot;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8,条件结构里的：if结构和switch结构if结构代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //if 选择结构: /* 伪代码: if(条件)&#123; 执行的代码块语句. &#125; if(条件)&#123; 执行条件成立的代码块语句. &#125;else&#123; 执行条件不成立的代码块语句 &#125; if(条件1)&#123; 执行条件1代码语句. &#125;else if(条件2)&#123; 执行条件2代码块语句. &#125;else if(条件3)&#123; 执行条件3代码块语句. &#125;else&#123; 执行以上条件不满足的代码块语句. &#125; */ var weather = &#x27;下刀子&#x27;; /* if(weather == &#x27;sun&#x27;)&#123; alert(&#x27;我们就去爬梧桐山!&#x27;); &#125;else&#123; alert(&#x27;我们还是写作业吧!&#x27;); &#125; */ if(weather == &#x27;sun&#x27;)&#123; alert(&#x27;我们就去爬梧桐山!&#x27;); &#125;else if(weather ==&#x27;hot&#x27;)&#123; alert(&#x27;我们就去游泳!&#x27;); &#125;else if(weather == &#x27;rain&#x27;)&#123; alert(&#x27;我们就去召唤师峡谷!&#x27;); &#125;else if(weather == &#x27;snow&#x27;)&#123; alert(&#x27;我们就去打雪仗!&#x27;); &#125;else&#123; alert(&#x27;我想静静!&#x27;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; switch结构代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var week = 1; //switch 结构,从上至下开始判断case条件 ,如果遇到成功的,会一直往下默认为成功,挨个触发条件的代码 //注意 : case 后面只能写(常量) //case 的比较其实是 属于全等于 switch(week)&#123; case 1: alert(&#x27;走向深渊...&#x27;); break; //打断 case 2: alert(&#x27;路漫漫...&#x27;); break; //打断 case 3: alert(&#x27;夜茫茫...&#x27;); break; //打断 case 4: alert(&#x27;黎明前的黑暗...&#x27;); break; //打断 case 5: alert(&#x27;看见曙光...&#x27;); break; //打断 case 6: alert(&#x27;迎接黎明!&#x27;); break; //打断 default: alert(&#x27;享受黎明!&#x27;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 9，循环结构：①for循环： 12345678910111213141516171819202122232425&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //for() 循环 /* for(1.初始部分;2.循环条件;4.迭代条件)&#123; //3.每次循环需要执行的代码 &#125; */ for(var i=0;i&lt;100;i++)&#123; document.write(&quot;1教育改变生活!&lt;br/&gt;&quot;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ②while循环： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //需求 :在网页中, 输出100 行内容 //使用while 循环 解决重复操作 : 1.循环条件(输出次数&lt;100) 2.循环操作 (输出每一次内容) /* while(循环条件)&#123; //循环条件满足下 ,执行的每一次操作 &#125; **/ //1.初始值(计数) var i = 0; while(i&lt;100)&#123;//2.循环条件 //3.每一次的循环操作 document.write(&quot;1教育改变生活!&lt;br/&gt;&quot;); i++;//4.迭代条件 &#125; //在循环条件不明确的时候 ,使用while 循环比较多 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ③do-while循环： 1234567891011121314151617181920&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //do ... while 循环 //无论条件十分成立 ,至少会执行一次. var i = 11; do&#123; console.log(123); i++; &#125;while(i&lt;10) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ④for in循环：会遍历数组 123456789101112131415161718192021222324&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [&#x27;orange&#x27;,&#x27;apple&#x27;,&#x27;banana&#x27;,&#x27;peach&#x27;]; /*for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]); &#125;*/ //for in 遍历数组 for(index in arr)&#123; console.log(index,arr[index]); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 10，break语句、continue语句和return语句：①break语句：立即退出整个循环 12345678910111213141516171819202122232425&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //需求: 从一组数据中, 找到 是 2 和 3 的倍数的整数后就直接停止 ,返回这个值 var arr = [1,2,3,4,5,6,7,8,9,10,11,12]; for(var i = 0;i&lt;arr.length;i++)&#123; if(arr[i]%2==0 &amp;&amp; arr[i]%3==0)&#123; console.log(&#x27;这个数字是:&#x27;+arr[i]); break; //终止循环 ,跳出整个循环体 ,位于break 后的代码将不再执行 &#125; console.log(&#x27;这是第:&#x27;+(i+1)+&#x27;次循环.&#x27;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ②continue语句：只退出当前循环，根据判断条件来决定是否进入下一次循环 123456789101112131415161718192021222324&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //需求: 从一组数据中, 找到 不是 2 和 3 的倍数的整数 并输出返回这个值 var arr = [1,2,3,4,5,6,7,8,9,10,11,12]; for(var i = 0;i&lt;arr.length;i++)&#123; if(arr[i]%2==0 &amp;&amp; arr[i]%3==0)&#123; continue; // 跳出当前循环,后面代码语句不再执行, 直接进入下一次循环 &#125; console.log(&#x27;这是数字是:&#x27;+arr[i]); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ③return语句：（终止）也有打断作用，使用在函数中 1234567891011121314151617181920&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //return 使用在函数中 function abc()&#123; return 50; console.log(&#x27;哈哈哈啊哈哈哈&#x27;); //此处代码不会被运行 &#125; abc(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 11，程序调试：常见调试方法有： ①直接在浏览器的控制台（console）（主动报红色的错误，一般就是语法错误（低级错误））。 ②逻辑或者业务流程错误（没有语法错误，效果也有反应，但是不是预期的效果）。 断点调试： ①alert()警告弹窗。 ②直接使用console.log()在觉得可能出现问题的代码处，输出你觉得有问题的数据值，进行审查是否与结果一致。 ③直接通过浏览器的控制台打断点，进行调试：在浏览器控制台打开[sources]-&gt;打开对应的文件，找到对应代码处的行号位置，点上断点，再次刷新浏览器。 示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;name()&quot;&gt;按钮&lt;/button&gt; &lt;button onclick=&quot;abc()&quot;&gt;abc&lt;/button&gt; &lt;script&gt; /* 常见的调试方式: 1.直接在浏览器的控制台(console) (主动报红色的错误 ,一般就是语法错误(低级错误)) 2.逻辑或者业务流程错误(没有语法错误,效果也有反应,但是不是预期的效果) 只能审查程序运行流程,每一个环节运行是否跟设定预期一样. - 【断点调试】 断点调试： 1.alert() 2.直接使用console.log() 在觉得可能出现问题的代码处 ,输出你觉得有问题的数据值,进行审查是否与结果一致 3.直接通过浏览器的控制台打断点 ,进行调试: 在浏览控制台打开[sources] - &gt; 打开对应的文件 ,找到对应代码处的行号位置 ,点上断点 ,再次刷新浏览器. */ /*var name = 123; console.log(name);*/ /*function name()&#123; alert(123); &#125;*/ /*var abc = 123; function abc()&#123; alert(132) &#125; */ //alert(132); //console.log(456); for(var i=0;i&lt;3;i++)&#123; document.write(&#x27;&lt;br/&gt;哈哈哈哈哈啊&#x27;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12,计算100以内偶数之和案例：有两个方法①方法的原理是先定义一个sum变量等于零，再用if条件判断出能被2整除的数i，然后定义i等于零再循环100次，最后sum+=i累加得出sum为100以内偶数之和，同理求100以内奇数之和就是用if条件判断出不能被2整除或者求余等于1的数，后面都是一样的。 ②方法的原理是也是先定义一个sum变量等于零，然后不用if判断，直接定义i=2;i&lt;=100;i+=2;也就是每次累加2，最后sum+=i，得出sum为100以内偶数之和，求奇数之和把i的初始值定为1即i=1即可。 代码如下： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var sum = 0; /*for(var i=0;i&lt;=100;i++)&#123; if(i%2==0)&#123; sum+=i; &#125; &#125;*/ for(var i=2;i&lt;=100;i+=2)&#123; sum+=i; &#125; console.log(&#x27;i最后为:&#x27;,i); document.write(&#x27;100以内的偶数之和为:&#x27;+sum); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 13，乘法口诀表案例：原理是利用双循环（循环里面再包一个循环），外面的循环定义i为行数i=1;i&lt;9;i++;初始值为1，大于9就中断循环操作，每次加1，累积也就是循环9次；里面的循环定义j为列数j=1;j&lt;i;j++;初始值为1，大于i就中断循环操作，j每一行显示的次数与i的大小有关，这样第一行1个，第二行2个，第三行3个…，所以i是自变量，j是应变量（随着i的增大而增大）。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt;.box span&#123; display:inline-block; width:100px; height:30px; border:1px solid #ccc; line-height:30px; text-indent:10px; font-weight:bold; &#125;.box span.even&#123; background:#f9f9f9; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;script&gt; for(var i=1;i&lt;=9;i++)&#123; for(var j=1;j&lt;=i;j++)&#123; document.write( &#x27;&lt;span class=&quot;&#x27;+(i%2==0?&quot;even&quot;:&quot;odd&quot;)+&#x27;&quot; style=&quot;color:&#x27;+creatRGBColor()+&#x27;;&quot;&gt;&#x27;+ i +&#x27; X &#x27;+ j + &#x27; = &#x27; + i*j + &#x27;&lt;/span&gt;&#x27; ); &#125; document.write(&#x27;&lt;br/&gt;&#x27;); &#125; //回顾: 颜色表示方式: 1.关键字 2.十六进制 3.rgb rgb(255,255,255); function creatRGBColor()&#123; var R = parseInt(Math.random()*256); var G = parseInt(Math.random()*256); var B = parseInt(Math.random()*256); return &#x27;rgb(&#x27;+R+&#x27;,&#x27;+G+&#x27;,&#x27;+B+&#x27;)&#x27;; &#125; &lt;/script&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 14，幸运大抽奖：原理是：用一个数组表示一个学生和ta的性别，下标0位置为名字；下标1位置为性别，性别0为女生，1为男生。 形成好一个二维数组后，再在这个二维数组中抽取出的数组取出下标为0的元素，也就是一个随机的人的名字。 例子数组： var =[‘叶丽婷’,0]; ​ var =[‘林伊杰’,0]; 步骤： ①首先定义一个全班同学名字的数组var Students=[‘叶丽婷’,’詹小玲’,’徐路金’,’林伊杰’,’张鑫’,’岑广权’,’胡晓丽’,’彭锦程’,’廖淼’,’刘伟’,’贾俊’,’温奕龙’,’周顺发’,’陈兴宗’,’侯倩倩’,’郭晓权’,’白元’,’余宏彪’,’李深’,’马张壹’,’曾志杰’,’王浩’,’许小文’,’郭欢子’,’高虹’]; ②再定义一个全班女生的名字的数组var women=[‘叶丽婷’,’詹小玲’,’胡晓丽’,’侯倩倩’,’郭欢子’,’高虹’]; ③然后再定义一个空的数组 var newStudents=[]; ④下面就是要把这个空数组中推入像例子数组一样，每个同学都得推进去就是用push()数组方法 推入的步骤： 在外面包一个循环，循环的次数为Students数组的长度，为for(var i=0;i&lt;Students.length;i++){ 里面写上判断。 ​ if(women.includes(Students[i])){ ​ newStudents.push([Students[i],0);/如果Students中循环到的元素在women数组中能查找的到就向newStudents数组中push推入这个元素和对应性别数字0形成的数组 例[‘叶丽婷’,0];newStudents会变成一个二维数组。/ ​ }else{ ​ newStudents.push([Students[i],1]);/这个就和上面的相反，就是如果Students中循环到的元素在women数组中不能查找的到就向newStudents数组中push推入这个元素和对应性别数字1形成的数组 例[‘林伊杰’,1];newStudents会变成一个二维数组*/ ​ } ​ } 经过上面的步骤就会空数组newStudents=[[‘叶丽婷’,0],[‘詹小玲’,0],[‘徐路金’,1],[‘林伊杰’,1],[‘张鑫’,1],[‘岑广权’,1],[‘胡晓丽’,0],[‘彭锦程’,1],[‘廖淼’,1],[‘刘伟’,1],[‘贾俊’,1],[‘温奕龙’,1],[‘周顺发’,1],[‘陈兴宗’,1],[‘侯倩倩’,0],[‘郭晓权’,1],[‘白元’,1],[‘余宏彪’,1],[‘李深’,1],[‘马张壹’,1],[‘曾志杰’,1],[‘王浩’,1],[‘许小文’,1],[‘郭欢子’,0],[‘高虹’,0]]; 下一步就是定义一个随机数var num=parseInt(Math.random()*newStudents); 最后就是输出得到的中奖名字了 1document.write(newStudent[num][0]) i表示newStudents中的随机的一个数组了，[0]表示该得到的数组中的0位置的元素，也就是随机抽到的学生的名字了。（这是抽一个同学的名字的方法，抽十个或更多的同学的名字看下一个代码框(不重复用splice方法删除)） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;班级抽奖综合&lt;/title&gt; &lt;style&gt; .container&#123; width:200px; height:150px; margin:20px auto; border:1px solid #111; text-align:center; line-height:150px; &#125; .container2&#123; display:table; width:800px; height:300px; margin:20px auto; border:1px solid #111; &#125; .td&#123; display:table-cell; text-align:center; vertical-align:middle; &#125; span&#123; display: inline-block; margin:10px 20px; height:80px; width:120px; background:#ccc; border-radius:20px; text-align:center; line-height:80px; font-size:20px; font-weight:bold; color:#fff; &#125; .manblue&#123; background:blue; &#125; .womanred&#123; background:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;javascript:location.reload()&quot;&gt;点击抽取幸运同学&lt;/a&gt; &lt;script&gt; var Students=[&#x27;叶丽婷&#x27;,&#x27;詹小玲&#x27;,&#x27;徐路金&#x27;,&#x27;林伊杰&#x27;,&#x27;张鑫&#x27;,&#x27;岑广权&#x27;,&#x27;胡晓丽&#x27;,&#x27;彭锦程&#x27;,&#x27;廖淼&#x27;,&#x27;刘伟&#x27;,&#x27;贾俊&#x27;,&#x27;温奕龙&#x27;,&#x27;周顺发&#x27;,&#x27;陈兴宗&#x27;,&#x27;侯倩倩&#x27;,&#x27;郭晓权&#x27;,&#x27;白元&#x27;,&#x27;余宏彪&#x27;,&#x27;李深&#x27;,&#x27;马张壹&#x27;,&#x27;曾志杰&#x27;,&#x27;王浩&#x27;,&#x27;许小文&#x27;,&#x27;郭欢子&#x27;,&#x27;高虹&#x27;];//首先创建一个整个班级人员的数组。 var women=[&#x27;叶丽婷&#x27;,&#x27;詹小玲&#x27;,&#x27;胡晓丽&#x27;,&#x27;侯倩倩&#x27;,&#x27;郭欢子&#x27;,&#x27;高虹&#x27;];//把女生创建成单独一个数组。 var newStudents=[];//创建一个新的空数组。 for(i=0;i&lt;Students.length;i++)&#123;//循环班级中的人数的次数。 if(women.includes(Students[i]))&#123;//如果循环的元素中有个women数组中的元素一样则往该newStudents空数组中push推入这个元素和0，形成一个数组里面的数组 例：女生为：[&#x27;叶丽婷&#x27;,0]。 newStudents.push([Students[i],0]); &#125;else&#123; newStudents.push([Students[i],1]);//相反则往该newStudents空数组中push推入Students中的women中没有的元素和1 例：男生为：[&#x27;彭锦程&#x27;,1]。 &#125; &#125; console.log(newStudents);//在调试程序中输出newStudents。 //这样会得到newStudent=[[&#x27;叶丽婷&#x27;,0],[&#x27;詹小玲&#x27;,0],[&#x27;徐路金&#x27;,1],[&#x27;林伊杰&#x27;,1],[&#x27;张鑫&#x27;,1],[&#x27;岑广权&#x27;,1],[&#x27;胡晓丽&#x27;,0],[&#x27;彭锦程&#x27;,1],[&#x27;廖淼&#x27;,1],[&#x27;刘伟&#x27;,1],[&#x27;贾俊&#x27;,1],[&#x27;温奕龙&#x27;,1],[&#x27;周顺发&#x27;,1],[&#x27;陈兴宗&#x27;,1],[&#x27;侯倩倩&#x27;,0],[&#x27;郭晓权&#x27;,1],[&#x27;白元&#x27;,1],[&#x27;余宏彪&#x27;,1],[&#x27;李深&#x27;,1],[&#x27;马张壹&#x27;,1],[&#x27;曾志杰&#x27;,1],[&#x27;王浩&#x27;,1],[&#x27;许小文&#x27;,1],[&#x27;郭欢子&#x27;,0],[&#x27;高虹&#x27;,0]]; &lt;/script&gt; &lt;div class=&quot;container&quot;&gt; &lt;script&gt; var num=parseInt(Math.random()*newStudents.length);//定义一个随机数字num，随机的次数为数组的长度.length，parseInt为取整数。 document.write(&#x27;&lt;span class=&quot;&#x27;+(newStudents[num][1]?&quot;manblue&quot;:&quot;womanred&quot;/*三目运算，意思是如果随机取到的num为1则得到manblue否则就是womanred，这两个分别在前面设置了样式，红色是女生，蓝色是男生*/)+&#x27;&quot;&gt;&#x27;+newStudents[num][0]/*[0]取该二位数组随机得到的一维数组中的下标为0的元素，也就是第一个元素，就是学生的名字。*/+&quot;&lt;/span&gt;&quot;);//输出随机得到的一个数组中的元素 &lt;/script&gt; &lt;/div&gt; &lt;div class=&quot;container2&quot;&gt; &lt;div class=&quot;td&quot;&gt; &lt;script&gt; for(var i=0;i&lt;10;i++)&#123;//该操作循环十次 var num=parseInt(Math.random()*newStudents.length);//定义一个随机数字num，随机的次数为数组的长度.length，parseInt为取整数。 var std=newStudents.splice(num,1)[0];//定义一个新的数组std，删除原数组newStudents中随机num位置1个元素添加到std中，[0]的意思是如果得到的是个数组，却想要里面0位置的元素，splice的作用是删除出来添加的std中不会重复。 document.write(&#x27;&lt;span class=&quot;&#x27;+(std[1]?&quot;manblue&quot;:&quot;womanred&quot;)+&#x27;&quot;&gt;&#x27;+std[0]+&quot;&lt;/span&gt;&quot;);//输出的得到的元素。 &#125; &lt;/script&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 15，数组的常见20种方法：（补充：数组只有一个属性即数组的长度length）1，join()：将数组中的所有元素，通过一个指定的字符（默认为 ,），拼接成一个字符串。 2，concat()：将多个数组拼合成一个数组。 3，reverse()：将数组中的元素调换顺序。 4，push()：在数组的末尾追加一个或多个元素，返回数组的新的长度。 5，pop()：删除数组的最后一个元素，返回被删除的元素。 6，shift()：删除数组的开头的一个元素，返回被删除的元素。 7，unshift()：在数组的开头添加一个或者多个元素，返回数组的新的长度。 8，slice(start,end)：截取数组中的元素，start&lt;=x&lt;end，如果设置了范围则截取范围里的元素，没设置的话则全部截取。 9，splice(index,howmany,item,item…)：索引数组中的index位置的，howmany个元素，再在该数组中添加item元素，可添无数个。 10，indexOf(item,[index])：查找元素在数组中首次出现的位置，没设置开始查找位置index的话默认从第一个元素开始找，设置了的话，从index位置开始找首次出现的位置，（最后都是返回查找到的元素的位置下标），如果没找到则返回-1。 11，sort()：将数组的元素进行排序，以数组的元素编码大小排序，（一般可以在网上查找该数组的16进制编码）。 12，toString()：将数组转化成字符串。 13，includes(item,[index])：用于检测item元素是否存在于与数组，如果是，则返回true，如果不是则返回false，index为查找的开始位置。 14，forEach()：遍历数组，数组遍历方法，与循环相似。 15，filter()：过滤，筛选；以自己提出的条件对数组进行筛选，挑选出来符合条件的元素。 16，map()：地图，映射；将数据按照自己提出的一定要求，映射成另外一种格式或数据（也就是把原数组种的元素以自己设置的item元素的符合条件，替换成对应的元素。） 17，reduce()：累加，累乘，累除，累减… 18，flat(num)：扁平化处理，num是展开的次数，通俗的说就是把一个多维数组进行降维处理，比如三维到一维需要两次，即num=2。 19，fill(str,start,end)：直接将数组中的元素替换成start&lt;=x&lt;end之间的指定的str元素或者字符，没设置区间的话默认全部替换。 20，lastIndexOf(item,[index])：查找数组中的最后一次出现的item元素，index为查找位置。（最后还是返回查找的元素的位置下标） ，没找到默认为-1。 数组的方法代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //创建数组方式一 var arr=new Array(5); arr[0]=&#x27;apple&#x27; arr[1]=&#x27;banana&#x27; arr[2]=&#x27;orange&#x27; arr[3]=&#x27;peach&#x27; arr[4]=&#x27;grape&#x27;// alert(arr[3]); //创建数组方式二 var arr2=new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;);// alert(arr2[3]); //创建数组方式三 var arr3=[&quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;,&quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;]; var arr4=[[1,2,3],[4,5,6],[7,8,9]] var socer=[20,25,65,56,58,50,90,100,75,60,80];// alert(arr3[3]); //数组属性length// alert(arr3.length); /*数组九种方法*/ //第一种join()// alert(arr3.join(&quot;|&quot;));/*将数组中的所有元素，通过一个指定的字符（默认为，）可以为任何东西，拼接成一个字符串。*/////// //第二种concat()// alert(arr3.concat(arr2));/*将多个数组拼合成一个数组。*/////// //第三种reverse()// alert(arr3.reverse());/*将数组中的元素顺序调换。*/////// //第四种push()// alert(arr3.push(&quot;apple&quot;, &quot;peach&quot;));/*在数组的尾端追加一个或多个元素，返回数组的新长度*/////// //第五种pop()// alert(arr3.pop());/*删除数组的最后一个元素，返回被删除的元素*///////// //第六种shift()// alert(arr3.shift());/*删除数组的第一个元素，返回被删除的元素*///////// //第七种unshift()// alert(arr3.unshift(&quot;hh&quot;,&quot;heihei&quot;));/*给数组元素的开头添加一个或者多个元素，返回元素的长度*///////// //第八种slice(start,end)start&lt;=x&lt;end// alert(arr3.slice(-5,-3));/*截取数组中的元素，在start和end之间，start自己算一个end不算，返回截取的一个或者多个元素。*///////// //第九种splice(index,howmany,item,item...) // alert(arr3.splice(2,3,&quot;hhhh&quot;));/*删除数组中的索引值为index位置的元素，个数为howmany个，然后再该位置加item元素。*/ // // // //第十种indexOf(item,index) // alert(arr3.indexOf(&quot;apple&quot;,[1]));/*元素在数组中首次出现的位置，指定从什么位置(index)开始查找item的首次出现位置，默认为0，如果返回-1，表示没有找到。 // // // //第十一种sort()对数组中的元素进行排序(以元素的编码大小进行排序),编码为16进制可转化为10进制。 // // // // //第十二种toString()将此数组转化成一个字符串(即里面的双引号都删除，只留下最外面两边的双引号)。 // // // ////下面是ES6新增的方法: //第十三种includes(item,[index]); // alert(arr3.includes(&quot;apple&quot;,5));/*用于检测item元素是否存在于数组，如果是则返回true，否则返回false，index为开始查找是否存在的位置。 // 下面四个和循环有关系 // // // //第十四种forEach() /*例：可利用forEach()来循环一个数组长度的次数，如果是用for，while，do while，for in循环的1话可能会更加麻烦*/ // var sexs=[0,1,0,0,1,0,1,0,1,1,1,1,0,0,1] // var newSexs=[]; // sexs.forEach(function(item)&#123; // newSexs.push(item?&quot;男&quot;:&quot;女&quot;) // &#125;) // document.write(newSexs); /*遍历数组的方法，和循环有点相似，不过只循环数组每个元素一遍，即数组的长度。使用产生的效果是把原数组循环一遍，以你自己设置好的条件是替换这个数组里面的元素还是删除(或者其他的方法都可以在这里面使用，和循环相似)这个数组里面的元素。*/ //第十五种filter() // var ff=socer.filter(function(item)&#123; // return item&lt;60; // &#125;) /*以自己对item设置的条件进行筛选符合条件的原数组socer中的元素放到一个新的数组ff中，例子中我做了一个筛选出不及格的人的分数放到了ff数组中。 //第十六种map()地图，映射的意思，在我们程序里面可当做把原数组socer中的元素以自己设置的item元素的符合条件，替换成对应的元素，例：*/ // var mm=socer.map(function(item)&#123; // return item&lt;60?&quot;不及格&quot;:item&gt;80?&quot;优秀&quot;:&quot;及格&quot;; // &#125;) /*return是将值返回给mm，这段的意思是，把成绩小于60分的同学定为不及格，大于80分的定为优秀，另外的也就是60到80之间的是及格，最后再把得到的元素即&quot;及格&quot;，&quot;不及格&quot;，&quot;优秀&quot;对应的替换到mm数组*/ //第十七种reduce()求累加，累减，累乘，累除等。 // var rr=socer.reduce(function(sum,item)&#123; // console.log(item,sum); // return sum+=item; // &#125;) /*可以吧加号换成*号就是累乘，-号和/号也是一样的，item是最后一项即an，sum是第一项到倒数第二项之和即Sn-1，他们两个加起来就是Sn整个数组的元素之和*/ //第十八种flat(num) // alert(arr4.flat());/*扁平化处理，num是展开的次数，例：三维一维需要num=2即两次，此方法是对一个多维数组进行降维处理*/ //第十九种fill(str,start,end) // alert(arr3.fill(1,0,5));/*此方法的作用是直接将数组的元素替换成指定的元素str（可以是字符等其他东西），start&lt;=x&lt;end,如果不加start和end截取的位置的话，默认全部替换。 //第二十种lastIndexOf(item,[index]) alert(arr3.lastIndexOf(&quot;apple&quot;,2));/*此方法与indexOf索引元素方向相反，返回item出现的最后一个位置，index为查找截止索引的位置，找不到返回-1*/ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第二章：jQuery基础1.为什么要使用jQuery​ jQuery是javascript的程序库之一，javascript对象和实用函数的封装。​ 1，jQuery代码更简单​ 2，各个浏览器兼容 ​ jQuery能做什么 （jqzz库网站）​ 1，访问和操作dom|​ 2，控制页面 ​ jQuery的优势​ 1，体积小，压缩之后只有100kb左右​ 2，强大的选择器​ 3，出色的DOM封装​ 4，可靠的事件处理机制​ 5，出色的浏览器兼容性​ 6，使用隐私迭代简化编程​ 7，丰富的插件支持 ​ CDN（content delievry network）内容分发网络 2.jQuery引入方法1234567891011121314151617&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt; &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--1.使用本地js(开发,测试阶段 &#x3D;&gt;开发环境)--&gt;&lt;!--&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;jquery-v1.12.0.min.js&quot;&gt;&lt;&#x2F;script&gt;--&gt;&lt;!--2.(部署上线-&gt;生产环境)使用cdn 方式引入 : cdn 加速,并且降低自己服务器压力,减少自己服务器带宽使用--&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;1.12.0&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 3.jQuery基础使用123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //使用jQuery 之前 ,需要先引入 ,然后再编写或引入自己的js // console.log(jQuery); //jQuery === $(别名) //console.log(jQuery === $); //工厂函数 jQuery() == $() //解决jQuery $ 符合的使用冲突 var RMB = jQuery.noConflict(); console.log(RMB); /* 语法结构: jQuery(选择器).执行的操作() 例如: 给一个类名为.box 的按钮,设置一个点击事件 jQuery(&quot;.box&quot;).click(function()&#123; alert(&#x27;单机事件&#x27;) &#125;) 理解为 : 先找到需要执行操作的DOM元素 ,然后给设定一个操作(可以是事件,也可是一个DOM的增删改查) */&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.初次使用jQuery案例12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button class=&quot;btn&quot;&gt;按钮&lt;/button&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; jQuery(&quot;.btn&quot;).click(function()&#123; alert(&#x27;单击事件&#x27;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.ready()事件和window.onload事件的区别1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //onload 事件: 页面加载(静态资源文件,图片...)完毕之后触发的事件 (只能触发一次) window.onload = function()&#123; alert(&#x27;网页加载完毕!1&#x27;); &#125; // window.onload = function()&#123; // alert(&#x27;网页加载完毕!2&#x27;); // &#125; //ready() 事件:页面文档结构(html)加载完毕触发 (不包括图片等资源) - 支持多次 jQuery(document).ready(function () &#123; alert(&#x27;页面加载完毕!1&#x27;); &#125;) $(document).ready(function () &#123; alert(&#x27;页面加载完毕!2&#x27;); &#125;) //简写 $(function()&#123; alert(&#x27;页面加载完毕!3&#x27;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.css()方法12345678910111213141516171819202122232425262728293031323334353637&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;修改样式&lt;/button&gt; &lt;div class=&quot;box&quot;&gt; 教育改变生活! &lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&quot;button&quot;).click(function()&#123; //1.设置css 样式 (两个参数) // $(&quot;.box&quot;).css(&#x27;color&#x27;,&#x27;red&#x27;); // $(&quot;.box&quot;).css(&#x27;font-size&#x27;,50); //2.设置多个样式(参数为对象) // $(&quot;.box&quot;).css(&#123; // color:&quot;red&quot;, // // &#x27;font-size&#x27;:50, // fontSize:50, // fontWeight:&#x27;bold&#x27; // &#125;); //3.读取元素的样式属性值 (一个参数) alert($(&quot;.box&quot;).css(&quot;font-size&quot;)); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.获取DOM对象的方法123456789101112131415161718192021222324252627282930313233343536&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt;哈哈哈哈&lt;/div&gt; &lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //使用原生js获取 var box = document.getElementById(&quot;box&quot;); //DOM对象:可以使用DOM对象中提供的方法和属性 // box.css(&#x27;color&#x27;,&#x27;red&#x27;); // 报错 ,没有css方法 // $(box).css(&#x27;color&#x27;,&#x27;red&#x27;); // box 已经转变成jQuery对象 //使用jQuery 获取 var box2 = $(&quot;#box&quot;); //jQuery 对象 : 可以使用jQuery对象中提供的属性和方法 // box2.style.color=&quot;red&quot;; //报错 ,没有style属性 // box2[0].style.color=&quot;red&quot;; // jQuery对象转成DOM对象 box2.get(0).style.color=&quot;red&quot;; // jQuery对象转成DOM对象 //回顾: 不同的对象 会有不同的属性及方法 . 例如: 字符串对象有字符串的方法,数组有数组的方法 //所谓的jQuery对象 其实就是通过jQuery包装过的DOM对象的集合. // jQuery 对象 &lt; === &gt; DOM对象 //1.DOM对象转jQuery对象 : 直接使用$(DOM对象) 即可 //2.jQuery对象转DOM 对象 =&gt; 直接使用数组下标 , 也可以使用get(0) 获取 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第三章：jQuery选择器1.基本选择器（基本和前面javascript选择器用法基本一样）123456789101112131415161718192021222324252627282930&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1.标签选择器 //2.类选择器 //3.ID选择器 //4.交集选择器 //5.并集选择器 $(function () &#123; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.层级选择器（基本和前面javascript选择器用法基本一样）1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //6.后代选选择器 //7.子元素选择器 //8.相邻兄弟元素选择器 + //9.同辈元素选择器 ~ $(function () &#123; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.属性选择器（基本和前面javascript选择器用法基本一样）1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //10. [name] 具有指定属性名 //11. [name=value] 具有指定属性及属性值value //12. [name!=value] 具有指定属性 ,并且值不等于value //13. [name^=value] 具有指定属性,并且属性值以value开头 //14 [name$=value] 具有指定属性,并且属性值以value结尾 //15. [name*=value] 具有指定属性,并且属性值包含value $(function () &#123; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.过滤选择器—基本过滤12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;这是一个h1标题标签&lt;/h1&gt; &lt;h2&gt;这是一个h2标题标签&lt;/h2&gt; &lt;h3&gt;这是一个h3标题标签&lt;/h3&gt; &lt;h4&gt;这是一个h4标题标签&lt;/h4&gt; &lt;h5&gt;这是一个h5标题标签&lt;/h5&gt; &lt;h6&gt;这是一个h6标题标签&lt;/h6&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;这是列表项1&lt;/li&gt; &lt;li&gt;这是列表项2&lt;/li&gt; &lt;li&gt;这是列表项3&lt;/li&gt; &lt;li&gt;这是列表项4&lt;/li&gt; &lt;li&gt;这是列表项5&lt;/li&gt; &lt;li&gt;这是列表项6&lt;/li&gt; &lt;li&gt;这是列表项7&lt;/li&gt; &lt;li&gt;这是列表项8&lt;/li&gt; &lt;li&gt;这是列表项9&lt;/li&gt; &lt;li&gt;这是列表项10&lt;/li&gt; &lt;/ul&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; //16.:first 从匹配元素中, 选取第一个匹配元素 // $(&quot;li:first&quot;).css(&quot;background&quot;,&#x27;red&#x27;); //17. :last 从匹配元素中 ,选取最后一个匹配元素 // $(&quot;li:last&quot;).css(&quot;background&quot;,&#x27;green&#x27;); //18. :even 从匹配元素中,选取索引值为偶数的元素 // $(&quot;li:even&quot;).css(&quot;background&quot;,&#x27;green&#x27;); //19. :odd 从匹配元素中 ,选取索引值为奇数的元素 // $(&quot;li:odd&quot;).css(&quot;background&quot;,&#x27;red&#x27;); //20. :eq(index) 从匹配元素中 ,选取指定索引值index的元素 // $(&quot;li:eq(5)&quot;).css(&quot;background&quot;,&#x27;green&#x27;); //21. :gt(index) 从匹配元素中 ,选取指定索引值大于index的元素 $(&quot;li:gt(3)&quot;).css(&quot;background&quot;,&#x27;red&#x27;); //22. :lt(index) 从匹配元素中 ,选取指定索引值小于index的元素 $(&quot;li:lt(3)&quot;).css(&quot;background&quot;,&#x27;green&#x27;); //23. :header 从匹配元素中 ,选取所有的标题元素 $(&quot;:header&quot;).css(&quot;color&quot;,&quot;red&quot;); //24. * 通配符 ,选择所有元素 $(&quot;*&quot;).css(&quot;color&quot;,&quot;green&quot;); //25. :animated 从匹配元素中 ,选取正在执行动画的元素 &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.过滤选择器—内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;p&gt;教育改变生活111&lt;/p&gt; &lt;p&gt;&lt;span&gt;教育改变生活2222&lt;/span&gt;&lt;/p&gt; &lt;/div&gt;&lt;hr&gt; &lt;p&gt;您好家居安静安静嗷嗷叫啊啊&lt;/p&gt; &lt;p&gt;安达市多多大多大大奥撒群翁无&lt;/p&gt; &lt;p&gt;sdddddsdsdassasddadsasasadasdda&lt;/p&gt; &lt;p&gt;sdddddsdsdass您好dsasasadasdda&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;sdddddsdsdass您好dsasasadasdda&lt;/p&gt; &lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // var p = document.getElementsByTagName(&quot;p&quot;); // // var re = []; // for(var i=0;i&lt;p.length;i++)&#123; // if(p[i].innerText.indexOf(&quot;您好&quot;)&gt;=0)&#123; // re.push(p[i]); // &#125; // &#125; $(function () &#123; //26. :contains(text) 从匹配元素中 ,选取包含内容文本为text 元素 // $(&quot;p:contains(&#x27;您好&#x27;)&quot;).css(&quot;color&quot;,&quot;red&quot;); //27. :empty 从匹配元素中 ,选取没有子元素,或者元素内容为空的元素 // $(&quot;p:empty&quot;).css(&#123; // border:&quot;1px solid red&quot;, // padding:50 // &#125;) //28. :parent 从匹配元素中,选取包含子元素 ,或者元素内容不为空的元素 $(&quot;p:parent&quot;).css(&#123; border:&quot;1px solid red&quot;, padding:50 &#125;) //29. :has(selector) 从匹配元素中,选取具有selector选择器匹配内容的元素 $(&quot;#box p:has(span)&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.过滤选择器—可见性1234567891011121314151617181920212223242526&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;1啊哈哈啊哈哈哈啊哈啊啊哈哈啊&lt;/div&gt;&lt;div style=&quot;display: none;&quot;&gt;2啊哈哈啊哈哈哈啊哈啊啊哈哈啊&lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; //30. :visible 从匹配元素中 选取可见元素 $(&quot;div:visible&quot;).css(&quot;color&quot;,&quot;red&quot;); //31. :hidden 从匹配元素中 ,选取不可见元素 $(&quot;div:hidden&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.过滤选择器—子元素选择器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div&gt; &lt;p&gt;这是一个p标签11111&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;这是一个p标签22222222&lt;/p&gt; &lt;p&gt;这是一个p标签22222222&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;hr&gt; &lt;ul&gt; &lt;li&gt;这是列表项1&lt;/li&gt; &lt;li&gt;这是列表项2&lt;/li&gt; &lt;li&gt;这是列表项3&lt;/li&gt; &lt;li&gt;这是列表项4&lt;/li&gt; &lt;li&gt;这是列表项5&lt;/li&gt; &lt;li&gt;这是列表项6&lt;/li&gt; &lt;li&gt;这是列表项7&lt;/li&gt; &lt;li&gt;这是列表项8&lt;/li&gt; &lt;li&gt;这是列表项9&lt;/li&gt; &lt;li&gt;这是列表项10&lt;/li&gt; &lt;/ul&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; //css3 选择器 //32. :first-child 从匹配元素中 ,选取出第一个子元素 // $(&quot;ul li:first-child&quot;).css(&quot;color&quot;,&quot;red&quot;); //33. :last-child 从匹配元素中 ,选取出最后个子元素 // $(&quot;ul li:last-child&quot;).css(&quot;color&quot;,&quot;red&quot;); //34. :nth-child(index) 从匹配元素中,选取索引值index位置元素 ,css中的索引值从1开始 // $(&quot;ul li:nth-child(1)&quot;).css(&quot;color&quot;,&quot;red&quot;); //35. :only-child 从匹配元素中 ,选取该元素是父元素中唯一一个子元素的元素 $(&quot;#box div p:only-child&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8.过滤选择器-表单元素1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; //36. :input 匹配所有 input, textarea, select 和 button 元素 //37. :text 匹配所有匹配元素中 ,表单类型为text 元素 //38. :password //39. :checkbox //40. :radio //41. :submit //42. :reset //43. :button //44. :file //45. :image //46. :hidden &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 9.过滤选择器-表单对象属性123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;sh&quot; selected&gt;上海&lt;/option&gt; &lt;option value=&quot;gz&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;szx&quot;&gt;深圳&lt;/option&gt;&lt;/select&gt;&lt;input type=&quot;text&quot; disabled&gt; &lt;div&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot;checked value=&quot;男&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女 &lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; //47. :checked 从匹配元素中 , 获取已经被选中的 单选 / 多选元素 // alert($(&quot;:radio:checked&quot;)[0].value) //48. :selected 从匹配元素中 ,获取预计被选中的 option 元素 alert($(&quot;select :selected&quot;)[0].value); //49. :enabled 从匹配元素中 获取所有可用的表单元素 // $(&quot;input:enabled&quot;).css(&quot;border&quot;,&quot;1px solid red&quot;); //50. :disabled 从匹配元素中 获取所有不可用的表单元素 $(&quot;input:disabled&quot;).css(&quot;border&quot;,&quot;1px solid red&quot;); //51. :not() 一切选择器的否定 , 取所有选择器的相反值 (慎用) $(&quot;:not(:header)&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第四章：jQuery选择器1.DOM事件类型12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;HTML DOM 允许 JavaScript 对 HTML 事件作出反应：&lt;/p&gt;&lt;h3&gt;jQuery事件就是 =&gt; DOM事件分类的封装:&lt;/h3&gt;&lt;p&gt;1.鼠标事件&lt;/p&gt;&lt;p&gt;2.键盘事件&lt;/p&gt;&lt;p&gt;3.表单事件&lt;/p&gt;&lt;p&gt;4.窗口事件&lt;/p&gt;&lt;p&gt;5.其他事件&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2.鼠标事件123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;按钮&lt;/button&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //鼠标事件 $(&quot;button&quot;).click(function () &#123; //鼠标单击事件 alert(132131) &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.jQuery bind绑定事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var abc = &#123; a:10 &#125; //bind(事件类型(可用有多个,空格隔开),[data],处理函数) 事件处理器函数 (专门绑定事件的函数) 1.7- ,1.7+建议使用on $(&quot;button&quot;).bind(&#x27;click mouseover&#x27;,abc,fn); $(&quot;button&quot;).bind(&#123; click:function()&#123; &#125;, mouseover:function()&#123; &#125; &#125;); $(&quot;button&quot;).bind(&#x27;click mouseover&#x27;,abc,fn2); function fn(e) &#123; // alert(&#x27;这是一个单击事件&#x27;); console.log(e.data); // e.data.a = 20; &#125; function fn2(e) &#123; // alert(&#x27;这是一个单击事件&#x27;); console.log(&quot;第二个方法&quot;); // e.data.a = 20; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.on绑定事件1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt; &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;button&gt;按钮&lt;&#x2F;button&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;jquery-v1.12.0.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; var abc &#x3D; &#123; a:10 &#125; &#x2F;&#x2F;on(事件类型(可用有多个,空格隔开),[data],处理函数) 事件处理器函数 (专门绑定事件的函数) 1.7- ,1.7+建议使用on $(&quot;button&quot;).on(&#39;click mouseover&#39;,abc,fn); $(&quot;button&quot;).on(&#39;click mouseover&#39;,abc,fn2); function fn(e) &#123; &#x2F;&#x2F; alert(&#39;这是一个单击事件&#39;); console.log(e.data); &#x2F;&#x2F; e.data.a &#x3D; 20; &#125; function fn2(e) &#123; &#x2F;&#x2F; alert(&#39;这是一个单击事件&#39;); console.log(&quot;第二个方法&quot;); &#x2F;&#x2F; e.data.a &#x3D; 20; &#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 5.unbind移除事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;button&gt;移除点击事件&lt;/button&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //bind(事件类型(可用有多个,空格隔开),[data],处理函数) 事件处理器函数 (专门绑定事件的函数) 1.7- ,1.7+建议使用on $(&quot;.box&quot;).bind(&quot;mouseover&quot;,fn); $(&quot;.box&quot;).bind(&#x27;click&#x27;,fn2); $(&quot;.box&quot;).bind(&#x27;click&#x27;,fn3); function fn(e) &#123; // alert(&#x27;这是一个单击事件&#x27;); console.log(&#x27;悬停这是一个单击事件&#x27;); // e.data.a = 20; &#125; function fn2(e) &#123; // alert(&#x27;这是一个单击事件&#x27;); console.log(&quot;单击第二个方法&quot;); // e.data.a = 20; &#125; function fn3(e) &#123; // alert(&#x27;这是一个单击事件&#x27;); console.log(&quot;单击第三个方法&quot;); // e.data.a = 20; &#125; //移除点击事件 $(&quot;button:first&quot;).click(function()&#123; // $(&quot;.box&quot;).unbind(); //移除该元素上所有的事件 // $(&quot;.box&quot;).unbind(&quot;click&quot;); //移除指定事件 $(&quot;.box&quot;).unbind(&quot;click&quot;,fn3); //移除指定事件的指定绑定的函数 &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.off移除绑定事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;button&gt;移除点击事件&lt;/button&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //bind(事件类型(可用有多个,空格隔开),[data],处理函数) 事件处理器函数 (专门绑定事件的函数) 1.7- ,1.7+建议使用on $(&quot;.box&quot;).bind(&quot;mouseover&quot;,fn); $(&quot;.box&quot;).bind(&#x27;click&#x27;,fn2); $(&quot;.box&quot;).bind(&#x27;click&#x27;,fn3); function fn(e) &#123; // alert(&#x27;这是一个单击事件&#x27;); console.log(&#x27;悬停这是一个单击事件&#x27;); // e.data.a = 20; &#125; function fn2(e) &#123; // alert(&#x27;这是一个单击事件&#x27;); console.log(&quot;单击第二个方法&quot;); // e.data.a = 20; &#125; function fn3(e) &#123; // alert(&#x27;这是一个单击事件&#x27;); console.log(&quot;单击第三个方法&quot;); // e.data.a = 20; &#125; //移除点击事件 $(&quot;button:first&quot;).click(function()&#123; // $(&quot;.box&quot;).off(); //移除该元素上所有的事件 // $(&quot;.box&quot;).off(&quot;click&quot;); //移除指定事件 $(&quot;.box&quot;).off(&quot;click&quot;,fn3); //移除指定事件的指定绑定的函数 &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.绑定一次事件12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;button&gt;移除点击事件&lt;/button&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //one(事件类型,[数据],函数) 只绑定一次事件,触发完之后移除了 $(&quot;.box&quot;).one(&quot;click&quot;,function()&#123; alert(1213513135); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8.live动态绑定事件123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 400px; height: 400px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;add&quot;&gt;添加一个按钮&lt;/button&gt; &lt;div class=&quot;box&quot;&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt; &lt;!--&lt;script src=&quot;../js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;--&gt; &lt;script&gt; //使用live()动态绑定事件 (1.10.0 左右 以后就已经删除 ,不能使用了!) $(&quot;.box button&quot;).live(&quot;click&quot;,function () &#123; alert(&quot;这是一个单击事件!&quot;); &#125;) //增加一个按钮 $(&quot;#add&quot;).click(function()&#123; $(&quot;.box&quot;).append($(&quot;&lt;button&gt;新增按钮&lt;/button&gt;&quot;)); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 9.on动态绑定事件12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 400px; height: 400px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;add&quot;&gt;添加一个按钮&lt;/button&gt;&lt;div class=&quot;box&quot;&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;!--&lt;script src=&quot;../js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;--&gt;&lt;script&gt; //使用on()动态绑定事件 (1.7+ 建议使用) //$(获取一个已经存在的父级元素例如body).on(事件类型,需要绑定事件的元素) $(&quot;.box&quot;).on(&quot;click&quot;,&quot;button&quot;,function () &#123; alert(&quot;这是一个单击事件!&quot;); &#125;) //增加一个按钮 $(&quot;#add&quot;).click(function()&#123; $(&quot;.box&quot;).append($(&quot;&lt;button&gt;新增按钮&lt;/button&gt;&quot;)); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 10.hover复合事件123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;button&gt;移除点击事件&lt;/button&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //hover(enter,leave) = &gt; :hover 集鼠标的悬停和离开 事件 $(&quot;.box&quot;).hover(function()&#123; console.log(&quot;鼠标悬停!&quot;); &#125;,function()&#123; console.log(&quot;鼠标离开!&quot;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 11.toggle复合事件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;点击按钮&lt;/button&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;!--&lt;script src=&quot;../js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;--&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //toggle() 1.9- : 模拟鼠标连续点击 ,1.9+切换显示隐藏的功能 // $(&quot;button&quot;).toggle(function()&#123; // $(&quot;.box&quot;).css(&quot;background&quot;,&quot;pink&quot;); // &#125;,function()&#123; // $(&quot;.box&quot;).css(&quot;background&quot;,&quot;green&quot;); // &#125;,function()&#123; // $(&quot;.box&quot;).css(&quot;background&quot;,&quot;purple&quot;); // &#125;,function()&#123; // $(&quot;.box&quot;).css(&quot;background&quot;,&quot;orange&quot;); // &#125;,function()&#123; // $(&quot;.box&quot;).css(&quot;background&quot;,&quot;cyan&quot;); // &#125;) $(&quot;button&quot;).click(function()&#123; $(&quot;.box&quot;).toggle(400); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12.trigger模拟事件123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;点击按钮&lt;/button&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //trigger () 模拟事件 , 会产生默认事件 及冒泡行为. / triggerHandler 不产生默认行为,及冒泡 // $(window).keydown(function()&#123; // console.log(123); // //模拟点击button // $(&quot;button&quot;).trigger(&quot;click&quot;); // &#125;) // // $(&quot;button&quot;).click(function()&#123; // $(&quot;.box&quot;).toggle(400); // console.log(&quot;按钮的单击事件&quot;) // &#125;) //自定义事件 , 使用on 绑定一个自定义事件 让事件更具有语义化,一看事件就知道业务操作的目的 $(&quot;.box&quot;).on(&quot;login&quot;,function()&#123; alert(&quot;触发了box的hello事件!&quot;); &#125;) $(window).keydown(function()&#123; $(&quot;.box&quot;).trigger(&quot;login&quot;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 13.trigger模拟a单击12345678910111213141516171819202122232425262728293031323334353637&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body onclick=&quot;alert(&#x27;ssssss&#x27;);&quot;&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;单击百度&lt;/a&gt;&lt;form action=&quot;http://www.baidu.com&quot; &gt;&lt;/form&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //trigger () 模拟事件 , 会产生默认事件 及冒泡行为. / triggerHandler 不产生默认行为,及冒泡 $(window).keydown(function()&#123; console.log(123); //模拟点击button $(&quot;a&quot;).triggerHandler(&quot;click&quot;); // a 标签的默认行为会被阻止 // $(&quot;form&quot;).triggerHandler(&quot;submit&quot;); &#125;) // $(&quot;a&quot;).click(function()&#123; // alert(&#x27;a被单击了!&#x27;); // &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 14.css操作方法-width与height1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; height: 200px; width: 200px; border: 10px solid #ccc; background-color: green; padding: 50px; margin: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //width() / height() 可以用于获取 或者设置元素的宽/高属性 (获取元素内容的宽度 ,不包括内外边距 ,边框等) // var w = $(&quot;.box&quot;).width(); //获取宽度 = 内容 //innerWidth() / innerHeight() // var w = $(&quot;.box&quot;).innerWidth(); //获取宽度 = 内容 + 左右内边距 //outerWidth() / outerHeight() // var w = $(&quot;.box&quot;).outerWidth();//获取宽度 = 内容 + 左右内边距 + 左右边框 //outerWidth(true) / outerHeight(true) var w = $(&quot;.box&quot;).outerWidth(true); // 获取宽度 = 内容 + 左右内边距 + 左右边框 + 左右外边距 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 15.css操作方法-offset12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .container&#123; position: absolute; top: 2000px; left: 0px; width: 1000px; &#125; .box&#123; width: 200px; height: 200px; background: red; margin: 100px auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //offset() 返回元素的偏移距离(对象= left / top 值) //相对于页面的顶部和左边 为参照的偏移距离 console.log($(&quot;.box&quot;).offset().top); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 16.scrollLeft与scrollTop123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 400px; height: 300px; margin: 50px auto; border: 1px solid red; overflow: auto; &#125; .container .box&#123; width: 3000px; height: 3000px; background: linear-gradient(90deg,red,green); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //scrollLeft() 获取或者 设置 水平方向的滚动距离 console.log($(&quot;.container&quot;).scrollLeft()); //scrollTop() 获取或者设置垂直方向的滚动距离 $(&quot;.container&quot;).scrollTop()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 17.返回顶部12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .toTop&#123; position: fixed; right: 10px; bottom: 100px; width: 40px; height: 40px; background: red; color: #fff; text-align: center; border: 2px solid #fff; cursor: pointer; &#125; .box&#123; width: 100%; height: 6000px; background: linear-gradient(0deg,red,green); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;toTop&quot;&gt;返回顶部&lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(window).scroll(function()&#123; console.log($(this).scrollTop()); &#125;) $(&quot;.toTop&quot;).click(function()&#123; // $(window).scrollTop(0); $(&quot;html,body&quot;).animate(&#123; scrollTop:0 &#125;,1500); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 18.系统函数数据类转换12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var str = &#x27;12.54sdsada&#x27;; //无论什么类型转换 ,被转换的字符串 必须是数字开头 // console.log(parseInt(str)); // =&gt; 12 console.log(parseFloat(str)); // = &gt; 12.54 console.log(isNaN(str));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第五章：遍历1.遍历后代元素1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div&gt;这是一个div&lt;/div&gt; &lt;div&gt; &lt;p&gt;这是div中的p&lt;/p&gt; &lt;/div&gt; &lt;p&gt;教育改变生活!!&lt;/p&gt; &lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //遍历后代元素: 通过元素关系,找出对应元素后代元素/ 直接子元素 //1.children() 返回匹配元素的直接子元素 // console.log($(&quot;#box&quot;).children()); // console.log($(&quot;#box&quot;).children(&#x27;p&#x27;)); //查找到子元素中的p元素 //2.find(selector) 返回匹配元素的所有selector选择器匹配的后代元素 console.log($(&quot;#box&quot;).find(&quot;p&quot;)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.遍历同辈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;这是列表项1&lt;/li&gt; &lt;li&gt;这是列表项2&lt;/li&gt; &lt;li id=&quot;li3&quot;&gt;这是列表项3&lt;/li&gt; &lt;li class=&quot;box&quot;&gt;这是列表项4&lt;/li&gt; &lt;li&gt;这是列表项5&lt;/li&gt; &lt;li&gt;这是列表项6&lt;/li&gt; &lt;li&gt;这是列表项7&lt;/li&gt; &lt;li&gt;这是列表项8&lt;/li&gt; &lt;li&gt;这是列表项9&lt;/li&gt; &lt;li&gt;这是列表项10&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;哈哈哈哈哈哈哈啊哈啊哈1&lt;/li&gt; &lt;li&gt;哈哈哈哈哈哈哈啊哈啊哈2&lt;/li&gt; &lt;li&gt;哈哈哈哈哈哈哈啊哈啊哈3&lt;/li&gt; &lt;li&gt;哈哈哈哈哈哈哈啊哈啊哈4&lt;/li&gt; &lt;li&gt;哈哈哈哈哈哈哈啊哈啊哈5&lt;/li&gt; &lt;li&gt;哈哈哈哈哈哈哈啊哈啊哈6&lt;/li&gt; &lt;li&gt;哈哈哈哈哈哈哈啊哈啊哈7&lt;/li&gt; &lt;li&gt;哈哈哈哈哈哈哈啊哈啊哈8&lt;/li&gt; &lt;li&gt;哈哈哈哈哈哈哈啊哈啊哈9&lt;/li&gt; &lt;li&gt;哈哈哈哈哈哈哈啊哈啊哈10&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;../js/jquery-v1.12.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //遍历同辈元素 : 遍历与匹配元素所属同一父级层中的所有兄弟元素 //1.siblings() 遍历当前所选元素的所有兄弟元素 ,除自身以外 // $(&quot;#li3&quot;).siblings().css(&quot;color&quot;,&quot;red&quot;); //2.next() 遍历当前元素的下一个同辈元素 // $(&quot;#li3&quot;).next(&#x27;.box&#x27;).css(&quot;color&quot;,&quot;red&quot;); //3.nextAll() 遍历当前元素后面所有兄弟元素 // $(&quot;#li3&quot;).nextAll().css(&quot;color&quot;,&quot;red&quot;); //4.prev() 遍历当前元素的上一个兄弟元素 // $(&quot;#li3&quot;).prev().css(&quot;color&quot;,&quot;red&quot;); //5.prevAll() 遍历当前元素前边所有兄弟元素 $(&quot;#li3&quot;).prevAll().css(&quot;color&quot;,&quot;red&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.遍历前辈元素12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;box2&quot;&gt; &lt;p&gt;哈哈哈哈哈啊啊啊啊哈啊&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../js/jquery-v1.12.0.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //遍历前辈元素 : 遍历当前元素的父级 与 组先级元素 //1.parent() 返回当前元素的直接父元素 // console.log($(&quot;p&quot;).parent()) ; //2.parents() 返回当前元素的所有的祖先级元素 , 一直遍历到网页的文档根部(html) // console.log($(&quot;p&quot;).parents()) ; console.log($(&quot;p&quot;).parents(&quot;#box&quot;)) ; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.过滤函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li class=&quot;on&quot;&gt;这是列表项内容1&lt;/li&gt; &lt;li&gt;这是列表项内容2&lt;/li&gt; &lt;li&gt;这是列表项内容3&lt;/li&gt; &lt;li&gt;这是列表项内容4&lt;/li&gt; &lt;li&gt;这是列表项内容5&lt;/li&gt; &lt;li&gt;这是列表项内容6&lt;/li&gt; &lt;li&gt;这是列表项内容7&lt;/li&gt; &lt;li&gt;这是列表项内容8&lt;/li&gt; &lt;li&gt; &lt;span&gt; 这是列表项内容9&lt;/span&gt; &lt;/li&gt; &lt;li&gt;这是列表项内容10&lt;/li&gt; &lt;/ul&gt; &lt;script src=&quot;../js/jquery-v1.12.0.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //过滤函数 与 过滤选择器相似, 目的都是用于筛选过滤匹配元素 //1.first() 从匹配元素中 过滤出第一个匹配元素 // $(&quot;li&quot;).first().css(&quot;color&quot;,&quot;red&quot;); //2.last() 从匹配元素中 过滤出最后一个匹配元素 // $(&quot;li&quot;).last().css(&quot;color&quot;,&quot;red&quot;); //3.eq(index)从匹配元素中 过滤出索引值为index的匹配元素 // $(&quot;li&quot;).eq(5).css(&quot;color&quot;,&quot;red&quot;); //4.hasClass() 检测元素是否具有某个类名的方法, 如果有返回 true, 没有返回false // console.log($(&quot;li&quot;).eq(0).hasClass(&quot;on&quot;)); //5.filter(expr) 从匹配元素中 ,过滤指定表达式的元 // console.log($(&quot;li&quot;).filter(&quot;.on&quot;)) //6.is(expr) 用于检测判断是否是表达式匹配元素 // console.log($(&quot;li&quot;).eq(0).is(&quot;.on&quot;)) //7.map(fn) 用法与数组中的map 一样 ,但此处遍历的是jQ元素 // var a = $(&quot;li&quot;).map(function (index,item) &#123; // // console.log(item.innerHTML); // return item.innerHTML; // &#125;) //8.has() 保留包含特定后代的元素，去掉那些不含有指定后代的元素。 // console.log($(&quot;li&quot;).has(&quot;span&quot;)); //9.not() 删除与表达式匹配的元素 // console.log($(&quot;li&quot;).not(&quot;.on&quot;)); //10.slice(start,end) console.log($(&quot;li&quot;).slice(0,4)) //has* . is* = &gt; 用于进行检测 或者判断 ,返回布尔值 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.串联12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box&#123; width: 400px; height: 400px; /*border: 1px solid red;*/ margin: 50px auto; padding: 50px; &#125; #box div&#123; /*border: 1px solid #ccc;*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div&gt;教育改变生活!&lt;/div&gt; &lt;div&gt;教育改变生活!&lt;/div&gt; &lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // $(&quot;#box&quot;).css(&quot;background&quot;,&quot;red&quot;); // $(&quot;#box div&quot;).css(&quot;background&quot;,&quot;green&quot;); // $(&quot;#box&quot;).css(&quot;border&quot;,&quot;10px solid red&quot;); // $(&quot;#box div&quot;).css(&quot;border&quot;,&quot;10px solid red&quot;); //1.串联 andSelf() 把先后匹配的元素整合一起 // $(&quot;#box&quot;).children().andSelf().css(&quot;border&quot;,&quot;10px solid red&quot;); //2.end() 返回前面已经匹配过元素的上一层匹配元素 $(&quot;#box&quot;).children().eq(0).next().css(&quot;border&quot;,&quot;10px solid red&quot;).end().css(&quot;border&quot;,&quot;10px solid green&quot;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第六章：jQuery中的DOM操作1.DOM操作分类：（DOM操作获取的DOM元素集合是伪数组不具有数组的方法）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; /* DOM操作的分类: 1.增 (8个) 内部操作 前(开头) prepend() prependTo() 后(末尾) append() appendTo() 外部操作 前(前边) before() insertBefore() 后(后边) after() insertAfter() 2.删(2个) remove() empty() 3.改 (5 / 6 / 7 / 8 / 9 ) 4.查 (获取匹配元素) 5.克隆 (1个) clone() clone(true) 6.替换 (2个) replaceWith() replaceAll() 7.包裹 - (在一些封装插件中用的比较常见) (3个) wrap() wrapAll() wrapInner() 8.属性操作 (2个) attr() removeAttr() 9.类操作(3个) addClass() removeClass() toggleClass() 10.内容 与 值的操作(3个) html() ==&gt; innerHTML text() ==&gt; innerText val() ==&gt; 表单的value属性 */&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.创建节点1234567891011121314151617181920212223242526&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //原生 var span = document.createElement(&quot;span&quot;); span.innerHTML = &#x27;哈哈哈啊啊哈&#x27;; span.className = &#x27;box&#x27;; //jQuery // var li = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;); // var li = $(&quot;&lt;li&gt;哈哈哈哈哈哈&lt;/li&gt;&quot;); var li = $(&quot;&lt;li class=&#x27;box&#x27;&gt;哈哈哈哈哈哈&lt;/li&gt;&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.增加元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 500px; border:1px solid red; margin: 50px auto; &#125; .box&#123; width: 100px; height: 100px; background: red; &#125; .sheep&#123; height: 100px; width: 200px; background: green; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--前边 : before--&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--开头--&gt; &lt;hr&gt; &lt;!--末尾处--&gt; &lt;div class=&quot;sheep&quot;&gt;羊羊羊&lt;/div&gt; &lt;/div&gt; &lt;!--后边 : after--&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var box = $(&#x27;&lt;div class=&quot;box&quot;&gt;教育改变生活!&lt;/div&gt;&#x27;);//使用jQuery创建元素节点 // ----------------------------内部操作------------------------------- //1.append() 在指定元素的末尾处追加内容 // $(&quot;.container&quot;).append(box); //2.appendTo() 将匹配内容追加到指定的元素末尾处 (类似于剪切效果) //$(&quot;.sheep&quot;).appendTo(&quot;.container&quot;); //3.prepend() 在指定元素的开头未知追加内容 // $(&quot;.container&quot;).prepend(box); //4.prependTo() 将匹配内容追加到指定的元素开头位置 (类似于剪切效果) // $(&quot;.sheep&quot;).prependTo(&quot;.container&quot;); // -------------------------------外部操作-------------------------------------------- //5.after() 在指定元素的后边追加内容 (外部) // $(&quot;.container&quot;).after(box); //6.insertAfter() 将匹配元素追加到指定元素的后边 (类似于剪切效果) // $(&quot;.sheep&quot;).insertAfter(&quot;.container&quot;); //7.before() 在指定元素的前边追加内容 (外部) // $(&quot;.container&quot;).before(box); //8.insertBefore() 将匹配元素追加到指定元素的前边 (类似于剪切效果) $(&quot;.sheep&quot;).insertBefore(&quot;.container&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.删除元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 600px; height: 300px; border: 1px solid red; margin: 50px auto; &#125; .container div&#123; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;删除&lt;/button&gt; &lt;button&gt;清空&lt;/button&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt;教育改变生活!&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt;教育改变生活!&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //remove() 方法 ,删除所有匹配元素 $(&quot;button:first&quot;).click(function()&#123; $(&quot;.container&quot;).remove(); &#125;) //empty() 方法 ,清空所有匹配元素 $(&quot;button:last&quot;).click(function()&#123; $(&quot;.container&quot;).empty(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.克隆节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 600px; height: 300px; border: 1px solid red; margin: 50px auto; &#125; .container div&#123; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;克隆clone()&lt;/button&gt;&lt;button&gt;克隆clone(true)&lt;/button&gt;&lt;div class=&quot;container&quot;&gt; &lt;div&gt;教育改变生活!&lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;.container&quot;).click(function()&#123; alert(&#x27;单击事件!&#x27;); &#125;) //clone() 方法 ,克隆匹配元素 ,得到一个新的元素 $(&quot;button:first&quot;).click(function()&#123; var node = $(&quot;.container&quot;).clone(); $(&quot;body&quot;).append(node); &#125;) //clone(true) 方法 ,克隆匹配元素 ,得到一个新的元素 $(&quot;button:last&quot;).click(function()&#123; var node = $(&quot;.container&quot;).clone(true); //true 表示连事件一起克隆过去 $(&quot;body&quot;).append(node); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.替换1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 600px; height: 300px; border: 1px solid red; margin: 50px auto; &#125; .container div&#123; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;replaceWith替换&lt;/button&gt;&lt;button&gt;replaceAll替换&lt;/button&gt;&lt;p&gt;哈哈哈啊哈啊&lt;/p&gt;&lt;p&gt;哈哈哈啊哈啊&lt;/p&gt;&lt;p&gt;哈哈哈啊哈啊&lt;/p&gt;&lt;p&gt;哈哈哈啊哈啊&lt;/p&gt;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //replaceWith() 方法 ,将匹配元素 ,使用指定的元素内容替换 $(&quot;button:first&quot;).click(function()&#123; $(&quot;p&quot;).replaceWith(&quot;&lt;h1&gt;教育改变生活!&lt;/h1&gt;&quot;); &#125;) //replaceAll() 方法 ,用指定元素(可以使用选择器) 替换掉匹配需要被替换的元素 $(&quot;button:last&quot;).click(function()&#123; // $(&quot;&lt;h1&gt;教育改变生活!&lt;/h1&gt;&quot;).replaceAll(&quot;p&quot;); $(&quot;a&quot;).replaceAll(&quot;p&quot;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.包裹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 600px; height: 300px; border: 1px solid red; margin: 50px auto; &#125; .container div&#123; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;p&gt;这是一个独立的p&lt;/p&gt;&lt;/div&gt;&lt;button&gt;wrap()&lt;/button&gt;&lt;button&gt;wrapAll()&lt;/button&gt;&lt;button&gt;wrapInner()&lt;/button&gt;&lt;p&gt;哈哈哈啊哈啊&lt;/p&gt;&lt;p&gt;哈哈哈啊哈啊&lt;/p&gt;&lt;p&gt;哈哈哈啊哈啊&lt;/p&gt;&lt;p&gt;哈哈哈啊哈啊&lt;/p&gt;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //wrap() 方法 ,将匹配元素 ,使用指定的元素包裹 $(&quot;button:first&quot;).click(function()&#123; $(&quot;p&quot;).wrap(&quot;&lt;div&gt;&lt;/div&gt;&quot;); &#125;) //wrapAll() 方法 ,将匹配元素 ,使用指定的元素包裹 (打包在匹配的第一个元素位置) $(&quot;button:eq(1)&quot;).click(function()&#123; $(&quot;p&quot;).wrapAll(&quot;&lt;div&gt;&lt;/div&gt;&quot;); &#125;) //wrapInner() 方法 ,将匹配元素 ,使用指定的元素包裹 (打包在匹配的第一个元素位置) $(&quot;button:eq(2)&quot;).click(function()&#123; $(&quot;p&quot;).wrapInner(&quot;&lt;div&gt;&lt;/div&gt;&quot;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8.属性操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 600px; height: 300px; border: 1px solid red; margin: 50px auto; &#125; .container div&#123; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;attr()&lt;/button&gt;&lt;a href=&quot;http://www.baidu.com&quot; title=&quot;这是一个标题&quot;&gt;百度&lt;/a&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //attr() 方法 ,获取或者设置匹配元素的属性 $(&quot;button:first&quot;).click(function()&#123; // alert($(&quot;a&quot;).attr(&quot;title&quot;)); //获取 // $(&quot;a&quot;).attr(&quot;name&quot;,&quot;这是个name属性&quot;);//设置单个属性 //设置多个属性 // $(&quot;a&quot;).attr(&#123; // name:&quot;阿萨德撒大所多所多&quot;, // abc:&quot;asdsdsssdssdsads&quot; // &#125;) // 删除属性 $(&quot;a&quot;).removeAttr(&quot;title&quot;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 9.类的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 600px; height: 300px; border: 1px solid red; margin: 50px auto; &#125; .container div&#123; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;类操作&lt;/button&gt;&lt;a href=&quot;http://www.baidu.com&quot; title=&quot;这是一个标题&quot; class=&quot;abc ssss hhhh&quot;&gt;百度&lt;/a&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //类的操作方法 ,获取或者设置匹配元素的class属性 $(&quot;button:first&quot;).click(function()&#123; // alert($(&quot;a&quot;).attr(&quot;class&quot;)); //addClass() 追加类 // $(&quot;a&quot;).addClass(&quot;ssss hhhhh&quot;); //removeClass() 删除类 // $(&quot;a&quot;).removeClass(&quot;abc ssss&quot;); //toggleClass() 切换类: 如果有则删除, 如果没有则添加 //$(&quot;a&quot;).toggleClass(&quot;aaaaa&quot;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第七章：特效函数1.显示与隐藏1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box&#123; width: 200px; height: 200px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;显示&lt;/button&gt; &lt;button&gt;隐藏&lt;/button&gt; &lt;button&gt;显示/隐藏&lt;/button&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //所有的特效函数 ,都可以设置一个速度(speed) , 回调函数 (callback) // show(speed,callback) / hide(speed,callback) / toggle(speed,callback) //speed : 特效执行的时间 //callback: 当特效执行完之后调用的函数 $(&quot;button:first&quot;).click(function () &#123; $(&quot;#box&quot;).show(300,function()&#123; alert(&#x27;已经完全显示!&#x27;); &#125;); &#125;) $(&quot;button:eq(1)&quot;).click(function () &#123; $(&quot;#box&quot;).hide(300,function () &#123; alert(&#x27;已经隐藏完毕!&#x27;); &#125;); &#125;) $(&quot;button:last&quot;).click(function () &#123; $(&quot;#box&quot;).toggle(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.淡入淡出12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box&#123; width: 200px; height: 200px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;显示&lt;/button&gt;&lt;button&gt;隐藏&lt;/button&gt;&lt;button&gt;显示/隐藏&lt;/button&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //所有的特效函数 ,都可以设置一个速度(speed) , 回调函数 (callback) // fadeIn(speed,callback) / fadeOut(speed,callback) / fadeToggle(speed,callback) //speed : 特效执行的时间 , 默认值:200(fast) / 400(normal) / 600(slow) //callback: 当特效执行完之后调用的函数 $(&quot;button:first&quot;).click(function () &#123; $(&quot;#box&quot;).fadeIn(2000); &#125;) $(&quot;button:eq(1)&quot;).click(function () &#123; $(&quot;#box&quot;).fadeOut(2000); &#125;) $(&quot;button:last&quot;).click(function () &#123; $(&quot;#box&quot;).fadeToggle(); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.上滑与下滑123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box&#123; width: 200px; height: 200px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;显示&lt;/button&gt;&lt;button&gt;隐藏&lt;/button&gt;&lt;button&gt;显示/隐藏&lt;/button&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../js/jquery.easing.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //所有的特效函数 ,都可以设置一个速度(speed) , 回调函数 (callback) // slideDown(speed,callback) / slideUp(speed,callback) / slideToggle(speed,callback) //speed : 特效执行的时间 , 默认值:200(fast) / 400(normal) / 600(slow) //callback: 当特效执行完之后调用的函数 $(&quot;button:first&quot;).click(function () &#123; $(&quot;#box&quot;).slideDown(600,&#x27;easeOutBounce&#x27;); &#125;) $(&quot;button:eq(1)&quot;).click(function () &#123; // $(&quot;#box&quot;).slideUp(30000); $(&quot;#box&quot;).slideUp(300); &#125;) $(&quot;button:last&quot;).click(function () &#123; $(&quot;#box&quot;).slideToggle(); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.animate自定义动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; position: absolute; left: 0; width: 100px; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;开始动画&lt;/button&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../js/jquery.easing.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* * jQuery 动画的原理 : * 通过js的dom操作 ,配合定时器 ,按一定时间间隔不断修改元素样式(样式属性值的递增/递减) ,达到动画效果 * * 注意:在jQuery中 ,只有样式属性值为数值类型的属性 ,才可以使用在动画中. * width / height / margin / padding / left / top / .... / font-size * * animate(params , speed , [easing] ,[callback]) * [必须]params : 动画下一个过程状态的css样式属性(动画效果的css样式) = &gt; 对象方式(json对象) * [必须]speed : 动画从当前状态开始, 直至改变最终状态 ,所需要花费的时间 * easing : 时间曲线(动画变化的速度) : 内置有两个 : linear(匀速) / 默认:swing(变速:慢-&gt;加速-&gt;慢) * callback : 动画执行完毕后的回调函数 (当动画已经执行完毕之后,需要做的事情) * * 可以使用官方提供的jquery.easing.js 插件扩展动画的速度:(30多个速度预设) * linear swing easeInQuad easeOutQuad easeInOutQuad easeInCubic easeOutCubic easeInOutCubic easeInQuart easeOutQuart easeInOutQuart easeInQuint easeOutQuint easeInOutQuint easeInExpo easeOutExpo easeInOutExpo easeInSine easeOutSine easeInOutSine easeInCirc easeOutCirc easeInOutCirc easeInElastic easeOutElastic easeInOutElastic easeInBack easeOutBack easeInOutBack easeInBounce easeOutBounce easeInOutBounce * * * */ // $(&quot;button&quot;).click(function()&#123; // $(&quot;.box&quot;).animate(&#123; // left:1340 // &#125;,5000,function()&#123; // $(&quot;.box&quot;).animate(&#123; // left:0, // top:600 // &#125;,5000,function()&#123; // $(&quot;.box&quot;).animate(&#123; // left:1340 // &#125;,5000) // &#125;) // &#125;) // &#125;) //简化版的队列动画 (挨个逐一执行) $(&quot;button&quot;).click(function()&#123; $(&quot;.box&quot;) .animate(&#123;left:1340&#125;,5000,&#x27;easeInBounce&#x27;).delay(0) .animate(&#123;left:0,top:600&#125;,5000,&#x27;easeInBounce&#x27;) .animate(&#123;left:1340&#125;,5000) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.stop停止动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; position: absolute; left: 0; width: 100px; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;开始动画&lt;/button&gt;&lt;button&gt;stop()&lt;/button&gt;&lt;button&gt;stop(true)&lt;/button&gt;&lt;button&gt;stop(true,true)&lt;/button&gt;&lt;button&gt;stop(false,true)&lt;/button&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../js/jquery.easing.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //停止动画 stop() //stop() :立即停止当前队列动画,进入下一队列动画 $(&quot;button:eq(1)&quot;).click(function()&#123; $(&quot;.box&quot;).stop(); &#125;) //stop(true) :立即停止所有队列动画,保留在当前位置 $(&quot;button:eq(2)&quot;).click(function()&#123; $(&quot;.box&quot;).stop(true); &#125;) //stop(true,true):立即停止所有队列动画 ,保留在当前动画的最终状态 $(&quot;button:eq(3)&quot;).click(function()&#123; $(&quot;.box&quot;).stop(true,true); &#125;) //stop(false,true) : 立即停止当前队列动画,并且从当前动画的最终状态开始 ,进入下一队列动画 $(&quot;button:eq(4)&quot;).click(function()&#123; $(&quot;.box&quot;).stop(false,true); &#125;) //简化版的队列动画 (挨个逐一执行) $(&quot;button:first&quot;).click(function()&#123; $(&quot;.box&quot;) .animate(&#123;left:1340&#125;,5000).delay(0) .animate(&#123;left:0,top:600&#125;,5000) .animate(&#123;left:1340&#125;,5000) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.二级菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; padding: 0; margin: 0; box-sizing: border-box; &#125; ul,li&#123; list-style: none; &#125; a&#123; font-size: 12px; color: #666; text-decoration: none; &#125; .container&#123; width: 502px; margin: 50px auto; &#125; .nav&#123; height: 30px; line-height: 30px; /*border: 1px solid #ccc;*/ &#125; .nav &gt; li&#123; position: relative; float: left; width: 100px; border: 1px solid #ccc; text-align: center; &#125; .nav &gt; li:hover&#123; background: #63B8FF; &#125; .nav .dropdown-menu&#123; position: absolute; width: 100%; left: 0; display: none; &#125; .nav .dropdown-menu &gt;li&#123; border: 1px solid #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;一级导航1&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航5&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;一级导航2&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航5&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;一级导航3&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航5&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;一级导航4&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航5&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;一级导航5&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;二级导航5&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;../js/jquery-v1.12.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../js/jquery.easing.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;.nav &gt; li&quot;).hover(function()&#123; $(this).find(&quot;.dropdown-menu&quot;).stop().slideDown(400,&#x27;easeOutBounce&#x27;); &#125;,function()&#123; $(this).find(&quot;.dropdown-menu&quot;).stop().slideUp(); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第八章：正则表达式正则表达式验证方法test(rel)返回布尔值1.分组12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //分组 = &gt; () 括起来的规则 = &gt; $1 表示第一组匹配到的内容 //分组功能非常强大 ,常用于一些框架模板引擎 var tel = &#x27;13800138000&#x27;; console.log(tel.replace(/^(1[3-9]\\d)\\d&#123;4&#125;(\\d&#123;4&#125;)$/,&#x27;$1****$2&#x27;)); var html = &#x27;&lt;img src=&quot;http://abc.com/a.jpg&quot;/&gt;&#x27;; //需求: 从html 中取出图片的地址 console.log(html.replace(/&lt;img\\ssrc=&quot;(.*)&quot;\\/&gt;/,&#x27;$1&#x27;));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.前瞻1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //前瞻: 根据需要匹配字符的后边内容进行匹配 var str = &#x27;hello how h3 are hi haha&#x27;; //需求: 替换掉后面紧接着数字的h str.replace(/h(?=\\d)/g,&#x27;*&#x27;); // 正前瞻 &quot;hello how *3 are hi haha&quot; //需求:替换后面不是接数字的h str.replace(/h(?!\\d)/g,&#x27;*&#x27;);// 负前瞻 &quot;*ello *ow h3 are *i *a*a&quot;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.手机号码正则123456789101112131415161718192021222324252627282930&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; /* * 手机号码特征: * 1. 以数字1开头 * 2. 第二位只能为 3 4 5 6 7 8 9 * 3. 第三位 - 第十一为 数字 * 4. 总共长度为 11 位 * * 注意: 如果需要制定长度范围的时候 ,一定要有开始和结束形成封闭的区间 * */ var telReg = /^1[3-9]\\d&#123;9&#125;$/; //正则对象中 有 验证 test() 方法 ,检测字符是否符合正则的规则,如果匹配则返回true , 否则为false var tel= &#x27;13800138000&#x27;; console.log(telReg.test(tel));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.贪婪模式12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //贪婪模式: 当正则表达式符合匹配要求时 ,匹配的模式会根据量词的限定最大值,尽可能以最多的方式进行匹配 var str = &#x27;abbabbbabbbb&#x27;; str.replace(/a+b&#123;2,5&#125;/g,&#x27;*&#x27;); // =&gt; &quot;***&quot; //非贪婪模式:一旦成功匹配不再继续尝试，这就是非贪婪模式 //进入非贪婪模式: 在量词后加上?即可。 str.replace(/a+b&#123;2,5&#125;?/g,&#x27;*&#x27;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.修饰符1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var str = &#x27;abcd4154E555F1&#x27;; console.log(str.replace(/[a-z]/i,&#x27;*&#x27;)); //i修饰符 : 不区分字母的大小写 console.log(str.replace(/[a-z]/ig,&#x27;*&#x27;)); //g修饰符 : 全局匹配, 不会再匹配一项之后停止 // 只有当目标字符串含有\\n，而且正则表达式中含有^或$的时候，/m修饰符才有作用 var reg = /^abc/m; var sss = &#x27;das\\nabcsaddsasadasd&#x27;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.正则对象123456789101112131415161718192021222324252627282930&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // Regexp 正则对象 RegExp(规则,修饰符) var reg = new RegExp(&#x27;\\d&#x27;,&#x27;g&#x27;); //构造函数方式创建 console.log(reg); //字面量方式创建正则对象 var reg2 = /\\d/g; //区别: 其实效果都一样 ,唯一区别就是 构造函数方式创建,可以使用字符创方式创建正则 // var str = &#x27;\\d&#123;1,2&#125;&#x27;; // var reg3 = new RegExp(str,&#x27;g&#x27;); // var reg4 = /str/g; //正则对象中 ,有一个lastIndex 属性 ,用于标记下一次开始匹配正则的位置(只要有匹配成功时,lastIndex值则为匹配正则字符的索引位置) // 在需要多次执行同一匹配时 需要 手动设置 reg.lastIndex = 0&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.正则匹配汉字1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //匹配注册的昵称 6 - 10 //unicode 编码 国际语言字符统一编码 // \\u4E00(19968) - \\u9FA5 (40869) // \\u 代表 unicode编码 4E00 编码库中的编码字符的索引位置 的十六进制 = &gt; 19968 var str = &#x27;s你是s我的a眼啊&#x27;; var reg = /^[\\u4E00-\\u9FA5\\w-]&#123;6,10&#125;$/gi; console.log(reg.test(str));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后ajax看《Ajax数据交互》","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://1314xulujin.github.io/tags/jQuery/"}]},{"title":"Photoshop软件使用基础","slug":"Photoshop软件使用基础","date":"2018-10-22T01:40:55.000Z","updated":"2020-06-21T13:10:21.256Z","comments":true,"path":"2018/10/22/Photoshop软件使用基础/","link":"","permalink":"https://1314xulujin.github.io/2018/10/22/Photoshop%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Photoshop软件使用基础 Photoshop是一款非常强大的图形图像处理软件. 图片格式 jpeg(.jpg) ​ 优点:图片支持高压缩(文件可以进行高比例的压缩),真色彩(图像色彩丰富,细致) ​ 缺点: 不能制作动图 , 不能制作透明图片 ​ 使用场景:没有特殊要求(背景透明,动态图片)情况下,例如: 人物照片\\风景\\新闻图片等 png ​ 优点:可以制作一些透明背景/半透明背景的图片 ,图片质量高,清晰度高 ​ 缺点:图片不支持压缩,文件相对而言比较大 ​ 使用场景: 主要使用在一些背景需要透明化的图片场景,例如 :网站logo \\ 各种小图标 gif ​ 优点:可以制作动画 ,可以制作一些全透明图片 ,支持压缩 ​ 缺点:图像的色彩有限(图像显示效果不好) ​ 使用场景: 动态图片 色彩原理:​ 光的组成: 三原色 ​ 一、RGB色彩模式: 用于电子显示屏设备(手机\\电脑\\平板\\投影仪等电子设备) ​ 红(Red): 0 - 255 ​ 绿(Green):0 - 255 ​ 蓝(Blue):0 - 255 ​ 色域: 在RGB色彩模式能表示的颜色 = 256 * 256 *256 约等于 1600万 , 2^24 ,所以也称之为 “24色” ​ 表示方式(后期网页中会使用到): 1###### RGB方式 ​ rgb(255,255,255) 白色 ​ rgb(0,0,0) 黑色 1###### 十六进制: (0-F 表示 0-15) ​ R G B 00 00 00 =&gt; #000000 黑色 ​ 255 255 255 =&gt; #ffffff 白色 ​ 255 0 0 =&gt;#ff 00 00 红色 ​ 二、CMYK:用于打印印刷 (四种打印机的墨盒色) ​ C:青色 ​ M:品红 ​ Y:黄色 ​ K:黑色 (PS)图像: 图片由像素点构成 也称之为 “位图” , 图像在放大诺干倍之后会看见像素点, 图像也会随之模糊 (AI)图形:点和线构成 ,也称之为 “矢量图” ,无限放大依然清晰 ,不失真. 分辨率 :在单位英寸中所包含的像素点的数量 : 如果只用于电子屏展示 72 / 如果需要打印 设置为 300 选区(ps的核心之一) : 选择需要执行某项操作的区域 (一般呈现为虚线) , 如果没有选中,则默认为全选.Ps快捷键:1234567891011121314151617181920212223填充前景色: alt + delete 填充背景色: ctrl + delete取消选择: ctrl + D撤销上一步: ctrl + alt + Z放大&#x2F;缩小视图: ctrl + +&#x2F;- (按住alt 键 + 滚动鼠标滚轮)自由变换: ctrl + T重复上一次并且复制 :ctrl + alt + shift + T合并图层: ctrl + E复制图层: ctrl + J反相(黑白颠倒):ctrl + I反向选择:ctrl + shift + I盖印可见图层:ctrl + shift + alt +E 画布: 画布舞台大小(白纸的大小) 图像: 只改变当前图像的大小 ,画布舞台还是不变的 动画: ​ FPS : FPS是图像领域中的定义，是指画面每秒传输帧数，通俗来讲就是指动画或视频每秒的绘制画面数。 ​ 蒙版: 用蒙版图层控制图层的显示与隐藏 : ​ 白色 = &gt; 显示 ​ 黑色 = &gt; 不显示 ​ 灰色 =&gt; 半透明 项目文件目录: ​ images (存放图片) ​ css (css样式文件) ​ js (js脚本文件) 文件目录及文件命名规范: ​ 1.文件名不能使用中文 ​ 2.不能使用特殊符号 ​ 3.一般使用字母 + 数字 \\ 或者 \\ 下划线 \\ @ ​ 4.文件名要做到见名识义(使用英文单词 \\ 中文拼音 ) 百度翻译","categories":[],"tags":[{"name":"photoshop","slug":"photoshop","permalink":"https://1314xulujin.github.io/tags/photoshop/"}]},{"title":"javascript编程基础","slug":"javascript编程基础","date":"2018-10-22T01:40:21.000Z","updated":"2020-06-21T13:10:21.270Z","comments":true,"path":"2018/10/22/javascript编程基础/","link":"","permalink":"https://1314xulujin.github.io/2018/10/22/javascript%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"JavaScript编程基础 JavaScript 诞生于1995 年。当时，它的主要目的是处理以前由服务器端语言（如Perl）负责的一些输入验证操作。在JavaScript 问世之前，必须把表单数据发送到服务器端才能确定用户是否没有填写某个必填域，是否输入了无效的值。 网景(Netscape) 最先提出的 , 早期用于解决客户端表单输入验证,随着网络发展,已经逐步延伸到互联网各个领域.(网页的各种交互 \\ 基于js语言开发的后端 \\ 物联网 \\ 移动设备…) 截止目前: JavaScript 已经成为客户端脚本的标志性语言 ,在JavaScript家族中,目前两大成员: ​ 1.浏览器端JavaScript = &gt; window (负责 DOM + BOM 等浏览器的交互) ​ 2.服务器端JavaScript = &gt; nodejs ( 负责服务器端程序 定义为一门后台语言,类似java \\ php 等 ) JavaScript组成:浏览器端JavaScript: ECMA标准语法 + DOM + BOM服务器端JavaScript: ECMA标准语法 + 各种服务端程序所需要的模块(开发服务器,操作数据库,文件系统等)ECMAScript (JavaScript的标准语法 ) : (ES5 /(存在兼容问题:ES6 / ES7 / ES8 / ES9) ) ECMA语法约定:1. 变量 ：（变量是个筐 ,啥都往里装 =&gt;存储数据的一块内存空间）1.先声明,后赋值使用var关键字来声明变量 var width; width=10;width是变量名称（会对应到计算机的某个地址），10是我想储存的东西 2.同时声明赋值var width=10; 3.不声明赋值(不建议使用,在严格模式下 会报错. )width=10; 2.数据类型1.基础类型(值类型)​ a) undefined 表示错误，不明确，未定义的变量 ​ b) null 表示是不存在的意思 null与undefined 到底有什么区别? 如果在使用var声明一个变量但是未对这个变量加以初始化时，便会返回一个值即为undefined。 但是null值只是表示空的对象指针（即null是在很多语言中存在，但是undefined只是在javascript中才有的） ​ c) boolean 布尔类型 有两个值true和false ​ d) number 数字类型 ​ f) string 字符串类型 2.对象类型(引用类型)​ a)object (使用typeof 检测时 对象 和 数组 都是 object) 对象类型 ​ b)function 函数类型 检测数据类型有哪几种方式 ?? 3.运算符1.算术运算符： + - * / %(求余) ++（自身+1） –（自身-1）。2.赋值运算符： = 、+=、-=、*=、%=。3.比较运算符（返回布尔值类型：true/false）：&gt; &lt; ==（等于） ===（全等于） &gt;= &lt;= !=(不等于) !===（不全等于）4.逻辑运算符：并且（&amp;&amp;） 或者（||） 非（!） 口诀：与或非。5.位运算符：并且(&amp;) 或者 （|）逻辑运算符和位运算符的区别 &amp;&amp;和&amp; ​ 都是用于判断逻辑运算符，用于判断两边是否成立，区别就是&amp;&amp;在一个条件失败之后，就不再进行后面所有的比较，&amp;（位运算符）即使第一项验证为false，依然执行完所有的条件判断。 ||和| ​ 都是用于判断逻辑运算符，用于判断或运算多个条件中有一个成立则表达式成立，区别就是，||只要有遇到条件成立时，就不再往后执行。|即使遇到条件成立，依然执行完所有的判断条件。 在表单验证里面就有用到：因为点击立即注册后，使用逻辑运算符，只有第一个会提示错误，所以要用到位运算符 表单验证示例代码见（E:\\课程每日记录\\8月02日\\01 QQ注册验证）； 4.注释：对代码加入一些提示，下次翻阅更能看得懂（这些提示不会影响代码的运行）单行: //：在后面加入注释内容，只能对一行代码进行注释多行: /**/：在中间加入注释内容，可为多行5.程序结构1.顺序结构 输入 0个或多个 输出 1个或多个 赋值 = 2.选择结构选择结构表示程序的处理步骤出现了分支，他需要根据某个特定的条件选择其中的一个分支执行。选择结构有单选择、双选择和多选择三种形式。 ​ ①if-else结构 ​ 单分支结构： ​ if(判断条件){ ​ } ​ 双分支结构： ​ if(判断条件){ ​ }else if(判断条件){ ​ } ​ 多分支结构： ​ if(判断条件){ ​ }else if(判断条件){ ​ }else{ ​ } ​ ②switch结构代码如下： 12345678910111213switch(判断条件)&#123; case 表达式1:/*表达式代表判断条件符合的值*/ 代码; break; case 表达式2: 代码; break； case 表达式3： 代码; break; ....... default:代码&#125; switch结构例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .box&#123; width: 350px; height: 300px; background-color: deeppink; margin: 100px auto; line-height: 300px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;!--type=&quot;search&quot; type=&quot;text&quot; 均可以输入,但是search更加友好，有一个删除按钮，用户可以点击这个按钮进行删除 --&gt; 请输入您的分数：&lt;input id=&#x27;score&#x27; type=&quot;search&quot; placeholder=&quot;1--100分&quot;&gt; &lt;/div&gt;&lt;script&gt; /* * 按照学生的分数划分等级： * &lt;60 等级：F * 60-70 D * 70-80 C * 80-90 B * 90-100 A * */ /* * 1.获取input结点 通过id名字去获取元素 * document.getElementById(&quot;id名字&quot;) * 2.用户的输入值 表单元素的值 对象.value * 事件函数： 鼠标事件， 单击 双击 * 键盘事件，按得那个键 * 表单 元素 聚焦 onfocus 离焦onblur * 3.判断值到底是属于哪一个等级 * */ var stuInput=document.getElementById(&#x27;score&#x27;); /*获取input控件里用户输入的值*/ /*离焦事件如果用户在文本框离焦了，就执行&#123;&#125;里面的内容 通过离焦获取学生分数*/ stuInput.onblur=function()&#123; console.log(stuInput.value); /*把获取回来的用户输入值转换为数值*/ var score=parseInt(stuInput.value); /*Math.floor(4.5) 向下取整 4 * Math.round(4.5) 向上取整 5 * */ switch(Math.floor(score/10))&#123; case 10: alert(&#x27;满分 A&#x27;); break; case 9: alert(&#x27;A&#x27;); break; case 8: alert(&#x27;B&#x27;); break; case 7: alert(&#x27;C&#x27;); break; case 6: alert(&#x27;D&#x27;); break; default :alert(&#x27;不及格&#x27;) &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ③三目运算 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /*if(true)&#123; alert(123); &#125;*/ /*if(true)alert(123);*/ //三目运算符 var a = 23; /*if(a &lt; 10)&#123; a = &#x27;0&#x27; + a; &#125; */ a = a&lt;10?&#x27;0&#x27;+a:a; //相当于 if else a = a&lt;10?&#x27;0&#x27;+a:a&gt;=24?&#x27;时间格式错误&#x27;:a;//if else if else alert(a); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用switch结构做成的幸运大抽奖（可记录抽奖次数，中奖次数等） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; .container&#123; position:relative; width:600px; height:500px; background:url(images/tx1.png); margin:50px auto; border:1px solid #ccc; text-align:center; &#125; .container button&#123; display:inline-block; margin:230px 10px; width:120px; height:40px; background:#ff3c3c; color:#fff; border:none; cursor:pointer; &#125; .container button:hover&#123; background-color:#900; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;button onclick=&quot;lucky(1,0)&quot;&gt;开始抽奖(单次)&lt;/button&gt; &lt;button onclick=&quot;lucky(10,1)&quot;&gt;开始抽奖(10次)&lt;/button&gt; &lt;button onclick=&quot;lucky(100,2)&quot;&gt;开始抽奖(100次)&lt;/button&gt; &lt;/div&gt; &lt;script&gt; /** 需求分析: 1.单击抽奖按钮 ,触发抽奖机制 2.通过生成的随机数,来判断中奖情况 1)怎么生成随机数 =&gt; Math.random(); 2)随机数取值 =&gt; 对生成的0-1之间的小数 处理后 ,取整数进行判断 3)怎么判断中奖情况:8 =&gt; 一等奖 , 2 / 6 = &gt;二等奖 ,3 / 5 / 7 =&gt;三等奖 作业:实现统计中奖情况: 一等奖次数 二等奖次数 三等奖次数 中奖次数 综合中奖概率 */ var list = [[0,0,0,0],[0,0,0,0],[0,0,0,0]];//一个用于存储,抽奖次数,中奖次数的数组,0位置记录抽奖次数,1 , 2,3位置分别记录中123等奖次数 //定义一个抽奖函数 function lucky(number,index)&#123;//number 指定的抽奖次数 //使用循环 ,执行重复操作 for(var i=0;i&lt;number;i++)&#123; list[index][0]++;//记录一下抽奖次数 var num = parseInt(Math.random()*10); var txt = &quot;&quot;;//中奖提示 switch(num)&#123; case 8: list[index][1]++; txt = &quot;恭喜您中得一等奖!&quot;; break; case 2: case 6: list[index][2]++; txt = &quot;恭喜您中得二等奖!&quot;; break; case 3: case 5: case 7: list[index][3]++; txt = &quot;恭喜您中得三等奖!&quot;; break; default : txt = &quot;谢谢参与,继续努力!&quot;; //alert(&quot;谢谢参与,继续努力!&quot;); &#125; &#125; //计算综合中奖概率 var p = ((list[index][1]+list[index][2]+list[index][3])/list[index][0] * 100).toFixed(2) + &#x27;%&#x27;; alert(txt+&quot;\\n\\n中奖情况:\\n一等奖:&quot;+list[index][1]+&quot;\\n二等奖:&quot;+list[index][2]+&quot;\\n三等奖:&quot;+list[index][3]+&quot;\\n抽奖次数:&quot;+list[index][0]+&quot;\\n综合中奖概率:&quot;+ p ); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.循环结构三要素：循环变量初始部分循环控制条件（出口） –&gt;数组下标越界的判断 条件迭代i++ i–） ①for循环 for( 初始部分1;控制条件2 ;条件迭代)&#123; 循环执行的语句 } 执行过程是： 1,–》2 –》4 –》3 –》2–》4–》3–》2–》4…… ​ 示例代码 12345678910111213141516171819202122232425&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;title&gt;无标题文档&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;script&gt; &#x2F;&#x2F;for() 循环 &#x2F;* for(1.初始部分;2.循环条件;4.迭代条件)&#123; &#x2F;&#x2F;3.每次循环需要执行的代码 &#125; *&#x2F; for(var i&#x3D;0;i&lt;100;i++)&#123; document.write(&quot;1教育改变生活!&lt;br&#x2F;&gt;&quot;); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; ②while循环 ​ var i=0;初始部分​ while(循环条件){​ 循环条件满足下每一次的循环​ i++;条件迭代​ } ​ 示例代码 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //需求 :在网页中, 输出100 行内容 //使用while 循环 解决重复操作 : 1.循环条件(输出次数&lt;100) 2.循环操作 (输出每一次内容) /* while(循环条件)&#123; //循环条件满足下 ,执行的每一次操作 &#125; **/ //1.初始值(计数) var i = 0; while(i&lt;100)&#123;//2.循环条件 //3.每一次的循环操作 document.write(&quot;1教育改变生活!&lt;br/&gt;&quot;); i++;//4.迭代条件 &#125; //在循环条件不明确的时候 ,使用while 循环比较多 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ③do…while循环：无论条件成立，至少都会循环一次 示例代码 1234567891011121314151617181920&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //do ... while 循环 //无论条件十分成立 ,至少会执行一次. var i = 11; do&#123; console.log(123); i++; &#125;while(i&lt;10) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ④for in循环：遍历数组 示例代码 12345678910111213141516171819202122232425&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [&#x27;orange&#x27;,&#x27;apple&#x27;,&#x27;banana&#x27;,&#x27;peach&#x27;]; /*for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]); &#125;*/ //for in 遍历数组 for(index in arr)&#123; console.log(index,arr[index]); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 嵌套循环（多重循环）123456789101112131415161718&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; for(var i=0;i&lt;10;i++)&#123; for(var j=0;j&lt;5;j++)&#123; console.log(&#x27;这是几次输出!&#x27;); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用循环结构做乘法口诀表案例（双重循环）12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt;.box span&#123; display:inline-block; width:100px; height:30px; border:1px solid #ccc; line-height:30px; text-indent:10px; font-weight:bold; &#125;.box span.even&#123; background:#f9f9f9; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;script&gt; for(var i=1;i&lt;=9;i++)&#123; for(var j=1;j&lt;=i;j++)&#123; document.write( &#x27;&lt;span class=&quot;&#x27;+(i%2==0?&quot;even&quot;:&quot;odd&quot;)+&#x27;&quot; style=&quot;color:&#x27;+creatRGBColor()+&#x27;;&quot;&gt;&#x27;+ i +&#x27; X &#x27;+ j + &#x27; = &#x27; + i*j + &#x27;&lt;/span&gt;&#x27; ); &#125; document.write(&#x27;&lt;br/&gt;&#x27;); &#125; //回顾: 颜色表示方式: 1.关键字 2.十六进制 3.rgb rgb(255,255,255); function creatRGBColor()&#123; var R = parseInt(Math.random()*256); var G = parseInt(Math.random()*256); var B = parseInt(Math.random()*256); return &#x27;rgb(&#x27;+R+&#x27;,&#x27;+G+&#x27;,&#x27;+B+&#x27;)&#x27;; &#125; &lt;/script&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; for 循环的怪异行为案例一1234567891011121314151617181920212223242526&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [1,2,3,4,5,6]; for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]); &#125; //建议使用以下方式:第一种方式,每次循环都需要去获取一次数组长度,进行不必要的数组操作,浪费性能 ,把数组长度值,通过len缓存起来,这样就避免了频繁的获取数组长度 ,提高性能 for(var i=0,len=arr.length;i&lt;len;i++)&#123; console.log(arr[i]); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; for循环的怪异行为案例二12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [1,2,3,4,5,6]; //1.以下情况,两个判断循环条件,则以第二个为主 /*for(var i=0,j=0;i&lt;6,j&lt;4;i++,j++)&#123; console.log(arr[i]); &#125;*/ //2.以下情况,两个表达式1&amp;表达式2 ,谁先不满足条件,就以谁为主 结束循环 /*for(var i=0,j=0;i&lt;8&amp;j&lt;6;i++,j++)&#123; console.log(arr[i]); &#125;*/ //3.以下情况,两个表达式1|表达式2,谁最后不满足条件,就以谁为主,结束循环 for(var i=0,j=0;i&lt;8|j&lt;6;i++,j++)&#123; console.log(arr[i]); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.数组1.定义数组:1.先声明 ,后赋值12var arr = new Array(5); arr[0] = 20; 2.直接声明赋值1var arr &#x3D; new Array(10,20,30); 3.变量命名规范​ ①不能使用特殊字符，只允许使用字母，数字，下划线，$。​ ②不能以数字开头，可以使用字母，下划线，$开头。​ ③不能使用关键字，保留字作为变量名。 break case catch continue default delete do else finally for function if in instanceof new return switch this throw try typeof var void while with ​ ④建议使用驼峰命名法，命名（多个单词组合，从第一个单词开始每个单词首字母大写）。​ 例：var studentName=’张三’;​ ⑤起名要做到见名识义（如果不规范好，只要代码稍微多一点，就会搞混淆）。 4.字面量方式创建1var arr &#x3D; [10,20,30]; 数组通过下标访问 , 数组下标从0开始. 5，二维数组和多维数组123456789101112131415161718192021222324&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [1,2,3]; //一维数组 var arr2 = [[1,2,3],[4,5,6],[7,8,9]];//二维数组 var arr3 = [ [ [1,2,3] ] ]; //三维数组 alert(arr2[2][1]); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6，数组遍历的方法（ES6）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr = [1,2,3,4,5]; //forEach() 遍历数组 arr.forEach(function(item,index)&#123; //console.log(&#x27;索引值为:&#x27;,index,&#x27;元素为:&#x27;,item) &#125;); //[1,4,9,16,25] var arr2 = arr.map(function(item)&#123;// item 就是每一次遍历数组的元素 //console.log(item); return item * item; //返回元素的平方 ,return 将值返回 &#125;) //0 表示女 , 1男 = &gt; var sexs = [0,0,1,1,0,1,0,1,1,0,0,0,0,1]; /*var abc = []; for(var i=0;i&lt;sexs.length;i++)&#123; if(sexs[i]==0)&#123; abc.push(&#x27;女&#x27;); &#125;else&#123; abc.push(&#x27;男&#x27;); &#125; &#125;*/ /*var abc = []; sexs.forEach(function(item)&#123; abc.push(item?&#x27;男&#x27;:&#x27;女&#x27;); &#125;) */ var abc = sexs.map(function(item)&#123; return item?&#x27;男&#x27;:&#x27;女&#x27;; &#125;) // var socer = [59,60,65,32,49,85,26,19,98,84,76,66]; //var aa = []; /* for(var i=0;i&lt;socer.length;i++)&#123; if(socer[i]&lt;60)&#123; aa.push(socer[i]); &#125; &#125;*/ /*socer.forEach(function(item)&#123; if(item &lt; 60)&#123; aa.push(item); &#125; &#125;)*/ var aa = socer.filter(function(item)&#123; return item &lt; 60; //只要返回布尔值true , 则就将item 元素放入aa 数组 &#125;) var cc =socer.map(function(item)&#123; return item&lt;60?&#x27;不及格&#x27;:item&gt;80?&#x27;优秀&#x27;:&#x27;及格&#x27;; &#125;) //reduce() 累计 var sum = socer.reduce(function(total,item)&#123; console.log(item,total); return total +=item; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7，document.write1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; .box&#123; width:600px; height:300px; border:1px solid red; margin:50px auto; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; 选择出生年份: &lt;select&gt; &lt;script&gt; for(var y = 2019;y&gt;=1920;y--)&#123; document.write(&#x27;&lt;option&gt;&#x27;+y+&#x27;&lt;/option&gt;&#x27;); &#125; &lt;/script&gt; &lt;/select&gt; &lt;div class=&quot;box&quot;&gt; &lt;script&gt; for(var i=70;i&gt;=10;i-=10)&#123; document.write(&#x27;&lt;hr width=&quot;&#x27;+i+&#x27;%&quot;/&gt;&#x27;); &#125; &lt;/script&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 数组的属性:​ length 返回数组的长度 数组的常用方法: 罗列常用的方法 ,及使用案例….. 1，join()：将数组中的所有元素，通过一个指定的字符（默认为 ,），拼接成一个字符串。 2，concat()：将多个数组拼合成一个数组。 3，reverse()：将数组中的元素调换顺序。 4，push()：在数组的末尾追加一个或多个元素，返回数组的新的长度。 5，pop()：删除数组的最后一个元素，返回被删除的元素。 6，shift()：删除数组的开头的一个元素，返回被删除的元素。 7，unshift()：在数组的开头添加一个或者多个元素，返回数组的新的长度。 8，slice(start,end)：截取数组中的元素，start&lt;=x&lt;end，如果设置了范围则截取范围里的元素，没设置的话则全部截取。 9，splice(index,howmany,item,item…)：索引数组中的index位置的，howmany个元素，再在该数组中添加item元素，可添无数个。 10，indexOf(item,[index])：查找元素在数组中首次出现的位置，没设置开始查找位置index的话默认从第一个元素开始找，设置了的话，从index位置开始找首次出现的位置，（最后都是返回查找到的元素的位置下标），如果没找到则返回-1。 11，sort()：将数组的元素进行排序，以数组的元素编码大小排序，（一般可以在网上查找该数组的16进制编码）。 12，toString()：将数组转化成字符串。 13，includes(item,[index])：用于检测item元素是否存在于与数组，如果是，则返回true，如果不是则返回false，index为查找的开始位置。 14，forEach()：遍历数组，数组遍历方法，与循环相似。 15，filter()：过滤，筛选；以自己提出的条件对数组进行筛选，挑选出来符合条件的元素。 16，map()：地图，映射；将数据按照自己提出的一定要求，映射成另外一种格式或数据（也就是把原数组种的元素以自己设置的item元素的符合条件，替换成对应的元素。） 17，reduce()：累加，累乘，累除，累减… 18，flat(num)：扁平化处理，num是展开的次数，通俗的说就是把一个多维数组进行降维处理，比如三维到一维需要两次，即num=2。 19，fill(str,start,end)：直接将数组中的元素替换成start&lt;=x&lt;end之间的指定的str元素或者字符，没设置区间的话默认全部替换。 20，lastIndexOf(item,[index])：查找数组中的最后一次出现的item元素，index为查找位置。（最后还是返回查找的元素的位置下标） ，没找到默认为-1。 数组的方法代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //创建数组方式一 var arr=new Array(5); arr[0]=&#x27;apple&#x27; arr[1]=&#x27;banana&#x27; arr[2]=&#x27;orange&#x27; arr[3]=&#x27;peach&#x27; arr[4]=&#x27;grape&#x27;// alert(arr[3]); //创建数组方式二 var arr2=new Array(&quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;);// alert(arr2[3]); //创建数组方式三 var arr3=[&quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;,&quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;,&quot;peach&quot;,&quot;grape&quot;]; var arr4=[[1,2,3],[4,5,6],[7,8,9]] var socer=[20,25,65,56,58,50,90,100,75,60,80];// alert(arr3[3]); //数组属性length// alert(arr3.length); /*数组九种方法*/ //第一种join()// alert(arr3.join(&quot;|&quot;));/*将数组中的所有元素，通过一个指定的字符（默认为，）可以为任何东西，拼接成一个字符串。*/////// //第二种concat()// alert(arr3.concat(arr2));/*将多个数组拼合成一个数组。*/////// //第三种reverse()// alert(arr3.reverse());/*将数组中的元素顺序调换。*/////// //第四种push()// alert(arr3.push(&quot;apple&quot;, &quot;peach&quot;));/*在数组的尾端追加一个或多个元素，返回数组的新长度*/////// //第五种pop()// alert(arr3.pop());/*删除数组的最后一个元素，返回被删除的元素*///////// //第六种shift()// alert(arr3.shift());/*删除数组的第一个元素，返回被删除的元素*///////// //第七种unshift()// alert(arr3.unshift(&quot;hh&quot;,&quot;heihei&quot;));/*给数组元素的开头添加一个或者多个元素，返回元素的长度*///////// //第八种slice(start,end)start&lt;=x&lt;end// alert(arr3.slice(-5,-3));/*截取数组中的元素，在start和end之间，start自己算一个end不算，返回截取的一个或者多个元素。*///////// //第九种splice(index,howmany,item,item...) // alert(arr3.splice(2,3,&quot;hhhh&quot;));/*删除数组中的索引值为index位置的元素，个数为howmany个，然后再该位置加item元素。*/ // // // //第十种indexOf(item,index) // alert(arr3.indexOf(&quot;apple&quot;,[1]));/*元素在数组中首次出现的位置，指定从什么位置(index)开始查找item的首次出现位置，默认为0，如果返回-1，表示没有找到。 // // // //第十一种sort()对数组中的元素进行排序(以元素的编码大小进行排序),编码为16进制可转化为10进制。 // // // // //第十二种toString()将此数组转化成一个字符串(即里面的双引号都删除，只留下最外面两边的双引号)。 // // // ////下面是ES6新增的方法: //第十三种includes(item,[index]); // alert(arr3.includes(&quot;apple&quot;,5));/*用于检测item元素是否存在于数组，如果是则返回true，否则返回false，index为开始查找是否存在的位置。 // 下面四个和循环有关系 // // // //第十四种forEach() /*例：可利用forEach()来循环一个数组长度的次数，如果是用for，while，do while，for in循环的1话可能会更加麻烦*/ // var sexs=[0,1,0,0,1,0,1,0,1,1,1,1,0,0,1] // var newSexs=[]; // sexs.forEach(function(item)&#123; // newSexs.push(item?&quot;男&quot;:&quot;女&quot;) // &#125;) // document.write(newSexs); /*遍历数组的方法，和循环有点相似，不过只循环数组每个元素一遍，即数组的长度。使用产生的效果是把原数组循环一遍，以你自己设置好的条件是替换这个数组里面的元素还是删除(或者其他的方法都可以在这里面使用，和循环相似)这个数组里面的元素。*/ //第十五种filter() // var ff=socer.filter(function(item)&#123; // return item&lt;60; // &#125;) /*以自己对item设置的条件进行筛选符合条件的原数组socer中的元素放到一个新的数组ff中，例子中我做了一个筛选出不及格的人的分数放到了ff数组中。 //第十六种map()地图，映射的意思，在我们程序里面可当做把原数组socer中的元素以自己设置的item元素的符合条件，替换成对应的元素，例：*/ // var mm=socer.map(function(item)&#123; // return item&lt;60?&quot;不及格&quot;:item&gt;80?&quot;优秀&quot;:&quot;及格&quot;; // &#125;) /*return是将值返回给mm，这段的意思是，把成绩小于60分的同学定为不及格，大于80分的定为优秀，另外的也就是60到80之间的是及格，最后再把得到的元素即&quot;及格&quot;，&quot;不及格&quot;，&quot;优秀&quot;对应的替换到mm数组*/ //第十七种reduce()求累加，累减，累乘，累除等。 // var rr=socer.reduce(function(sum,item)&#123; // console.log(item,sum); // return sum+=item; // &#125;) /*可以吧加号换成*号就是累乘，-号和/号也是一样的，item是最后一项即an，sum是第一项到倒数第二项之和即Sn-1，他们两个加起来就是Sn整个数组的元素之和*/ //第十八种flat(num) // alert(arr4.flat());/*扁平化处理，num是展开的次数，例：三维一维需要num=2即两次，此方法是对一个多维数组进行降维处理*/ //第十九种fill(str,start,end) // alert(arr3.fill(1,0,5));/*此方法的作用是直接将数组的元素替换成指定的元素str（可以是字符等其他东西），start&lt;=x&lt;end,如果不加start和end截取的位置的话，默认全部替换。 //第二十种lastIndexOf(item,[index]) alert(arr3.lastIndexOf(&quot;apple&quot;,2));/*此方法与indexOf索引元素方向相反，返回item出现的最后一个位置，index为查找截止索引的位置，找不到返回-1*/ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 拓展知识子数组排序算法-冒泡排序(每一轮循环)每次把数组中的前一项与其后一项的对比,如果前一项,大于后一项,则两个人交换位置. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /** 冒泡排序算法: (每一轮循环)每次把数组中的前一项与其后一项的对比,如果前一项,大于后一项,则两个人交换位置. 冒泡排序的过程: 第一轮: 1.[3,5,1,4,2] 2.[3,1,5,4,2] 3.[3,1,4,5,2] 4.[3,1,4,2,5] (找出数组中的最大值) 5.[3,1,4,2,5] 第二轮: 6.[1,3,4,2,5] 7.[1,3,4,2,5] 8.[1,3,2,4,5] 9.[1,3,2,4,5] 10.[1,3,2,4,5] 第三轮: 11.[1,3,2,4,5] 12.[1,2,3,4,5] 13.[1,2,3,4,5] 14.[1,2,3,4,5] 15.[1,2,3,4,5] ... 第五轮: .... */ var arr = [5,3,1,4,2]; //var arr = [15,23,31,24,12,9,10,61,52,34]; for(var i=0;i&lt;arr.length;i++)&#123; for(var j=0;j&lt;arr.length;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; var tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; &#125; //冒泡优化方案: https://blog.csdn.net/hansionz/article/details/80822494 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 数组去重算法（去掉数组中重复的元素，一个元素只在数组中出现一次）1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //去重算法 一 : var arr = [10,2,0,10,20,5,8,9,10]; var tmp = []; for(var i=0;i&lt;arr.length;i++)&#123; if(!tmp.includes(arr[i]))&#123; tmp.push(arr[i]); &#125; &#125; //去重算法 二 : ES6新增语法解决 var tmp2 = new Set(arr); //Set() 集合 (另一种类似数组的数据,再ES6中新增的 ,集合中的数据是唯一的) arr3 = Array.from(tmp2);//将集合转换成数组 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; arguments 是一个对应于传递给函数的参数的类数组对象(伪数组对象) 7.函数:1，定义函数1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;add()&quot;&gt;点击运行函数&lt;/button&gt; &lt;script&gt; //函数:可以实现特定功能的代码块语句 , 也可以称&quot;方法 / 功能&quot; //函数分类: 系统函数 , 自定义函数 //定义函数 :1.有参函数 , 2.无参函数 //定义一个无参函数 function add()&#123; //console.log(10 + 20 ); //函数中 , 可以有函数运行的返回结果 return 10 + 20; //返回结果 &#125; var a = add(); alert(a); //add();//1.运行函数 (网页加载完 ,直接运行) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2，定义一个有参函数12345678910111213141516171819202122232425&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //定义一个有参函数 : 具有参数设定 ,让函数扩展性更强,能实现更灵活的功能(可以多次调用,分别执行不同的效果) //NaN = Not a Number 不是一个数字 function add(a,b,c)&#123;//a ,b 就是函数 add 的参数 = &gt; &quot;形参&quot; return a + b + c; &#125; var num = add(10,20);//10 , 20 就是add方法在调用时的实际参数 = &gt; &quot;实参&quot; var num2 = add(1000,15656565); alert(num2); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3，变量提升123456789101112131415161718192021222324&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; alert(a);//A.报错(1.√) B.undefined(2.√) C.没有任何反应 var a = 10; /* js怪异现象: 在第10行运行时理论上应该是报错的 ,但是并没有 ,只是弹出undefined (变量提升)运行机制: 其实在js在运行时, 首先会做一个预解析(将使用到的变量,函数创建),但是不会对其赋值 ,所以 在预解析阶段 a 并不会被赋予10 ,只有当代码运行到该位置时才会被赋值10 **/ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4，变量作用域（全局变量 局部变量）1234567891011121314151617181920212223242526&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var a = 10; //全局变量 ,可以在当前页面任何位置使用的变量 //局部变量:变量只能在该变量定义时所在代码块内部使用. function hello()&#123; var b = 20;//局部变量:在某个代码块内部定义的变量 var a = 30; //alert(a);//30 优先使用局部变量 alert(c);//undefined var c = 40; &#125; hello(); alert(a); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5，变量的怪异行为123456789101112131415161718192021&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; function ad()&#123; b = 10; //此处b没有使用var 关键字声明 ,则被视为 全局变量 &#125; ad(); alert(b); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6，生成指定范围的函数1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //1.需求: 生成指定范围的整数 50 - 100 //0-10 =&gt; Math.random() * 10 //0-50 =&gt; Math.random() * 50 //50 -100 =&gt; Math.random()*50 + 50 function randomNumber(min,max)&#123; return parseInt(Math.random()*(max - min + 1)) + min; &#125; var num = []; for(var i=0;i&lt;10;i++)&#123; num.push(randomNumber(50,100)); &#125; //2.计算偶数之和 //什么是偶数? 能够被2整除的数字就是偶数 = &gt; 对2求余 余数为0 ,表示能够被2整除 var sum = 0; for(var i=0;i&lt;num.length;i++)&#123; if(num[i]%2==0)&#123; console.log(&#x27;偶数&#x27;); sum+=num[i]; &#125;else&#123; console.log(&#x27;奇数&#x27;); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; BOM操作:(浏览器厂商提供的功能,用于操作浏览器窗口)1.window对象属性及其属性的方法一，history：返回用户的访问记录信息(历史记录) ​ 其常用方法有（需要历史记录，即访问过） ​ back()加载history对象的前一个url​ forward()加载history对象的后一个url​ go(num)加载history对象的具体的url，num为加载的前后第num个页面 ​ 其示例代码如下有三个页面，可实现跳转，也可前进后退 a页面 123456789101112131415&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是a页面&lt;/h1&gt; &lt;a href=&quot;b.html&quot;&gt;访问b页面&lt;/a&gt; &lt;button onclick=&quot;window.history.forward()&quot;&gt;前进&lt;/button&gt; &lt;button onclick=&quot;window.history.go(2)&quot;&gt;前进2&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; b页面 123456789101112131415&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这是b页面&lt;/h1&gt; &lt;a href=&quot;c.html&quot;&gt;访问c页面&lt;/a&gt; &lt;button onclick=&quot;window.history.back()&quot;&gt;后退&lt;/button&gt; &lt;button onclick=&quot;window.history.go(1)&quot;&gt;前进&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; c页面 1234567891011121314&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;title&gt;无标题文档&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;h1&gt;这是c页面&lt;&#x2F;h1&gt; &lt;button onclick&#x3D;&quot;window.history.go(-1)&quot;&gt;后退&lt;&#x2F;button&gt; &lt;button onclick&#x3D;&quot;window.history.go(-2)&quot;&gt;后退2&lt;&#x2F;button&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 二，location：返回当前访问的url信息(当前url) ​ 1.属性：​ ①host：返回当前服务器主机地址（名称）=》www.baidu.com，需要在服务器环境下使用​ alert(window.location.host); =&gt; www.baidu.com​ ②hostname：与host相同或相似。​ ③href：返回当前访问地址的完整url。​ alert(location.href); =&gt; http://www.baidu.com ​ 2.方法：​ ①reload()重新加载当前文档（刷新）。​ 点击刷新​ ②replace()用新的文档替换当前文档​ &lt;button onclick=”window.location.replace(“https://www.baidu.com&quot;)&quot;&gt;跳转到百度 1234567891011121314151617181920212223&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;window.location.reload()&quot;&gt;刷新&lt;/button&gt; &lt;button onclick=&quot;window.location.replace(&#x27;http://www.baidu.com&#x27;)&quot;&gt;跳转&lt;/button&gt; &lt;script&gt; //host : 返回当前服务器主机地址(名称) = &gt; www.baidu.com ,需要在服务器环境下使用 //alert(location.host); //hostname //alert(location.hostname); //href 返回当前访问地址的url //alert(location.href); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 三，screen：屏幕对象 = &gt; 包含屏幕的信息(尺寸 ,屏幕在分辨率(width/height) ，及可用宽高尺寸(availWidth / availHeight)) availWidth和availHeight（可用屏幕宽和可用屏幕高）innerWidth和innerHeight（返回文档显示区的宽高）outerWidth和outerHeight（包括文档显示区，工具与滚动条的宽高） 四，navgatior：对象包含有关浏览器的信息。(用于判断访问用户是用什么设备,什么浏览器访问) 会显示以下这些信息（作为了解）： appCodeName:”Mozilla” appName:”Netscape” appVersion:”5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36” cookieEnabled:true credentials:CredentialsContainer doNotTrack:null geolocation:Geolocation hardwareConcurrency:4 language:”zh-CN” languages:Array[3] maxTouchPoints:0 mediaDevices:MediaDevices mimeTypes:MimeTypeArray onLine:true permissions:Permissions platform:”Win32” plugins:PluginArray presentation:Presentation product:”Gecko” productSub:”20030107” serviceWorker:ServiceWorkerContainer userAgent:”Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36” vendor:”Google Inc.” vendorSub:”” webkitPersistentStorage:DeprecatedStorageQuota webkitTemporaryStorage:DeprecatedStorageQuota proto:Navigator 2.定时器​ ①.定时器函数的使用（setInterval和setTimeout） 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /** window对象上的定时器函数: -setInterval()=&gt; 周期性定时器 (每隔指定时间执行一次) -setTimeout() =&gt; 延时定时器 (执行一次) 定时器单位: ms 计算 1s = 1000 ms **/ /* 1.setTimeout(function()&#123; alert(&#x27;3秒钟时间到了!&#x27;); &#125;,3000);*/ function doSth()&#123; console.log(&#x27;时间到了!boom~~~~&#x27;); &#125; //2.setTimeout(doSth,3000); //3.setTimeout(&quot;doSth()&quot;,3000); setInterval(doSth,3000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ​ ②.清除定时器（clearInterval和clearTimeout） 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 注意: 如果使用的是setInterval() 设置 ,必须使用clearInterval() 清除 // setTimeout() 设置 ,必须使用clearTimeout() 清除 var time = 5; function cutdown()&#123; time--; if(time&lt;=0)&#123; //清除定时器 clearInterval(timer); &#125; console.log(time+&#x27;s&#x27;); &#125; var timer = setInterval(cutdown,1000); //返回定时器的 ID &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.Date内置对象12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //Date() 负责处理时间/日期 var date = new Date(); //创建日期对象 console.log(date); var year = date.getFullYear(); //获取四位数的年份 var month = date.getMonth(); //获取月份 0 - 11 var day = date.getDate(); //获取日期 1 - 31 var week = date.getDay();//获取星期 0 - 6 var hours = date.getHours();//获取小时 0 - 23 var minutes = date.getMinutes();//获取分 0 - 59 var seconds = date.getSeconds();//获取秒 0 - 59 var ms = date.getMilliseconds();//获取毫秒 0 - 999 //时间戳(时间的唯一标识) , 记录着从格林威治时间(GMT)1970年1月1日0时0分0秒0毫秒 累计到当前的总的毫秒数 var timestamp = date.getTime(); //alert(timestamp); //1562982204883 var date2 = new Date(1562982204883); var m = date2.getMinutes(); //alert(m); var date3 = new Date(&quot;2014-8-5&quot;); var week2 = date3.getDay(); var ts = date3.getTime(); alert(ts); // 2 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用定时器和Date制作的动态时钟案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试&lt;/title&gt; &lt;style&gt; .container&#123; width: 500px; height: 200px; margin:50px auto; border:1px solid #ccc; border-radius:10px; background:#eee; font-weight: bold; font-family:&quot;microsoft Yahei&quot;; text-align: center; &#125; #dateBox&#123; width: 500px; height:50px; font-size:25px; margin-top:30px; &#125; #timeBox&#123; font-size:60px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot; id=&quot;app&quot;&gt; &lt;div id=&quot;dateBox&quot;&gt;2018年8月8日 星期六&lt;/div&gt; &lt;div id=&quot;timeBox&quot;&gt;12:50:32&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app=document.getElementById(&quot;app&quot;); var weeks=[&#x27;星期天&#x27;,&#x27;星期一&#x27;,&#x27;星期二&#x27;,&#x27;星期三&#x27;,&#x27;星期四&#x27;,&#x27;星期五&#x27;,&#x27;星期六&#x27;] function createTime()&#123; //获取最新时间 var appTime=&#x27;&#x27;; var date=new Date(); var y=date.getFullYear(); var m=date.getMonth(); var d=date.getDate(); var w=date.getDay(); var h=date.getHours(); var i=date.getMinutes(); var s=date.getSeconds(); //输出时间 appTime+=&#x27;&lt;div id=&quot;dateBox&quot;&gt;&#x27;+y+&#x27;年&#x27;+(m+1)+&#x27;月&#x27;+d+&#x27;日&#x27;+weeks[w]+&#x27;&lt;/div&gt;&#x27;; h=h&lt;10?&#x27;0&#x27;+h:h; i=i&lt;10?&#x27;0&#x27;+i:i; s=s&lt;10?&#x27;0&#x27;+s:s; appTime+=&#x27;&lt;div id=&quot;timeBox&quot;&gt;&#x27;+h+&#x27;:&#x27;+i+&#x27;:&#x27;+s+&#x27;&lt;/div&gt;&#x27;; app.innerHTML=appTime; setTimeout(createTime,1000) &#125; createTime(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用定时器Date内置对象（相比动态时钟多用了格林威治事件即时间戳）制作的国庆倒计时案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;国庆倒计时&lt;/title&gt; &lt;style&gt; .container&#123; height: 500px; font-size: 100px; background:#ff3c3c; color:#fff; font-weight: bold; font-family: &quot;Microsoft Yahei&quot;; text-align: center; &#125; .font&#123; letter-spacing: 50px; line-height: 180px; &#125; #national&#123; line-height: 300px; letter-spacing: 25px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot; id=&quot;app&quot;&gt; &lt;div class=&quot;font&quot;&gt;距离国庆还有&lt;/div&gt; &lt;div id=&quot;national&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var national=document.getElementById(&quot;app&quot;); function createTime()&#123; var appTime=&#x27;&#x27;; //获取国庆节的时间戳（格林威治时间） var nation=new Date(&quot;2019-10-1&quot;); var nationtime=nation.getTime(); //获取当前时间戳（格林威治时间） var date=new Date(); var nowtimestamp=date.getTime(); var timestamp=nationtime-nowtimestamp; var d=parseInt(timestamp/(1000*60*60*24)); var h=parseInt(timestamp/(1000*60*60)%24); var i=parseInt(timestamp/(1000*60)%60); var s=parseInt(timestamp/1000%60); h=h&lt;10?&#x27;0&#x27;+h:h; i=i&lt;10?&#x27;0&#x27;+i:i; s=s&lt;10?&#x27;0&#x27;+s:s; appTime+=&#x27;&lt;div class=&quot;font&quot;&gt;&#x27;+&#x27;距离国庆还有&#x27;+&#x27;&lt;/div&gt;&#x27;; appTime+=&#x27;&lt;div id=&quot;national&quot;&gt;&#x27;+d+&#x27;天&#x27;+h+&#x27;时&#x27;+i+&#x27;分&#x27;+s+&#x27;秒&#x27;+&#x27;&lt;/div&gt;&#x27;; app.innerHTML=appTime; setTimeout(createTime,1000); &#125; createTime(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.Math内置对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试&lt;/title&gt; &lt;style&gt; .container&#123; width: 500px; height: 200px; margin:50px auto; border:1px solid #ccc; border-radius:10px; background:#eee; font-weight: bold; font-family:&quot;microsoft Yahei&quot;; text-align: center; &#125; #dateBox&#123; width: 500px; height:50px; font-size:25px; margin-top:30px; &#125; #timeBox&#123; font-size:60px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //Math内置对象 console.log(Math.abs(-3));//绝对值计算 console.log(Math.random()*10);//取自己设置的区间的随机数 console.log(Math.round(1.35));//四舍五入取整数 console.log(Math.pow(0.5904,0.5));//计算x的y次幂 console.log(Math.max(5,2,85,65,7,6,3));//取该数组的最大数 console.log(Math.min(5,8,9,52,63,41,98,79,2,3));//取该数组的最小数 console.log(Math.floor(100.9999));//向上取整，取最大 console.log(Math.ceil(10.1));//向下取整，取最小 //Math内置对象之三角函数 console.log(Math.sin(Math.PI/180*45));//求正弦sin45°的值 console.log(Math.cos(Math.PI/180*45));//求余弦cos45°的值 console.log(Math.tan(Math.PI/180*45));//求正切tan45°的值 console.log(Math.atan(1)*180/Math.PI);//已知正切值，求角度 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.document文档对象12345678910111213141516171819202122&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //document.write(&#x27;哈哈啊&#x27;); //referrer 需要在服务器环境下使用 , 返回当前文档的来源地址 //alert(document.referrer); //URL 返回当前文档的URL地址 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6.URL的组成部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /** https://www.baidu.com:80/abc/index.html?name=张三&amp;age=20 =&gt; URL 应用协议: 1.https:// = &gt; 协议 , 安全类型的http 协议 / web请求的协议 http:// =&gt; 协议 超文本传输协议(主要应用在web服务器进行数据传输的规范协议) 发邮件:SMTP , POP3 文件传输:FTP ,SFTP 2.www.baidu.com = &gt; 主机名(网址,域名) www(mp3/ tieba / baike) =&gt; 二级域名 baidu.com =&gt;主域名 .com =&gt;顶级域名(国际) .cn(中国) .tw(台湾) .hk(香港) .jp(日本) .us(美国) .uk(英国) ... 3.端口 (设备与外界通讯交流的出口), 用于标识服务器(设备)上对应服务 web服务,默认一般是80 ,所以浏览器中不显示 如果是https协议 就是 443端口 (在一台服务器(www.baidu.com)上,可能有web网站服务,smtp邮件服务,ftp文件服务) 4. 文件目录及文件名 =&gt; abc/index.html 5. 查询字符串(QueryString),作用:传输给服务器的数据 **/ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DOM操作(w3c DOM操作)网页文档 - &gt; document对象 查：在进行一切的DOM操作时（增/删/改/查）​ 获取网页元素/标签对象（DOM对象）的方式： 1，通过ID属性获取：document.getElementById(“id元素”); 2，通过标签名称获取：document.getElementsByTagName(“标签元素”); 3，通过元素name属性值获取：document.getElementsByName(“name元素”); 4，通过类名（class）属性获取：document.getElementsClassName(“类（class）元素”); 示例代码 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;getAttr()&quot;&gt;获取图片路径&lt;/button&gt; &lt;button onclick=&quot;setAttr()&quot;&gt;设置新图片&lt;/button&gt; &lt;button onclick=&quot;removeAttr()&quot;&gt;删除图片路径&lt;/button&gt; &lt;img id=&quot;img&quot; class=&quot;abc&quot; title=&quot;title哈啊哈哈哈&quot; alt=&quot;sadadadad&quot; hehe=&quot;哈哈啊哈哈&quot; src=&quot;images/fruit.jpg&quot;/&gt; &lt;script&gt; var img = document.getElementById(&quot;img&quot;); function getAttr()&#123; //获取DOM对象的属性 getAttribute(属性名) 可以获取任何属性 alert(img.getAttribute(&quot;src&quot;)); &#125; function setAttr()&#123; //设置DOM的属性及属性值 setAttribute(属性名,属性值) 可以设置任何属性 img.setAttribute(&quot;src&quot;,&quot;images/grape.jpg&quot;); //img.setAttribute(&#x27;ggggg&#x27;,&#x27;99999999&#x27;); &#125; function removeAttr()&#123; //删除指定的属性 removeAttribute(需要删除的属性名) img.removeAttribute(&quot;src&quot;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5，根据DOM树的节点关系查找元素： ​ 获取 html document.documentElement； ​ 获取 body document.body； ​ 获取 head document.head； ​ 获取 title document.title； ​ document.title=”我开心”；（改变html文档标题） ​ 根据元素的层级关系，查找对应的元素： ​ 注意：节点分为 1.元素 2.属性 3.文本节点（多数表现为空格，换行和文本） ​ ①父级 ​ 一个元素的父级元素只有一个，所以只有一个方法查找 ​ parentNode（父辈级）返回当前元素的父级元素节点（只会返回元素节点）； ​ ②兄弟 ​ previousSibling返回当前元素的前一个兄弟（同胞）元素（文本或元素节点）； ​ previousElementSibling返回当前元素的前一个兄弟（同胞）元素（只能是元素节点）； ​ nextSibling返回当前元素的下一个兄弟（同胞）元素（文本或元素节点）； ​ nextElementSibling返回当前元素的下一个兄弟（同胞）元素（只能是元素节点）； ​ ③子元素 ​ firstChild返回当前元素的第一个子节点（可以是文本或属性）； ​ firstElementChild返回当前的第一个子节点（只能是返回元素节点）； ​ childNodes返回当前元素的所有的子节点集合（文本，元素）； ​ children返回当前元素的所有的子元素集合（只能返回元素节点）； 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;span&gt;第一个子元素span&lt;/span&gt; &lt;p id=&quot;p1&quot;&gt;第二个子元素p&lt;/p&gt; &lt;div&gt;第三个子元素div&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // html = &gt; document.documentElement //body =&gt; document.body //head =&gt; document.head //console.log(document.head); //title = &gt; document.head.title //console.log(document.title=&#x27;我开心就好!&#x27;); var box = document.getElementById(&quot;box&quot;); /* 注意:节点分: 1.元素 2.属性 3.文本节点(多数表现为空格,换行,及文本内容) 根据元素的层级关系 查找对应的元素: 1.父辈 : parentNode 返回当前元素的父级元素节点 2.兄弟 : 1)previousSibling 返回当前元素的前面一个同胞元素 (文本 或者 元素节点) 2)previousElementSibling 返回当前元素的前一个同胞元素 3)nextSibling 返回当前元素的下一个同胞元素(文本 或者元素节点) 4)nextElementSibling 返回当前元素的下一个同胞 3.子元素 1)firstChild 返回当前元素的第一个子节点 (可能是文本节点或者元素节点) 2)firstElementChild 返回当前元素的第一个子元素 (只返回元素节点) 3)lastChild 返回最后一个子节点 4)lastElementChild 返回最后一个子元素节点 childNodes 返回当前元素的所有子节点集合(文本 / 元素) children 返回当前元素所有的子元素 nodeType 返回节点类型 : 1 元素节点 3 文本节点 9 文档 8 注释 */ //console.log(box.lastChild); var p1 = document.getElementById(&quot;p1&quot;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 增1，var a = document.createElement(“a”);创建一个新的空对象元素 2，a.href=”http://imooc.con&quot; a.innerHTML=”go to imooc”; 或 a.setAttribute(“class”,”picture”)设置关键 属性 3，再可以将此标签对象元素添加到指定的父级元素之下 ​ 获取的父级元素.appendChild(“a”) 示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; *&#123; padding:0; margin:0; &#125; div&#123; width:100px; height:100px; float:left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; for(var r = 0;r&lt;256;r++)&#123; for(var g =0;g&lt;1;g++)&#123; var div = document.createElement(&quot;div&quot;); div.style.background=&#x27;rgb(&#x27;+r+&#x27;,&#x27;+g+&#x27;,&#x27;+255+&#x27;)&#x27;; document.body.appendChild(div); &#125; &#125; /*var div = document.createElement(&quot;div&quot;); //创建在内存中 = &gt; &lt;div&gt;&lt;/div&gt; div.setAttribute(&#x27;class&#x27;,&#x27;box&#x27;); div.innerHTML = &#x27;这是新增的div&#x27;; //将新增的网页元素插入到body中 document.body.appendChild(div); 注意:只要是元素的新增或者删除之类的操作,一定是要从父节点下手 */ &lt;/script&gt; &lt;!-- body末尾处 , 结束标签之前--&gt;&lt;/body&gt;&lt;/html&gt; 删removeChild() 删除这个元素的子元素； 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; #container&#123; width:800px; height:600px; margin:50px auto; border:1px solid #ccc; &#125; .box&#123; width:200px; height:200px; font-size:30px; color:#fff; line-height:200px; background-color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;remove()&quot;&gt;删除&lt;/button&gt; &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;教育改变生活!&lt;/div&gt; &lt;/div&gt; &lt;script&gt; function remove()&#123; var box = container.firstElementChild; //删除子元素 container.removeChild(box); //container.removeChild(box); //container.innerHTML=&quot;&quot;; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改replaceChild(新元素，被替换的元素); 示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; #container&#123; width:800px; height:600px; margin:50px auto; border:1px solid #ccc; &#125; .box&#123; width:200px; height:200px; font-size:30px; color:#fff; line-height:200px; background-color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;remove()&quot;&gt;替换&lt;/button&gt; &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;教育改变生活!&lt;/div&gt; &lt;/div&gt; &lt;script&gt; function remove()&#123; var box = container.firstElementChild; //替换 var img = document.createElement(&quot;img&quot;); img.src=&quot;images/grape.jpg&quot;; //replaceChild(新元素,被替换的元素) container.replaceChild(img,box); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 修改元素样式setAttribute(“class”,”box”) box.style.color=”#fff”; box.style.cssText=”background:red;” 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; #container&#123; width:800px; height:600px; margin:50px auto; border:1px solid #ccc; &#125; .box&#123; width:200px; height:200px; &#125; .on&#123; background:red; color:#fff; font-size:24px; text-align:center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;setStyle()&quot;&gt;设置样式&lt;/button&gt; &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;教育改变生活!&lt;/div&gt; &lt;/div&gt; &lt;script&gt; //设置DOM对象的样式 (行内样式) function setStyle()&#123; var box = container.firstElementChild; /*box.style.background=&quot;red&quot;; box.style.color=&quot;#fff&quot;; box.style.fontSize=&quot;26px&quot;; box.style.lineHeight=&quot;200px&quot;;*/ //使用css方式 //box.style.cssText=&quot;background:red;color:#fff;font-size:24px;&quot; box.setAttribute(&#x27;class&#x27;,&quot;box on&quot;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DOM事件事件分类1234567891011121314151617&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;HTML DOM 允许 JavaScript 对 HTML 事件作出反应：&lt;/p&gt; &lt;h3&gt;DOM事件分类:&lt;/h3&gt; &lt;p&gt;1.鼠标事件&lt;/p&gt; &lt;p&gt;2.键盘事件&lt;/p&gt; &lt;p&gt;3.表单事件&lt;/p&gt; &lt;p&gt;4.窗口事件&lt;/p&gt; &lt;p&gt;5.其他事件&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 鼠标事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; #box&#123; width:400px; height:400px; background-color:red; margin:50px auto; border:1px solid #ccc; &#125; .box&#123; width:200px; height:200px; background-color:green; margin:100px auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var box = document.getElementById(&quot;box&quot;); //1.单击事件 - &gt; onclick = &gt;click //2.双击事件 = &gt; ondblclick box.ondblclick = function()&#123; console.log(&#x27;双击事件!&#x27;); &#125; //3.鼠标按下事件 =&gt; onmousedown box.onmousedown = function()&#123; console.log(&#x27;鼠标按下事件!&#x27;); &#125; //4.鼠标起来事件 =&gt; onmouseup box.onmouseup = function()&#123; console.log(&#x27;鼠标起来事件!&#x27;); &#125; //5.鼠标悬停事件 = &gt; onmouseover box.onmouseover = function()&#123; //console.log(&#x27;鼠标悬停事件!&#x27;); &#125; //6.鼠标移出事件 = &gt; onmouseout box.onmouseout = function()&#123; //console.log(&#x27;鼠标移出事件!&#x27;); &#125; //7.鼠标移动事件 =&gt; onmousemove box.onmousemove = function()&#123; //console.log(&#x27;鼠标移动事件!&#x27;); &#125; //8.鼠标进入事件 = &gt;onmouseenter box.onmouseenter = function()&#123; console.log(&#x27;鼠标移动enter事件!&#x27;); &#125; //9.鼠标离开事件 = &gt;onmouseleave box.onmouseleave = function()&#123; console.log(&#x27;鼠标移动leave事件!&#x27;); &#125; //mouseover \\ mouseout 与 mouseenter / mouseleave 的区别: // (事件冒泡)mouseover \\ mouseout 在其子元素上悬停和离开也会触发事件 // (事件不冒泡) mouseenter / mouseleave 在其子元素上进入离开不会触发事件 //事件冒泡现象:DOM元素触发事件的时候,会根据元素的嵌套关系,自底向上传递事件直至文档根部 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 键盘事件123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;input&quot; /&gt; &lt;script&gt; var input = document.getElementById(&quot;input&quot;); //onkeydown 键盘按下事件 input.onkeydown = function()&#123; //console.log(&#x27;键盘按下事件!&#x27;); &#125; //onkeyup 键盘按键起来事件 input.onkeyup = function()&#123; //console.log(&#x27;键盘按键起来事件!&#x27;); &#125; //onkeypress 键盘按键产生可打印字符事件 input.onkeypress = function()&#123; console.log(&#x27;这是一个字符键!&#x27;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 表单事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;#&quot; id=&quot;form&quot;&gt; 账号&lt;input id=&quot;abc&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;input type=&quot;reset&quot; /&gt; &lt;/form&gt; &lt;script&gt; var abc = document.getElementById(&quot;abc&quot;); var form = document.getElementById(&quot;form&quot;); //1.onfocus =&gt; 获得焦点事件 abc.onfocus = function()&#123; //console.log(&#x27;这是焦点事件!&#x27;); &#125; //2.onblur =&gt; 失去焦点事件 abc.onblur = function()&#123; //console.log(&#x27;这是失去焦点事件!&#x27;); &#125; //3.oninput =&gt; 输入内容事件 abc.oninput = function()&#123; //console.log(&#x27;输入内容事件!&#x27;); &#125; //4.onselect =&gt; 文本内容被选择事件 abc.onselect = function()&#123; console.log(&#x27;文本内容被选择事件!&#x27;); &#125; //5.onchange =&gt; 输入框内容改变(需要失去焦点) / 下拉列表/单选/复选框内容发生改变时触发 abc.onchange = function()&#123; console.log(&#x27;内容发生改变!&#x27;); &#125; //6.表单元素事件 - 表单提交事件 (伴随着默认的行为:页面跳转刷新) form.onsubmit = function()&#123; console.log(&#x27;表单正在提交....&#x27;); &#125; //7.表单元素事件 - 表单重置事件 form.onreset = function()&#123; console.log(&#x27;表单重置事件!&#x27;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 窗口事件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //1.onload = &gt; 网页元素内容(图片等)加载完毕 window.onload = function()&#123; console.log(&#x27;网页内容加载完毕!&#x27;); &#125; //2.onresize = &gt;窗口大小改变事件 window.onresize = function()&#123; console.log(&#x27;窗口大小正在发生改变!&#x27;); &#125; //3.onclose =&gt; 窗口关闭事件 window.onclose = function()&#123; alert(&#x27;正在关闭窗口!&#x27;); &#125; window.onblur = function()&#123; console.log(&#x27;窗口失去焦点事件&#x27;); &#125;; window.onfocus = function()&#123; console.log(&#x27;窗口获得焦点事件&#x27;); &#125;; //document 的 oncopy 事件 window.oncontextmenu = function()&#123; console.log(&#x27;正在触发右键菜单事件!&#x27;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其他事件12345678910111213141516171819&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;啊哈哈啊哈哈哈哈哈啊哈啊哈啊&lt;/p&gt; &lt;script&gt; document.oncopy = function()&#123; alert(&#x27;休想复制!!!!&#x27;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 默认右键菜单事件123456789101112131415161718192021222324&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a id=&quot;a&quot; href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;p&gt;DOM元素中,有些远些特定功能,例如超链接点击会跳转,表单点击提交会跳转页面,右键会默认出来一个菜单 等等 都属于默认事件.&lt;/p&gt; &lt;script&gt; window.oncontextmenu = function()&#123; console.log(&#x27;正在调用右键菜单!&#x27;); //阻止元素的默认行为 return false; &#125; a.onclick= function()&#123; return false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义右键菜单事件(先要禁掉右键默认菜单)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; *&#123; padding:0; margin:0; &#125; a&#123; text-decoration:none; font-size:12px; color:#666; &#125; ul,li&#123; list-style:none; &#125; #contextmenu&#123; position:absolute; min-width:140px; border:1px solid #ccc; box-shadow:0 0 3px #eee; display:none; &#125; #contextmenu li&#123; padding:0 10px; line-height:30px; border-bottom:1px dashed #ccc; &#125; #contextmenu li a&#123; display:block; &#125; #contextmenu li:hover&#123; background-color:#f1f1f1; &#125; #contextmenu li.noborder&#123; border:0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;contextmenu&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://lby.link&amp;title=%E8%BF%99%E6%98%AF%E5%88%86%E4%BA%AB%E7%9A%84%E6%BC%94%E7%A4%BA%E6%A1%88%E4%BE%8B&amp;summary=%E8%BF%99%E6%98%AF%E4%B8%80%E6%AE%B5%E6%91%98%E8%A6%81&quot;&gt;分享到QQ空间&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;分享到QQ好友&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;分享到朋友圈&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;分享到腾讯微博&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;noborder&quot;&gt;&lt;a href=&quot;#&quot;&gt;分享到新浪微博&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; //分享的链接 https://blog.csdn.net/qq_37022150/article/details/82866171 var contextmenu = document.getElementById(&quot;contextmenu&quot;); var clientW = window.innerWidth;//窗口可视区域的宽度 var clientH = window.innerHeight; //禁用系统默认的右键菜单 window.oncontextmenu = function(e)&#123; var mw = contextmenu.offsetWidth;//获取菜单元素的宽度 var mh = contextmenu.offsetHeight;//获取菜单元素的高度 var e = e || window.event; var x = e.clientX; var y = e.clientY; //console.log(x,y); contextmenu.style.display = &quot;block&quot;; var mw = contextmenu.offsetWidth;//获取菜单元素的宽度 var mh = contextmenu.offsetHeight;//获取菜单元素的高度 console.log(mw,mh); //判断菜单是否会出界 if(x &gt; clientW - mw)&#123; console.log(&#x27;菜单会出界&#x27;); x = clientW - mw; &#125; if(y &gt; clientH - mh)&#123; y = clientH - mh; &#125; contextmenu.style.left = x + &#x27;px&#x27;; contextmenu.style.top = y + &#x27;px&#x27;; return false; &#125; window.onblur = function()&#123; contextmenu.style.display = &quot;none&quot;; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件对象Event1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;title&gt;无标题文档&lt;&#x2F;title&gt;&lt;style&gt; *&#123; padding:0; margin:0; &#125; .box&#123; width:100%; height:3000px; background:linear-gradient(to bottom,red,green);&#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt; &lt;script&gt; &#x2F;&#x2F;事件对象 Event : Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。事件通常与函数结合使用，函数不会在事件发生前被执行！ &#x2F;* 事件对象 - 常用属性: altKey: 判断触发事件时 是否按住了 alt 键 ctrlKey: shiftKey: which:标记鼠标(1左 2中 3右)或键盘的按键码(ascll码) target:指向当前触发事件元素 键盘: code 键盘字符码 key 键盘字符 keyCode 键盘码 (ascll码) *&#x2F; window.onkeydown &#x3D; function(e)&#123; var e &#x3D; e || window.event; &#x2F;&#x2F;短路运算 ,用于解决低版本的IE不支持e的写法,需要使用window.event console.log(&#39;键盘按下!&#39;,e); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 事件对象Event-鼠标Event对象代表事件的状态，比如事件在其中发生的元素，键盘按键的状态（键盘事件），鼠标的位置，鼠标按钮的状态（鼠标事件）。事件通常以与函数结合使用，函数不会在事件发生前被执行。（即事件发生后函数才会被执行，即为什么window.onload在窗口加载完成后才会执行完。） 示例代码：（一个鼠标按下事件,即鼠标按下事件发生后函数才会被执行） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; *&#123; padding:0; margin:0; &#125; .box&#123; width:100%; height:3000px; background:linear-gradient(to bottom,red,green);&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; //事件对象 Event : Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。事件通常与函数结合使用，函数不会在事件发生前被执行！ /* 事件对象 - 常用属性: altKey: 判断触发事件时 是否按住了 alt 键 ctrlKey: shiftKey: which:标记鼠标(1左 2中 3右)或键盘的按键码(ascll码) target:指向当前触发事件元素 鼠标: button: 标识按下的鼠标按键: 0 左键 / 1 中键 / 2右键 clientX 触发事件时 ,鼠标相对于当前可视区域窗口坐标位置X的值 clientY 触发事件时 ,鼠标相对于当前可视区域窗口坐标位置Y的值 offsetX 触发事件时 ,鼠标相对于当前触发事件元素的坐标位置的X值 offsetY 触发事件时 ,鼠标相对于当前触发事件元素的坐标位置的Y值 pageX 触发事件时,鼠标相对于网页页面的坐标位置的X值 pageY 触发事件时,鼠标相对于网页页面的坐标位置的Y值 screenX 触发事件时,鼠标相对于屏幕的坐标位置的X值 screenY 触发事件时,鼠标相对于屏幕的坐标位置的Y值 x: 与clientX 一样 y: 与clientY 一样 */ window.onmousedown = function(e)&#123; var e = e || window.event; //短路运算 ,用于解决低版本的IE不支持e的写法,需要使用window.event console.log(&#x27;鼠标按下!&#x27;,e); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件冒泡事件冒泡即在一个元素的子元素上添加事件对象被执行时，会将子元素上的事件冒泡到其父元素甚至到其祖先级元素上。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; #box1&#123; width:800px; height:800px; background:#ccc; margin:50px auto; &#125; #box2&#123; width:600px; height:600px; background:red; &#125; #box3&#123; width:400px; height:400px; background:green; &#125; #box4&#123; width:200px; height:200px; background:blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box1&quot;&gt;box1 &lt;div id=&quot;box2&quot;&gt;box2 &lt;div id=&quot;box3&quot;&gt;box3 &lt;div id=&quot;box4&quot;&gt; box4 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //事件冒泡: 根据DOM嵌套关系将事件自底向上传递. //阻止事件冒泡 box1.onclick = function(e)&#123; alert(&quot;box1单击事件!&quot;); &#125; box2.onclick = function(e)&#123; alert(&quot;box2单击事件!&quot;); var e = e || window.event; console.log(e); e.bubbles = false; //e.stopPropagation(); //1.阻止事件冒泡 //低版本IE / chrome 也可以 e.cancelBubble = true; //2.阻止冒泡 &#125; box3.onclick = function(e)&#123; alert(&quot;box3单击事件!&quot;); e.cancelBubble = true; //2.阻止冒泡 &#125; box4.onclick = function(e)&#123; alert(&quot;box4单击事件!&quot;); e.cancelBubble = true; //2.阻止冒泡 &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件捕获事件捕获则相反，对一个元素添加事件对象时，该事件被执行时会将事件传到自己的子元素上甚至子元素的子元素… 事件捕获与事件冒泡的区别示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;div &#123; background-color: coral; border: 1px solid; padding: 50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;该实例演示了在添加事件监听时冒泡与捕获阶段的不同。&lt;/p&gt;&lt;div id=&quot;myDiv&quot;&gt; &lt;p id=&quot;myP&quot;&gt;点击该段落， 我是冒泡&lt;/p&gt;&lt;/div&gt;&lt;br&gt;&lt;div id=&quot;myDiv2&quot;&gt; &lt;p id=&quot;myP2&quot;&gt;点击该段落， 我是捕获&lt;/p&gt;&lt;/div&gt;&lt;script&gt;document.getElementById(&quot;myP&quot;).addEventListener(&quot;click&quot;, function() &#123; alert(&quot;你点击了 P 元素!&quot;);&#125;, false);document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;, function()&#123; alert(&quot;你点击了 DIV 元素!&quot;);&#125;, false);document.getElementById(&quot;myP2&quot;).addEventListener(&quot;click&quot;, function() &#123; alert(&quot;你点击了 P 元素!&quot;);&#125;, true);document.getElementById(&quot;myDiv2&quot;).addEventListener(&quot;click&quot;, function() &#123; alert(&quot;你点击了 DIV 元素!&quot;);&#125;, true);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; offset坐标1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; *&#123; padding:0; margin:0; &#125; #box&#123; width:400px; height:400px; background:red; margin:50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;/div&gt; &lt;div style=&quot;height:3000px;&quot;&gt;&lt;/div&gt; &lt;script&gt; box.onmousedown = function(e)&#123; console.log(e); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如何给多个元素绑定事件(for循环)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;list1&quot;&gt; &lt;li&gt;1这是列表项&lt;/li&gt; &lt;li&gt;2这是列表项&lt;/li&gt; &lt;li&gt;3这是列表项&lt;/li&gt; &lt;li&gt;4这是列表项&lt;/li&gt; &lt;li&gt;5这是列表项&lt;/li&gt; &lt;li&gt;6这是列表项&lt;/li&gt; &lt;li&gt;7这是列表项&lt;/li&gt; &lt;li&gt;8这是列表项&lt;/li&gt; &lt;/ul&gt; &lt;ul id=&quot;list2&quot;&gt; &lt;li&gt;1这是列表项&lt;/li&gt; &lt;li&gt;2这是列表项&lt;/li&gt; &lt;li&gt;3这是列表项&lt;/li&gt; &lt;li&gt;4这是列表项&lt;/li&gt; &lt;li&gt;5这是列表项&lt;/li&gt; &lt;li&gt;6这是列表项&lt;/li&gt; &lt;li&gt;7这是列表项&lt;/li&gt; &lt;li&gt;8这是列表项&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var list1 = document.getElementById(&quot;list1&quot;); var lis = list1.getElementsByTagName(&quot;li&quot;); //集合 for(var i=0;i&lt;lis.length;i++)&#123; lis[i].onclick = function(e)&#123; //console.log(e.target); //alert(e.target.innerText); //this = &gt; 指针 指向当前触发事件的元素 alert(this.innerText); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 添加事件监听(addEventListener)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;addBtn&quot;&gt;新增一个li&lt;/button&gt; &lt;ul id=&quot;list1&quot;&gt; &lt;li&gt;1这是列表项&lt;/li&gt; &lt;li&gt;2这是列表项&lt;/li&gt; &lt;li&gt;3这是列表项&lt;/li&gt; &lt;li&gt;4这是列表项&lt;/li&gt; &lt;li&gt;5这是列表项&lt;/li&gt; &lt;li&gt;6这是列表项&lt;/li&gt; &lt;li&gt;7这是列表项&lt;/li&gt; &lt;li&gt;8这是列表项&lt;/li&gt; &lt;/ul&gt; &lt;ul id=&quot;list2&quot;&gt; &lt;li&gt;1这是列表项&lt;/li&gt; &lt;li&gt;2这是列表项&lt;/li&gt; &lt;li&gt;3这是列表项&lt;/li&gt; &lt;li&gt;4这是列表项&lt;/li&gt; &lt;li&gt;5这是列表项&lt;/li&gt; &lt;li&gt;6这是列表项&lt;/li&gt; &lt;li&gt;7这是列表项&lt;/li&gt; &lt;li&gt;8这是列表项&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //事件捕获阶段：事件从最上一级标签开始往下查找，直到捕获到事件目标(target)。 //事件冒泡阶段：事件从事件目标(target)开始，往上冒泡直到页面的最上一级标签。 var list1 = document.getElementById(&quot;list1&quot;); //addEventListener(事件类型,处理函数,是否为冒泡捕获阶段执行) 事件监听器 list1.addEventListener(&#x27;click&#x27;,function(e)&#123; //console.log(e.target); // = &gt;每次触发事件的 li alert(e.target.innerText); //console.log(this); // = &gt; list1 &#125;); //新增li addBtn.onclick = function()&#123; var li = document.createElement(&#x27;li&#x27;); li.innerHTML = &#x27;这是后面追加的li&#x27;; list1.appendChild(li); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DOM事件流1234567891011121314&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; DOM 事件流触发过程 : 捕获阶段 - &gt; 目标阶段(当前元素) - &gt; 冒泡阶段 //DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。&lt;/body&gt;&lt;/html&gt; 移除监听事件(removeEventListener)12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; #box&#123; width:200px; height:200px; background-color:red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;绑定事件&lt;/button&gt; &lt;button onclick=&quot;unbind()&quot;&gt;移除事件&lt;/button&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; function clickEvent()&#123; alert(10); &#125; function clickEvent2()&#123; alert(100); &#125; function clickEvent3()&#123; alert(1000); &#125; box.addEventListener(&#x27;click&#x27;,clickEvent); box.addEventListener(&#x27;click&#x27;,clickEvent2); box.addEventListener(&#x27;click&#x27;,clickEvent3); //移除 function unbind()&#123; //box.removeEventListener(&#x27;click&#x27;,clickEvent3); box.removeEventListener(&#x27;click&#x27;,clickEvent3); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 低版本IE兼容的监听事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt; &lt;script&gt; /* var addEventListener = null; if(document.addEventListener)&#123; //alert(&#x27;支持!&#x27;); addEventListener = window.addEventListener; &#125;else&#123; //alert(&#x27;不支持!@&#x27;); addEventListener = window.attachEvent; &#125; */ //btn.attachEvent() /*if(window.attachEvent)&#123; //alert(&#x27;支持!&#x27;); btn.attachEvent(&#x27;onclick&#x27;,function()&#123; alert(123); &#125;) &#125;else&#123; //alert(&#x27;不支持!&#x27;); &#125;*/ function bindEvent(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handler); &#125;else&#123; var ev = &#x27;on&#x27; + type; element.attachEvent(ev,handler); &#125; &#125; function unbindEvent(element,type,handler)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,handler); &#125;else&#123; var ev = &#x27;on&#x27; + type; element.dettachEvent(ev,handler); &#125; &#125; bindEvent(btn,&#x27;click&#x27;,function()&#123; alert(123); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 捕获与冒泡的区别(捕获就是事件由祖先级到后代,冒泡就是事件由后代到祖先级)1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;&lt;style&gt;div &#123; background-color: coral; border: 1px solid; padding: 50px;&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;p&gt;该实例演示了在添加事件监听时冒泡与捕获阶段的不同。&lt;&#x2F;p&gt;&lt;div id&#x3D;&quot;myDiv&quot;&gt; &lt;p id&#x3D;&quot;myP&quot;&gt;点击该段落， 我是冒泡&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;br&gt;&lt;div id&#x3D;&quot;myDiv2&quot;&gt; &lt;p id&#x3D;&quot;myP2&quot;&gt;点击该段落， 我是捕获&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script&gt;document.getElementById(&quot;myP&quot;).addEventListener(&quot;click&quot;, function() &#123; alert(&quot;你点击了 P 元素!&quot;);&#125;, false);document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;, function()&#123; alert(&quot;你点击了 DIV 元素!&quot;);&#125;, false);document.getElementById(&quot;myP2&quot;).addEventListener(&quot;click&quot;, function() &#123; alert(&quot;你点击了 P 元素!&quot;);&#125;, true);document.getElementById(&quot;myDiv2&quot;).addEventListener(&quot;click&quot;, function() &#123; alert(&quot;你点击了 DIV 元素!&quot;);&#125;, true);&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; js动画制作原理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; #box&#123; position:absolute; left:0; width:100px; height:100px; background:red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; //动画 : 从布局样式的A状态 ,设置一个时间,改变到B状态的过程. //在js实现动画的时代 ,只能用于一些css属性值为数字类型的属性才能制作动画 var left = 0; var opacity = 0; var direction = true; var timer = setInterval(function()&#123; left+=2; if(direction)&#123; opacity+=0.01; if(opacity&gt;=1)direction=false; &#125;else&#123; opacity-=0.01; if(opacity&lt;=0)direction=true; &#125; box.style.left = left + &#x27;px&#x27;; box.style.opacity = opacity; if(left &gt;=1000)&#123; clearInterval(timer); &#125; &#125;,1000 / 60); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 案例-翻牌抽奖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; #container&#123; width:1100px; margin:50px auto; overflow:hidden; border:1px solid #f1f1f1; &#125; .box&#123; float:left; width:200px; height:300px; margin:50px auto; transition:all 0.35s; margin:10px 5px; &#125; .box.open&#123; transform:rotateY(180deg); &#125; .box div&#123; position:absolute; width:200px; height:300px; color:#fff; text-align:center; &#125; .box .front&#123; background:red; font-size:20px; line-height:300px; transform:rotateY(180deg); &#125; .box.open .front&#123; z-index:2; &#125; .box.open.on .front&#123; background-color:gold; &#125; .box .back&#123; background:#999; font-size:16px; line-height:300px; cursor:pointer; &#125; #container .box.show&#123; position:fixed; top:50%; left:50%; box-shadow:0 0 10px 2px #ccc; animation:animate 1s both; &#125; @keyframes animate &#123; 0%&#123; left:50%; top:50%; transform:translate(-50%,-50%) scale(0.3) rotateY(180deg); &#125; 100%&#123; left:50%; top:50%; transform:translate(-50%,-50%) scale(2) rotateY(180deg); &#125; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; &lt;script&gt; var container = document.getElementById(&quot;container&quot;); var goods = [&#x27;花呗还款&#x27;,&#x27;iPhone X&#x27;,&#x27;Mac Book Pro&#x27;,&#x27;清空购物车&#x27;,&#x27;100元充值卡&#x27;]; //生成一组 0 - 9 5个随机不重复的整数 var lucky = []; while(lucky.length&lt;5)&#123; var num = parseInt(Math.random() * 10); if(lucky.indexOf(num) == -1)&#123; lucky.push(num); &#125; &#125; //生成卡牌 var htmlStr = &#x27;&#x27;; for(var i=0;i&lt;10;i++)&#123; htmlStr+=&#x27;&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;front&quot;&gt;谢谢惠顾&lt;/div&gt;&lt;div class=&quot;back&quot;&gt;点击翻开抽奖&lt;/div&gt;&lt;/div&gt;&#x27;; &#125; //插入到容器 container.innerHTML = htmlStr; //获取所有的卡牌 var boxs = container.getElementsByClassName(&quot;box&quot;); //根据已经生成的一组需要中奖的卡牌,放入对应的奖品 for(var i=0;i&lt;lucky.length;i++)&#123; boxs[lucky[i]].firstElementChild.innerHTML = goods[i]; &#125; //监听点击事件 = &gt; 翻牌 container.addEventListener(&#x27;click&#x27;,function(e)&#123; var e = e || window.event; //console.log(e); var ele = e.target; if(ele.className == &#x27;back&#x27;)&#123; //只能点击背面 ,已经翻过的不能再翻 // console.log(ele); ele.parentNode.className= &quot;box open on&quot;; setTimeout(function()&#123; for(var i=0;i&lt;boxs.length;i++)&#123; if(boxs[i]!= ele.parentNode &amp;&amp; boxs[i]!=ele2)&#123; console.log(ele); boxs[i].className=&quot;box open&quot;; &#125; &#125; //克隆一个大的显示 var ele2 = ele.parentNode.cloneNode(true); ele2.className =&quot;box open on show&quot;; container.appendChild(ele2); &#125;,350) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 案例-挑战10s123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;title&gt;无标题文档&lt;&#x2F;title&gt;&lt;style&gt; .container&#123; width:600px; height:200px; padding-top:50px; border:1px solid #ccc; margin:50px auto; text-align:center; &#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;button id&#x3D;&quot;btn&quot;&gt;开始挑战&lt;&#x2F;button&gt; &lt;div id&#x3D;&quot;time&quot;&gt;10.00&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script&gt; var timeBox &#x3D; document.getElementById(&quot;time&quot;); var btn &#x3D; document.getElementById(&quot;btn&quot;); var timer,s,time&#x3D;0; var flag &#x3D; false; btn.onmousedown &#x3D; function()&#123; flag &#x3D; true; time &#x3D; 0; timer &#x3D; setInterval(function()&#123; time++; &#x2F;&#x2F;更新时间 s &#x3D; (time &#x2F; 100).toFixed(2); s &#x3D; s&lt;10?&#39;0&#39;+s:s; timeBox.innerHTML &#x3D; s; &#125;,10); &#125; document.onmouseup &#x3D; function()&#123; if(flag)&#123; clearInterval(timer); flag &#x3D; false; if(time &#x3D;&#x3D; 10 * 100)&#123; alert(&#39;挑战成功!&#39;); &#125;else&#123; alert(&#39;挑战失败!&#39;); &#125; &#125; &#125; &#x2F;*btn.onmouseout &#x3D; function()&#123; clearInterval(timer); &#125;*&#x2F; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 案例-幸运大抽奖(转转转)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; *&#123; padding:0; margin:0; &#125; #container&#123; width:600px; height:600px; margin:50px auto; border:1px solid #ccc; &#125; #container div&#123; float:left; width:170px; height:170px; background-color:#F60; margin:6px; border:8px solid transparent; box-shadow:0 0 5px 1px #ccc; &#125; #start&#123; display:block; width:100%; height:100%; border:none; background-color:#f9f9f9; font-size:30px; &#125; #container div.active&#123; border-color:red; box-shadow:0 0 10px 3px gold; background-color:#36C; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;&lt;button id=&quot;start&quot;&gt;开始抽奖&lt;/button&gt;&lt;/div&gt; &lt;div&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div&gt;8&lt;/div&gt; &lt;div&gt;9&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var container = document.getElementById(&quot;container&quot;); var divs = container.getElementsByTagName(&quot;div&quot;);//获取9宫格的div var order = [0,1,2,5,8,7,6,3];//顺序索引值 = &gt; div的索引位置 /*order = order.sort(function(a,b)&#123; return Math.random() - 0.5; &#125;)*/ var index = 0;//当前所在的位置 =&gt; 转动的索引位置 var timer,randomNum; var speed = 50; var count = 0;//记录转动的次数 start.onclick = function()&#123; count=0; index=0; speed=50; start.innerHTML = &#x27;抽奖中...&#x27;; //设定 ,抽奖的停止 必须转满 3圈 , 可以在接下来的两圈内,随机停下 randomNum = 46 + Math.floor(Math.random() * 7); console.log(randomNum); start.disabled = true; change();// &#125; function change()&#123; count++; //清除所有的样式 for(var i=0;i&lt;order.length;i++)&#123; divs[order[i]].className=&quot;&quot;; &#125; //设置当前位置的样式 divs[order[index]].className =&quot;active&quot;; index++; if(index&gt;=order.length)index=0; if(randomNum - count &lt;10)&#123; speed+=20; &#125; if(count&lt;randomNum)&#123; setTimeout(change,speed); &#125;else&#123; start.disabled = false; start.innerHTML =&#x27;开始抽奖&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 严格模式: 在ES5版本及以前JavaScript语法非常随意, 容易导致一些项目维护和拍错非常困难.使用严格模式(下一代JS) 规避一些没有必要的异常奇葩问题. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;消除代码运行的一些不安全之处，保证代码运行的安全；提高编译器效率，增加运行速度；为未来新版本的Javascript做好铺垫。 在代码块首行使用 : “use strict” ; 声明严格模式 , 也可以在函数内部首行声明 罗列 各项严格模式规则…","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://1314xulujin.github.io/tags/javascript/"}]},{"title":"HTML网页基础","slug":"HTML网页基础","date":"2018-10-22T01:39:09.000Z","updated":"2020-06-21T13:10:21.249Z","comments":true,"path":"2018/10/22/HTML网页基础/","link":"","permalink":"https://1314xulujin.github.io/2018/10/22/HTML%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"HTML网页基础 基本的网页结构网页基本结构:12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;这是网页标题&lt;&#x2F;title&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;&#x2F;&gt; &lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;这是关键字&quot;&#x2F;&gt; &lt;meta name&#x3D;&quot;decoration&quot; content&#x3D;&quot;这是一个用于web前端的开发学习的网站，欢迎！&quot;&#x2F;&gt; &lt;meta name&#x3D;&quot;author&quot; content&#x3D;&quot;作者的名字&quot;&#x2F;&gt; &lt;meta name&#x3D;&quot;generator&quot; content&#x3D;&quot;例如北大青鸟&quot;&#x2F;&gt; &lt;link href&#x3D;&quot;css文件路径&quot; rel&#x3D;&quot;stylesheet&quot;&#x2F;&gt; &lt;link rel&#x3D;&quot;shortcut icon&quot; href&#x3D;&quot;favicon.ico&quot;&#x2F;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 常见网页标签: 标签 含义 常用属性 a 超链接 href / target / title img 图片 src / alt / title / width / heiht h1-h6 标题 p 段落标签 br 换行标签 hr 分割线标签 em 字体倾斜标签 strong 字体加粗标签 i 可在大标签中加的小标签也可使字体倾斜 span 可在大标签中加的小标签 div 一般当做盒子的块级标签 ul li ol tr th table textarea 行内标签和块级标签的区别和特点：1，行内标签（内联标签）： ①元素可以在同一行显示。 ②行内元素不支持指定的宽高属性，元素的宽高由文字多少决定。 ③行内元素一般定义为网页内容元素。 2，块级标签： ①独占一行显示。 ②块级元素支持指定的宽高属性。 ③块级元素一般定义为网页的容器（就是包裹内容元素的）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; p&#123; width:200px; height:100px; background-color:red; color:#fff; text-align:center; line-height:100px; &#125; .p2&#123; cursor:text; &#125; .p3&#123; cursor:pointer; &#125; .p4&#123; cursor:wait; &#125; .p5&#123; cursor:help; &#125; .p6&#123; cursor:crosshair; &#125; .p7&#123; cursor:move; &#125; .p8&#123; cursor:url(panda.ico),auto; &#125; html&#123; cursor:url(panda.ico),auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;默认&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;文本&lt;/p&gt; &lt;p class=&quot;p3&quot;&gt;手状&lt;/p&gt; &lt;p class=&quot;p4&quot;&gt;等待&lt;/p&gt; &lt;p class=&quot;p5&quot;&gt;帮助&lt;/p&gt; &lt;p class=&quot;p6&quot;&gt;十字光标&lt;/p&gt; &lt;p class=&quot;p7&quot;&gt;可移动状态&lt;/p&gt; &lt;p class=&quot;p8&quot;&gt;这是自定义图标&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML特殊符号：123456789空格&amp;nbsp;大于号（&gt;）&gt;小于号（&lt;）&lt;版权符号（©）&amp;copy; 图片路径的两种引入路径：1&lt;img src=&quot;图片路径&quot; alt=&quot;图片没有显示的替换文本&quot; title=&quot;鼠标悬停在图片上所显示的信息&quot;/&gt; 1，相对路径：相对于当前需要引入图片的网页html文件而言图片的路径（以网页文件的地址为参照）（推荐使用相对路径）。 2，绝对路径：非常肯定的地址，引入的图片和html文件不在同一个文件夹里面。 3，拓展知识： 1&lt;embed src=&quot;视频路径&quot; controls autoplay=&quot;autoplay&quot;/&gt; 超链接：1.文本图片链接方式 1&lt;a href=&quot;链接地址&quot; target=&quot;目标窗口位置[(_self以自身窗口跳转)（_blank打开一个新的窗口跳转）]&quot;/&gt; 2，锚点链接 12&lt;a href=&quot;#register&quot;&gt;新用户&lt;/a&gt;（点击）&lt;a name=&quot;#register&quot;&gt;新用户&lt;/a&gt;（跳转目标） 3，发邮件（拓展知识） 1&lt;a href=&quot;Tencentto:1599537548@qq.com&quot;&gt;发邮件&lt;/a&gt; CSS美化网页网页三层：1，结构层：html。 2，表现层：css。 3，行为层：js。 浏览器设置字体样式的代码：123456789101112131415&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; p&#123; font-size:16px;/*字体大小为16像素*/ font-family:&quot;微软雅黑&quot;;/*字体为微软雅黑字体*/ font-weight:blod;/*(100,200,300,400,500,600，normal)*//*字体为粗体*/ color:red;/*字体颜色为红色*/ transform:scale(0.625);/*以前浏览器中最小是12px，更新之后的浏览器字体可以更小，如果在早期浏览器需要设置小于12px的字体的方法：使用css3缩放方法。此时字体大小为开始设置的16px乘以0.625等于10px。 &#125; &lt;/head&gt; &lt;body&gt; &lt;p&gt;教育改变生活！&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; css样式使用方式： 行内(内敛)样式： 123&lt;div style=&quot;width:50px;height=50px;&quot;&gt; 这是个宽高都为50像素的盒子&lt;/div&gt; 内部样式： 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&#123; width:50px; height:50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 这是一个宽高都为50像素的盒子 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 外部样式： ①链入式： 1&lt;link href=&quot;css样式地址&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt; ②导入式： 123&lt;style&gt; @import url(&quot;css样式地址&quot;);&lt;/style&gt; 链入式和导入式的区别 1，link 标签属于XHTML，@import属于css2.1。 2，使用link 链接的css文件先加载到网页当中，再进行编译显示。 3，使用@import导入式的css文件，客户端显示HTML结构，再把css文件加载到网页当中。 4，@import是属于css2.1特有的，对于不兼容css2.1的浏览器来说是无效的。 导入式加载的过程： ​ 浏览器先加载完html网页内容，然后对htnl文件逐行解析（从第一行到最后一行解析），如果在没解析完html标签结构的前提下，在过程遇到style标签，会暂时性跳过，直至解析完html网页结构后再回去处理style标签中的css样式，再解析。 伪类语法：12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; a&#123; font-size:12px; &#125; /**编写伪类的顺序: L - V - H - A **/ /* :link 表示链接未单击访问时效果*/ a:link&#123; color:green; &#125; /* :visited 鼠标单击访问过后的链接效果*/ a:visited&#123; color:#999; &#125; /* :hover 鼠标悬停至链接时的效果*/ a:hover&#123; font-size:36px; font-weight:bold; color:red; &#125; /* :active 鼠标按住不松手时的效果 */ a:active&#123; color:yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 鼠标状态设置：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; p&#123; width:200px; height:100px; background-color:red; color:#fff; text-align:center; line-height:100px; &#125; .p2&#123; cursor:text; &#125; .p3&#123; cursor:pointer; &#125; .p4&#123; cursor:wait; &#125; .p5&#123; cursor:help; &#125; .p6&#123; cursor:crosshair; &#125; .p7&#123; cursor:move; &#125; .p8&#123; cursor:url(panda.ico),auto; &#125; html&#123; cursor:url(panda.ico),auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;默认&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;文本&lt;/p&gt; &lt;p class=&quot;p3&quot;&gt;手状&lt;/p&gt; &lt;p class=&quot;p4&quot;&gt;等待&lt;/p&gt; &lt;p class=&quot;p5&quot;&gt;帮助&lt;/p&gt; &lt;p class=&quot;p6&quot;&gt;十字光标&lt;/p&gt; &lt;p class=&quot;p7&quot;&gt;可移动状态&lt;/p&gt; &lt;p class=&quot;p8&quot;&gt;这是自定义图标&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 盒子背景图片及颜色的加入：、123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;style&gt; .cart&#123; width:110px; height:35px; line-height:35px; font-size:12px; /*text-align:center;*/ text-indent:36px; /**设置边框*/ border:1px solid #ccc; /**设置背景颜色:**/ background-color:#f9f9f9; /**设置背景图像:*/ background-image:url(buy.png); /**设置背景图平铺方式:repeat(默认平铺), repeat-x 横向平铺 ,repeat-y纵向平铺 , no-repeat 不平铺**/ background-repeat:no-repeat; /**设置背景位置:1.像素值 2. 单词(top / center /right / left / bottom) 3.百分比 设置x , y 轴 位置, 如果只设置x不设置y 则默认为居中. **/ /*background-position:16px 11px;*/ /*background-position:20%;*/ /**简写:background: */ background:#f9f9f9 url(buy.png) no-repeat 20% center; &#125;&lt;/style&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;cart&quot;&gt;我的购物车&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 雪碧图的使用（一张用css sprites拼合而成的背景图）123456789101112131415161718192021&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; .vip3&#123; width:52px; height:23px; background-image:url(indexhead_sprite.png); background-position:-165px -470px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;vip3&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css基本选择器： ID - &gt; #： 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #p&#123; color:#red; width:50px; height:50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;p&quot;&gt; 这是一个宽高为50像素的红色的盒子 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CLASS -&gt; .： 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .p&#123; color:#red; width:50px; height:50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;p&quot;&gt; 这是一个宽高为50像素的红色的盒子 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 标签 -&gt; 标签名： 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&#123; color:#red; width:50px; height:50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 这是一个宽高为50像素的红色的盒子 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 优先级： ID &gt; CLASS &gt; 标签 (在同一个元素上的ID , CLASS比较)： 物以稀为贵，id绝对只有这一个，而标签选择器和类选择器会有很多。 行内 &gt; 内部&gt; 外部： 就近原则。 3.*important 最高级别： 特别列子。 高级选择器: 并集选择器： 123456789101112131415161718192021&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; /**1.并集选择器: 多个选择器之间通过逗号隔开 , 同时声明相同样式**/ .box1,.box2&#123; width:200px; height:200px; background-color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 交集选择器： 1234567891011121314151617181920212223&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; /**2.交集选择器:由两个选择器构成,取两个选择器之间的交集部分,第一选择器为标签选择器,第二为类或者ID(中间不能有空格)**/ p.p1&#123;/**匹配p标签中并且具有类名为p1的元素*/ color:red; font-size:30px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;p1&quot;&gt;这是一个p标签&lt;/p&gt; &lt;p&gt;哈哈哈哈哈哈&lt;/p&gt; &lt;hr/&gt; &lt;div class=&quot;p1&quot;&gt;这是一个div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 后代选择器： 123456789101112131415161718192021222324&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; /***3.后代选择器:两个嵌套层级关系的选择器, 嵌套的选择器在前然后空格被嵌套的选择器**/ #box p&#123; color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;p&gt;这是一个p标签&lt;/p&gt; &lt;span&gt;这是一个span标签&lt;/span&gt; &lt;div&gt; &lt;p&gt;这是一个重孙子的p&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;哈哈哈哈哈哈哈哈&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 子元素选择器： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;title&gt;无标题文档&lt;&#x2F;title&gt;&lt;style&gt; &#x2F;**4.子元素选择器:两个层级关系中,使用 &gt; 连接 ,只作用于直接子元素*&#x2F; #box&gt;p&#123; color:green; font-size:30px; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div id&#x3D;&quot;box&quot;&gt; &lt;p&gt;这是一个p标签&lt;&#x2F;p&gt; &lt;span&gt;这是一个span标签&lt;&#x2F;span&gt; &lt;div&gt; &lt;p&gt;这是一个重孙子的p&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;p&gt;哈哈哈哈哈哈哈哈&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 兄弟选择器： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; /**5:+下一个兄弟元素*/ .li3+li&#123; color:red; &#125; /**6:~ 后边所有的兄弟元素 **/ .li3~li&#123; color:green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1哈啊哈哈哈哈啊啊哈哈&lt;/li&gt; &lt;li&gt;2哈啊哈哈哈哈啊啊哈哈&lt;/li&gt; &lt;li class=&quot;li3&quot;&gt;3哈啊哈哈哈哈啊啊哈哈&lt;/li&gt; &lt;li&gt;4哈啊哈哈哈哈啊啊哈哈&lt;/li&gt; &lt;li&gt;5哈啊哈哈哈哈啊啊哈哈&lt;/li&gt; &lt;li&gt;6哈啊哈哈哈哈啊啊哈哈&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 属性选择器： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; /**属性选择器: 通过元素属性的特征进行匹配元素*/ /**1.匹配具有某个属性的元素*/ a[href]&#123; color:red; &#125; /**2.匹配具有某个属性属性值为指定值的元素*/ a[href=&quot;baidu.com&quot;]&#123; color:purple; &#125; /**3.匹配具有某个属性及属性值以指定值开头的元素**/ a[href^=&quot;http://&quot;]&#123; color:yellow; &#125; /**4.匹配具有某个属性及属性值以指定值结尾的元素**/ a[href$=&quot;.cn&quot;]&#123; color:pink; &#125; /**5.匹配具有某个属性及属性值包含指定值的元素*/ a[href*=&quot;baidu&quot;]&#123; color:cyan; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a&gt;百度&lt;/a&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度1&lt;/a&gt; &lt;a href=&quot;http://www.taobao.com&quot;&gt;百度2&lt;/a&gt; &lt;a href=&quot;baidu.com&quot;&gt;百度3&lt;/a&gt; &lt;a href=&quot;jd.com&quot;&gt;百度4&lt;/a&gt; &lt;a href=&quot;jd.cn&quot;&gt;百度5&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 前提: 非继承属性 &gt; 继承属性(除此条件外,基本可以适应以下计算规则) ID CLASS 标签 100 10 1 例子 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; #box2 .box3 .box4&#123; color:green; &#125; #box .box4 span&#123; color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;box2&quot;&gt; &lt;div class=&quot;box3&quot;&gt; &lt;p class=&quot;box4&quot;&gt; &lt;span&gt;猜猜我是什么颜色?&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 列表与表格完整表格：12345678910111213141516&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;日期&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbodt&gt; &lt;tr&gt; &lt;td&gt;大保健&lt;/td&gt; &lt;td&gt;￥1000&lt;/td&gt; &lt;/tr&gt; &lt;/tbodt&gt; &lt;tfoot&gt; &lt;/tfoot&gt;&lt;/table&gt; 跨行跨列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; table&#123; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--跨行--&gt; &lt;table border=&quot;1&quot; width=&quot;200px&quot;&gt; &lt;tr&gt; &lt;td rowspan=&quot;3&quot;&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;!--跨列--&gt; &lt;table border=&quot;1&quot; width=&quot;200px&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 表单表单的基本语法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;跳转地址&quot;&gt; &lt;p&gt; &lt;label for=&quot;username&quot;&gt;账号：&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; name=&quot;&quot; id=&quot;username&quot;/&gt;&lt;!--文本框类型（默认）--&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot;&lt;!--在输入框中未填写显示的注释--&gt; name=&quot;&quot; id=&quot;password&quot;/&gt;&lt;!--密码框类型--&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;sing&quot;&gt;唱&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;sing&quot;/&gt;&lt;!--复选框类型--&gt; &lt;label for=&quot;dance&quot;&gt;跳&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;dance&quot;/&gt;&lt;!--复选框类型--&gt; &lt;label for=&quot;rap&quot;&gt;rap&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;rap&quot;/&gt;&lt;!--复选框类型--&gt; &lt;label for=&quot;basketball&quot;&gt;篮球&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;basketball&quot;/&gt;&lt;!--复选框类型--&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;man&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;性别&quot; id=&quot;man&quot;/&gt;&lt;!--多项单选框类型--&gt; &lt;label for=&quot;woman&quot;&gt;女&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;性别&quot; id=&quot;woman&quot;/&gt;&lt;!--多项单选框类型--&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;enter&quot;&gt;&lt;/label&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot; id=&quot;enter&quot;/&gt;&lt;!--提交按钮类型--&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;reset&quot;&gt;&lt;/label&gt; &lt;input type=&quot;reset&quot; name=&quot;&quot; id=&quot;reset&quot;/&gt;&lt;!--重置按钮类型--&gt; &lt;/p&gt; &lt;p&gt; &lt;lable for=&quot;photo&quot;&gt;选一张帅照&lt;/lable&gt;&lt;!--选择找图片等文件类型--&gt; &lt;input type=&quot;file&quot; id=&quot;photo&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;textarea id=&quot;username&quot; cols=&quot;40&quot;/&gt;&lt;!--多行文本单个滑动框内显示--&gt; &lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 如何设置框中字数量：type为text和password时，用maxlength（最大长度）=”10”（即最大字符长度为10个）默认是无限大。 disabled和readonly：这两个属性需要的话直接加在input内，disabled是不可用，并且表单内容不提交，readonly表单内容会提交。 表单数据的提交的两种方式及其区别：1，method=”get”： ①数据提交不安全（数据内容显示在地址栏中） ②由于对于浏览器的url地址部分浏览器限制长度为255个字符，那么这样的话对于提交的数据而言就会有长度限制。 ③只能提交一些字符类型的数据（数字，字母，符号等字符）。 ④url可以存为书签，收藏。 ⑤请求可以有缓存。 2，method=”post”： ①数据安全提交（不显示在地址栏中）。 ②数据提交大小无上限。 ③url不可存为书签。 ④可以传输各种文件数据。 ⑤请求不允许缓存。 盒子模型盒子模型计算：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt;&lt;title&gt;无标题文档&lt;&#x2F;title&gt;&lt;style&gt; .box&#123; width:200px; height:200px; background-color:red; padding:50px; border:20px solid green; margin:50px; &#x2F;** 设置盒子模型的计算模式 1.content-box: 默认值 2.border-box *&#x2F; box-sizing:border-box; &#125; &#x2F;*** 盒子的尺寸: content-box: 盒子宽度 &#x3D; 内容宽度 + 左右两边的内边距 + 左右两边的边框. 盒子高度 &#x3D; 内容高度 + 上下两边的内边距 + 上下两边的边框. (实际中就是简化了计算的工作量)border-box: 盒子的尺寸按照css设置的宽高属性为准, 如果有内边距,边框,则会向内侧缩小展示. *&#x2F;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div class&#x3D;&quot;box&quot;&gt;啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 边框（四个方向）：1，border-style 边框样式（默认黑色）：solid dashed double dotted none(属性值); 2，border-color 边框颜色： border-color：transparent；透明框。 3，border-width 边框粗细（默认1px）： 4，border:1px solid #ccc; 简写例子 内边距和外边距：padding（内边距） padding:20px;四个方向同时为20px； padding:20px（上下） 30px（左右）; padding:20px（上） 30px（左右） 40px（下）； padding:20px（上） 30px（右） 40px （下）50px（左）；（顺时针） margin（外边距）{同内边距一样} 公用样式：12345678910111213141516171819202122232425/*除去浏览器默认样式*/*&#123; padding: 0; margin: 0;&#125;ul,li&#123; list-style: none;&#125;a&#123; text-decoration: none;&#125;.left&#123; float: left;&#125;.right&#123; float: right;&#125;html,body&#123; font-size: 12px; font-family: &quot;微软雅黑&quot;,&quot;Microsoft Yahei&quot;;&#125;.wrap&#123; width:; margin: 0 auto;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css *//* Document ========================================================================== *//** * 1. Correct the line height in all browsers. * 2. Prevent adjustments of font size after orientation changes in iOS. */html &#123; line-height: 1.15; /* 1 */ -webkit-text-size-adjust: 100%; /* 2 */&#125;/* Sections ========================================================================== *//** * Remove the margin in all browsers. */body &#123; margin: 0;&#125;/** * Render the `main` element consistently in IE. */main &#123; display: block;&#125;/** * Correct the font size and margin on `h1` elements within `section` and * `article` contexts in Chrome, Firefox, and Safari. */h1 &#123; font-size: 2em; margin: 0.67em 0;&#125;/* Grouping content ========================================================================== *//** * 1. Add the correct box sizing in Firefox. * 2. Show the overflow in Edge and IE. */hr &#123; box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */&#125;/** * 1. Correct the inheritance and scaling of font size in all browsers. * 2. Correct the odd `em` font sizing in all browsers. */pre &#123; font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */&#125;/* Text-level semantics ========================================================================== *//** * Remove the gray background on active links in IE 10. */a &#123; background-color: transparent;&#125;/** * 1. Remove the bottom border in Chrome 57- * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari. */abbr[title] &#123; border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */&#125;/** * Add the correct font weight in Chrome, Edge, and Safari. */b,strong &#123; font-weight: bolder;&#125;/** * 1. Correct the inheritance and scaling of font size in all browsers. * 2. Correct the odd `em` font sizing in all browsers. */code,kbd,samp &#123; font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */&#125;/** * Add the correct font size in all browsers. */small &#123; font-size: 80%;&#125;/** * Prevent `sub` and `sup` elements from affecting the line height in * all browsers. */sub,sup &#123; font-size: 75%; line-height: 0; position: relative; vertical-align: baseline;&#125;sub &#123; bottom: -0.25em;&#125;sup &#123; top: -0.5em;&#125;/* Embedded content ========================================================================== *//** * Remove the border on images inside links in IE 10. */img &#123; border-style: none;&#125;/* Forms ========================================================================== *//** * 1. Change the font styles in all browsers. * 2. Remove the margin in Firefox and Safari. */button,input,optgroup,select,textarea &#123; font-family: inherit; /* 1 */ font-size: 100%; /* 1 */ line-height: 1.15; /* 1 */ margin: 0; /* 2 */&#125;/** * Show the overflow in IE. * 1. Show the overflow in Edge. */button,input &#123; /* 1 */ overflow: visible;&#125;/** * Remove the inheritance of text transform in Edge, Firefox, and IE. * 1. Remove the inheritance of text transform in Firefox. */button,select &#123; /* 1 */ text-transform: none;&#125;/** * Correct the inability to style clickable types in iOS and Safari. */button,[type=&quot;button&quot;],[type=&quot;reset&quot;],[type=&quot;submit&quot;] &#123; -webkit-appearance: button;&#125;/** * Remove the inner border and padding in Firefox. */button::-moz-focus-inner,[type=&quot;button&quot;]::-moz-focus-inner,[type=&quot;reset&quot;]::-moz-focus-inner,[type=&quot;submit&quot;]::-moz-focus-inner &#123; border-style: none; padding: 0;&#125;/** * Restore the focus styles unset by the previous rule. */button:-moz-focusring,[type=&quot;button&quot;]:-moz-focusring,[type=&quot;reset&quot;]:-moz-focusring,[type=&quot;submit&quot;]:-moz-focusring &#123; outline: 1px dotted ButtonText;&#125;/** * Correct the padding in Firefox. */fieldset &#123; padding: 0.35em 0.75em 0.625em;&#125;/** * 1. Correct the text wrapping in Edge and IE. * 2. Correct the color inheritance from `fieldset` elements in IE. * 3. Remove the padding so developers are not caught out when they zero out * `fieldset` elements in all browsers. */legend &#123; box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */&#125;/** * Add the correct vertical alignment in Chrome, Firefox, and Opera. */progress &#123; vertical-align: baseline;&#125;/** * Remove the default vertical scrollbar in IE 10+. */textarea &#123; overflow: auto;&#125;/** * 1. Add the correct box sizing in IE 10. * 2. Remove the padding in IE 10. */[type=&quot;checkbox&quot;],[type=&quot;radio&quot;] &#123; box-sizing: border-box; /* 1 */ padding: 0; /* 2 */&#125;/** * Correct the cursor style of increment and decrement buttons in Chrome. */[type=&quot;number&quot;]::-webkit-inner-spin-button,[type=&quot;number&quot;]::-webkit-outer-spin-button &#123; height: auto;&#125;/** * 1. Correct the odd appearance in Chrome and Safari. * 2. Correct the outline style in Safari. */[type=&quot;search&quot;] &#123; -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */&#125;/** * Remove the inner padding in Chrome and Safari on macOS. */[type=&quot;search&quot;]::-webkit-search-decoration &#123; -webkit-appearance: none;&#125;/** * 1. Correct the inability to style clickable types in iOS and Safari. * 2. Change font properties to `inherit` in Safari. */::-webkit-file-upload-button &#123; -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */&#125;/* Interactive ========================================================================== *//* * Add the correct display in Edge, IE 10+, and Firefox. */details &#123; display: block;&#125;/* * Add the correct display in all browsers. */summary &#123; display: list-item;&#125;/* Misc ========================================================================== *//** * Add the correct display in IE 10+. */template &#123; display: none;&#125;/** * Add the correct display in IE 10. */[hidden] &#123; display: none;&#125; 改变元素显示方式（display）：none（不显示） inline（显示为行内元素） block（显示为块级元素） inline-block（显示为行内块级 具有行内元素的特性可以在一行显示，而且可以设置宽高属性） 浮动：float:值（left,right,none）常见网页布局种类：1，上下结构 2，上中下结构 3，上左右下结构（1-2-1结构） 4，上左中右下结构（1-3-1结构） 使用浮动的特性：1，会释放当前元素所占位置（布局层已经漂浮）。 2，使用浮动后两个元素间会紧密贴合在一起。 3，使用浮动后多个元素间顶部对齐。 4，使用浮动后元素会脱离标准文档流，形成块级框。 块级框：只要使用浮动，绝对定位，固定定位的元素，都会形成块级框1，盒子不占网页布局位置。 2，行内元素也可以设置宽高属性。 3，行内元素也可以设。 “坍塌”塌陷：当一个盒子中所有子元素都已经使用浮动后，那元素的高度将为0（盒子没有设置高度为前提）。 注意：网页布局，任何容器都应该有高度（可以是设置高度，也可以是由内容撑开的高度），如果没有高度，布局一定会出问题（重叠在一起）。 清除浮动带来的问题（解决坍塌等问题）。：1，手动设置容器高度.container{height:100px;} 2，使用clear属性清除浮动： ​ 具体实现：在使用浮动时的容器的末尾处追加一个空白的块级元素，设置css属性clear：both； （可适用于任何场景） 123456789101112&lt;html&gt; &lt;head&gt; &lt;style&gt; .clear&#123; clear:both; &#125; &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 3，使用overflow属性（visible 可见、hidden 隐藏、scroll 滚动条、auto 根据内容的多少设置出 溢出时会有滚动条比较合适）。 4，H5候补。 定位：position:left,right,top,buttom，static(默认值，没有定位)。相对定位 relative：12345p&#123; position:relative; top:-20px; left:90%;&#125; 相对定位的特性： 1，属于标准文档流，显示方式与原来没区别。 2，相对定位以自身原来位置进行偏移，不会对周边的元素造成影响。 3，一般情况下不会给相对定位的元素使用偏移，”贡献”属性它的实际用于给绝对定位做”嫁衣”。 4，一般用于一些容器（父级容器或者需要给绝对定位作参考的容器）。 绝对定位 absolute：12345678.container&#123; position:relative;&#125;.box&#123; position:absolute; top:-20px; left:90%;&#125; 1，使用绝对定位的元素释放自身的位置。 2，使用绝对定位的元素会形成”块级框”。 3，偏移以浏览器的边界作用参照（非固定）。 4，参照对象：如果使用绝对定位的元素，能够从它的祖先级元素中，找到一个已经使用定位的元素，则以一个最近 已经定位的祖先级，作为偏移的参照对象进行偏移，如果没有浏览器为参照对象偏移（默认）。 5，常见问题：经常会忽略参照元素的相对定位，导致元素布局混乱。 绝对定位的妙用：1234567891011121314151617181920212223242526&lt;html&gt; &lt;head&gt; &lt;title&gt;绝对定位的妙用&lt;&#x2F;title&gt; &lt;style&gt; *&#123; padding:0; margin:0; &#125; .box&#123; position:absolute; top:50%; left:50%; width:200px; height:200px; margin-top:-100px;&#x2F;*往回走自身高度的一半*&#x2F; margin_left:-100px;&#x2F;*往回走自身宽度的一半*&#x2F; background:red; &#125; &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class&#x3D;&quot;box&quot;&gt; 我是一个可以定位在网页正中间的盒子 &lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 固定定位 fixed：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt; /* 固定定位特性: 1.释放当前位置 ,形成&quot;块级框&quot; 2.固定在浏览器窗口的某个位置(不会跟随网页的滚动而变化) 四个方向偏移: left / right / top / bottom 单位: px / 百分比 (相对于父容器宽度的比例) */ .container&#123; position:relative; width:1000px; height:600px; margin:50px auto; border:1px solid red; &#125; .box&#123; position:fixed; top:0px; left:0px; width:200px; height:200px; background-color:green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;box&lt;/div&gt; &lt;p&gt;相对自身原来位置进行偏移!!!!!!!!!!!!!!!!!&lt;/p&gt; &lt;div style=&quot;height:3000px;background:linear-gradient(to bottom,red,green);&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1，释放当前位置，形成”块级框”。 2，固定定位浏览器的某个位置，向上下滑动对其位置无影响。 固定定位的妙用：给已知宽高度和未知宽高度的盒子进行绝对定位12345678910111213141516171819&lt;html&gt; &lt;head&gt; &lt;title&gt;固定定位的妙用（已知宽高的盒子）&lt;/title&gt; &lt;style&gt; .mask&#123; position:absolute; top:0; right:0; bottom:0; left:0; background:ragb(0,0,0,0.5)/*0.5代表透明度*/ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http:\\\\www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;div class=&quot;mask&quot;&gt;我会把百度覆盖&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 未知宽高度的元素水平垂直居中： 1，使用表格模式（IE8及以上兼容）。 2，使用css3位移（IE9及以上兼容）。 3，使用css3弹性盒子布局（IE10以上）。 4，详细步骤看电脑文件夹（E:\\老师的笔记拷贝版本\\01HTML网页制作基础\\07 定位）。 z-index属性：（只有使用定位的元素才有效）属性值：0,1,2,3（越大越在z轴上面） 拓展知识框线上加文字的简便方法：123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;框线上加文字&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;fieldset&gt; &lt;legend&gt; 我是框线上的文字。 &lt;&#x2F;legend&gt; &lt;&#x2F;fieldset&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[],"tags":[{"name":"html4","slug":"html4","permalink":"https://1314xulujin.github.io/tags/html4/"}]},{"title":"前端工程化","slug":"前端工程化","date":"2018-10-22T01:39:09.000Z","updated":"2022-08-14T08:37:19.408Z","comments":true,"path":"2018/10/22/前端工程化/","link":"","permalink":"https://1314xulujin.github.io/2018/10/22/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/","excerpt":"","text":"前端工程化 ​ 前端工程化是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间，而前端工程本质上是软件工程的一种，因此我们应该从软件工程的角度来研究前端工程。 工程化是为了规范前端工作流中的：模块化 ， 组件化，工作流规范 ，自动化 几个方向出发。 原生的javascript中是不支持模块化，所以很多时候需要借助一些第三方实现的工具来完成，就好比为了更好的编写样式同一，结构清晰，便利的css样式 ，我们会选用less去完成样式的编写，然后通过工具编译成浏览器支持的css. 自动化：就是解决那些曾经需要手动去完成的重复任务（工作） （自动化的意义） 工程化工具（常用）：12345代码版本控制（团队协作） ： git &#x2F; svn模块化工具：浏览器端：require.js &#x2F; sea.js 模块化规范：commonjs 、 AMDjs , CMDjs自动化构建（打包工具）： rollup &#x2F; grunt &#x2F; gulp &#x2F; webpack（当下最火） 使用Gulp (基于流的自动化构建工具 ， 任务的模式增强工作流) 安装 (需要全局安装 ， 当作是一个命令工具使用) ，使用的版本 ： 3.9.11cnpm install gulp@3.9.1 -g 安装成功： 使用 gulp -v 查看当前安装版本号 ，如果能正常输出，表示安装成功。 创建gulp任务清单入口1在项目的根目录下 ，创建一个 gulpfile.js 文件 （gulp默认从该文件进行处理，相当于一个任务的入口文件） 安装gulp提供的项目开发依赖包123gulp是开发工具，所以依赖包也应该是开发依赖 ,安装的时候需要记录为开发依赖，而非项目依赖cnpm install gulp@3.9.1 --save-dev ( --save-dev 也可以写成 -D) 注意：安装依赖的之前 先确认项目目录下是否有package.json 文件 （目前非必须）养成习惯。 使用gulp命令执行任务123gulp 命令 不带参数 ，默认就是执行 gulpfile中定义的 default任务带参数： gulp less 执行less任务 编写gulp任务1234567&#x2F;&#x2F;因为gulp 是基于任务的模式进行处理的，所以可以把一些需要自动完成的工作写成一个任务即可。const gulp &#x3D; require(&quot;gulp&quot;);&#x2F;&#x2F;引入gulp 的依赖&#x2F;&#x2F;创建任务 - defaultgulp.task(&quot;default&quot;,()&#x3D;&gt;&#123; console.log(&#39;正在执行gulp默认任务...&#39;);&#125;) 使用gulp编写一个less编译任务12345678910111213141516171819202122232425262728293031323334353637const gulp &#x3D; require(&quot;gulp&quot;);&#x2F;&#x2F;需要引入 gulp-less 工具中间件来处理less的文件流编译const less &#x3D; require(&quot;gulp-less&quot;);&#x2F;&#x2F;引入一个处理css补充兼容性前缀const autoprefixer &#x3D; require(&quot;gulp-autoprefixer&quot;);&#x2F;&#x2F;引入一个css压缩库const miniCss &#x3D; require(&quot;gulp-minify-css&quot;);&#x2F;&#x2F;引入生成sourcemap 映射文件库const sourcemaps &#x3D; require(&quot;gulp-sourcemaps&quot;);&#x2F;&#x2F;引入重命名库const rename &#x3D; require(&quot;gulp-rename&quot;);&#x2F;&#x2F;创建一个less编译的任务gulp.task(&quot;less&quot;,()&#x3D;&gt;&#123; &#x2F;&#x2F;读取文件流（读取需要编译的less文件） &#x2F;&#x2F; gulp.src(&quot;.&#x2F;src&#x2F;less&#x2F;index.less&quot;) &#x2F;&#x2F; gulp.src([&quot;.&#x2F;src&#x2F;less&#x2F;index.less&quot;,&quot;.&#x2F;src&#x2F;less&#x2F;reset.less&quot;]) gulp.src(&quot;.&#x2F;src&#x2F;less&#x2F;**&#x2F;*.less&quot;) .pipe(sourcemaps.init()) &#x2F;&#x2F;初始化映射 .pipe(less()) &#x2F;&#x2F;在流的中间添加一个处理less 的环节用于编译less .pipe(autoprefixer(&#123; &#x2F;&#x2F; browsers:[&quot;last 5 versions&quot;],&#x2F;&#x2F;配置需要考虑兼容的浏览器的版本信息 cascade:true,&#x2F;&#x2F;是否美化格式 &#125;)) .pipe(sourcemaps.write())&#x2F;&#x2F;写入map映射信息 .pipe(gulp.dest(&quot;.&#x2F;dist&#x2F;css&quot;))&#x2F;&#x2F;输出压缩之前的代码 .pipe(miniCss()) .pipe(rename(&#123; suffix:&#39;.min&#39; &#125;))&#x2F;&#x2F;修改输出文件名 ，补个min 表示压缩文件 .pipe(gulp.dest(&quot;.&#x2F;dist&#x2F;css&quot;)); &#x2F;&#x2F; gulp.dest() 将读取的文件流输出到指定的位置&#125;) 实现自动编译(Less)和刷新浏览器配置123456789101112131415161718192021222324252627282930313233const gulp = require(&quot;gulp&quot;);const less = require(&quot;gulp-less&quot;);const sourcemaps = require(&quot;gulp-sourcemaps&quot;);const autoprefixer = require(&quot;gulp-autoprefixer&quot;);const browserSync = require(&quot;browser-sync&quot;).create(); //创建一个http服务//定义一个默认任务gulp.task(&quot;default&quot;,[&#x27;less&#x27;,&#x27;http&#x27;],()=&gt;&#123; //默认任务开启对项目源代码文件的变化监听 let watcher = gulp.watch(&quot;./src/less/**/*.less&quot;,[&#x27;less&#x27;]); //监听dist目录文件变化实现浏览器刷新 gulp.watch(&quot;./dist/**/*&quot;).on(&quot;change&quot;,browserSync.reload);&#125;)//定义一个less任务 gulp.task(&quot;less&quot;,()=&gt;&#123; console.log(&#x27;正在编译less...&#x27;); gulp.src(&quot;./src/less/index.less&quot;) .pipe(sourcemaps.init()) .pipe(less()) .pipe(autoprefixer()) .pipe(sourcemaps.write()) .pipe(gulp.dest(&#x27;./dist/css&#x27;));&#125;)//定义一个http 静态资源服务器启动任务gulp.task(&quot;http&quot;,()=&gt;&#123; browserSync.init(&#123; server:&quot;./dist&quot; &#125;)&#125;) gulp工具中常用的包1234567891011121314gulp gulp命令基础的依赖包gulp-less 编译lessgulp-minify-css 压缩cssgulp-rename 输出文件重命名gulp-autoprefixer 自动补充浏览器兼容前缀gulp-sourcemaps 自动生成映射map文件browser-sync 搭建静态资源服务器和浏览器刷新gulp-uglify 压缩jsgulp-inject 用于将处理的文件直接插入到html文件中gulp-hash-name 将文件名修改成hashgulp-jadegulp-ejsgulp-clean 清空输出目录 使用项目根目录下的package.json文件1234567891011除了了一些基本的信息外： browserslist 字段 ： 可以用于标识当前项目需要考虑兼容的浏览器版本情况 scripts 字段 :用于配置一些cli命令脚本（实现简化每次执行的命令的长度） &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;npm run dev&quot;, &quot;dev&quot;:&quot;gulp --mode=development --port=3000&quot;, &quot;build&quot;:&quot;gulp --mode=production&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, 注意：要去执行dev中的脚本命令 ， 要使用 npm run dev , 如果是build 就是 npm run build其中有一个比较特殊的命令（固定的）start 内置的 ，可以直接 npm start 使用 ，其他的是自定义的，需要npm run dev 的方式使用。 使用npm自定义一个全局命令工具（类似于gulp , webpack一样的命令）123456789101112131415161718实现一个自动化部署的全局名： 作用就是将当前的项目打包后的代码部署到服务器（通过FTP传输）思路： 就是通过npm link 命令 将本地写好的功能映射为一个全局命令。1.新创建一个新的项目（命令工具）, 例如 ：npm init 初始化的时候将name设置为 （server-push 自定义的，后面会被用作命令的）【package.json 文件中的name 就是命令的名字】2.在当前项目根目录下，创建一个 bin 文件夹（命令工具执行的核心程序文件） index.js （当前文件需要在文件的开头第一行添加： #! &#x2F;usr&#x2F;bin&#x2F;evn node 指定当前的运行环境使用node）3.在package.json 文件中添加一个bin 字段 ，并且设置 为 bin&#x2F;index.js4.使用npm link 命令 将当前创建好的项目作为一个全局命令使用（链接全局）5.如果以上都完成即可使用全局命令 ( server-push ) 也能像gulp ， git , webpack一样的全局命令了执行的 bin&#x2F;index.js 文件：至于代码的上传 ，如果使用FTP ,则可以使用node包中的ftp模块（需要下载） ，跟着官方文档进行本地文件的传输即可。 Webpack 构建工具 中文官网： https://www.webpackjs.com/ ​ webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)*，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 *bundle。 webpack 就是node.js 开发出来的一个用于处理文件，对项目文件结构依赖关系进行打包处理的一个自动化工具。 安装123安装3.12.0 、 4.x 都可以 (3.x包含cli ， 4.x 需要单独安装webpack-cli)cnpm install webpack@3.12.0 -g 使用 webpack -v 检测是否安装成功。 入口： *入口起点(entry point)**指示 webpack 应该使用哪个模块，来作为构建其内部依赖图*的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 1234567891011项目结构： -config |-build.webpack.config.js -src |- main.js &#x3D;&gt; 项目的入口 -dist |- bundle.js &#x3D;&gt; webpack 根据入口的文件内容进行打包输出的内容 |- index.html &#x3D;&gt;构建好的html文件 -webpack.config.js &#x3D;&gt;webpack 默认的配置文件 123基本的打包命令： webpack .&#x2F;src&#x2F;main.js .&#x2F;dist&#x2F;bundle.js 解释： webpack 需要打包的入口文件地址[input] 打包后输出的文件地址[output] 为了方便使用（包含需要进行一些具体的配置指定项），一般会创建一个webpack的打包配置文件（webpack.config.js ， 类似于前面用过的gulpfile.js 文件）所以主要的学习webpack就是学习如何去编写webpack的配置文件。 默认情况下：执行webpack之后会自动在根目录搜索webpack.config.js 作为webpack工具的配置 ，可以修改。123456789101112修改webpack 默认使用的配置文件 ，其实只要在webpack 命令后添加 --config 参数指定配置文件的地址即可示例： webpack --config .&#x2F;config&#x2F;build.webpack.config.js 其实webpack后面还可以添加很多参数 ，为了方便每次不需要敲那么多参数，我们直接在package.json文件中添加scripts选项命令。&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;:&quot;webpack --config .&#x2F;config&#x2F;build.webpack.config.js&quot; &#125;, 如果收想要知道webpack命令 后面可以使用哪些参数：https:&#x2F;&#x2F;www.webpackjs.com&#x2F;api&#x2F;cli&#x2F; 常用的webpack命令参数: 参数 含义 –config 指定webpack 的配置文件地址 –env 当配置文件是一个函数时，会将环境变量传给这个函数 –mode 用到的模式，”development” 或 “production” 之中的一个 –progress 打包时显示进度 (true / false) –devtool 为打包好的资源定义 [source map 的类型] (sourcemap) –display-error-details 展示打包时错误的一些细节问题 （布尔值） –watch-aggregate-timeout 指定一个毫秒数，在这个时间内，文件若发送了多次变化，会被合并 –color 开启/关闭控制台的颜色 (布尔值) –display 选择显示预设(verbose - 繁琐, detailed - 细节, normal - 正常, minimal - 最小, errors-only - 仅错误, none - 无; 从 webpack 3.0.0 开始) webpack的常用配置：12345context:&#x2F;&#x2F;配置基础目录 绝对路径，用于从配置中解析入口起点(entry point)和 loaderenrty:配置项目的入口文件output：配置项目的输出（目录，文件名）module:配置项目模块中不同类型文件的解析处理（使用loader进行文件的解析）devServer: 配置本地开发测试的web服务环境 常用的loader:（执行顺序: 从下往上 ， 从右往左）1234567891011css-loader : 在js中将css样式文件，解析为js的模块 ，因为最终打包的一个js文件style-loader: 就是将解析过的css的模块 ，应用到网页样式（内部样式），会将css块的样式生成style标签应用样式less-loader:将less文件通过less包编译成css内容 （需要同时安装， less , less-loader）postcss-loader ： 处理css 可以配合 autoprefixer插件实现补充前缀file-loader :处理那些css文件或引入的图片资源文件转移（拷贝）url-loader : 功能与file-loader 类似，但是可以设置文件的大小 ，如果文件小于指定的大小，会直接转码成base64编码内容babel-loader &#x2F; @bable&#x2F;core 这一类就是处理 js 中es6 转 es5等功能 插件（Plugins）:1234567891011121314151617181920212223extract-text-webpack-plugin 插件负责将项目中内部样式抽离出一个单独的css文件 （目前支持webpack3.x）mini-css-extract-plugin(支持webpack4.x)html-webpack-plugin（生成html模板文件，会自动引入那些打包出来的css , js文件）clean-webpack-plugin 每次打包生成之前会先把原有的目录内容清空webpack-bundle-analyzer 这是一个打包文件bundle的 性能分析插件、MinChunkSizePlugin 合并一些小模块文件（减少http请求）CommonsChunkPlugin 提取公共模块LimitChunkCountPlugin 切割文件， 来实现文件的按需加载webpack-merge 提取公共webpack配置然后按环境合并DefinePlugin 在webpack库中内置的一个用于定义打包时全局变量的插件(在处理webpack时生成一个全局变量提供代码内部使用)friendly-errors-webpack-plugin 友好的错误提示（成功）portfinder 插件用于端口检测获取可用端口号 参考配置：1234567891011121314151617181920212223242526272829//生产环境的配置const path = require(&quot;path&quot;);module.exports = &#123; context: path.resolve(process.cwd(), &quot;src&quot;),//配置基础目录 绝对路径，用于从配置中解析入口起点(entry point)和 loader entry: &quot;./main.js&quot;,//单入口文件 output: &#123; path: path.resolve(process.cwd(), &quot;dist&quot;),//必须绝对路径 ， 打包静态资源输出的目录 filename: &quot;app.js&quot;,//指定打包的bundle的文件名称 // filename:&quot;[name].app.[hash].js&quot;,//[name]就是入口文件名 ，[id]模块标识符 ,[hash:5] 模块标识符的hash值 [chunkhash]编译模块内容的hash(文件内容变化才变化，不然都一样) hash值默认长度为20 ， [query] 模块的 query，例如，文件名? 后面的字符串 publicPath: &quot;./&quot;,//此选项指定在浏览器中所引用的静态资源的路径「此输出目录对应的公开 URL」 &#125;, module: &#123;//配置项目依赖中各个不同类型的文件模块，该使用什么样的loader去进行文件的解析处理 rules: [//具体的解析规则 &#123;//配置一个解析css样式文件的 loader test: /\\.css$/,//正则匹配文件名以.css结尾的文件，对于这些文件配置解析方式 // loader: &quot;style-loader!css-loader&quot;,//指定使用css-loader进行解析处理(loader的执行顺序就是从下往上， 从右往左) loader:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;] &#125;, &#123; test:/\\.less$/, loader:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;,&#x27;less-loader&#x27;] &#125; ] &#125;, plugins: [], resolve: &#123;&#125;&#125; webpack 构建优化：1.设置排除项（或者指定项的打包目录）减少构建时遍历文件目录 和打包时间12exclude: &#x2F;node_modules&#x2F; 排除不要的include:[] 指定需要打包编译的目录 2.通过webpack-merge 提取公共的webpack配置123webpack.base.config.js 公共webpack.dev.config.js 开发环境webpack.build.config.js 生产环境 3.打包切片（实现模块懒加载） ， 模块抽离1234567891011121314151617181920212223242526274.x 以后使用 webpack.config.js 中的配置项直接配置： optimization: &#123;//优化配置 splitChunks: &#123; chunks: &#x27;async&#x27;, minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: &#x27;~&#x27;, automaticNameMaxLength: 30, name: true, cacheGroups: &#123;//进一步详细配置切割规则 default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true, &#125;, vendors: &#123;//配置所有来自于node_modules中的模块全部打包到vendors中 test: /[\\\\/]node_modules[\\\\/]/, priority: 10, name: &quot;vendor&quot;, chunks: &quot;all&quot;, &#125; &#125; &#125; &#125;","categories":[],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"使用hexo简单的搭建博客","slug":"使用hexo简单的搭建博客","date":"2018-10-18T05:37:20.000Z","updated":"2020-06-21T13:10:21.338Z","comments":true,"path":"2018/10/18/使用hexo简单的搭建博客/","link":"","permalink":"https://1314xulujin.github.io/2018/10/18/%E4%BD%BF%E7%94%A8hexo%E7%AE%80%E5%8D%95%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"简单的利用hexo搭建博客1.安装需要的插件 安装node.js插件(https://nodejs.org)安装在默认路径 node -v验证安装Git工具(https://git-scm.com/downloads)安装在默认路径 2.打开git创建文件夹来搭建博客环境 mkdir（创建文件夹命令）cd （进入和退出到某路径） 创建一个boke/blog文件夹 3.安装hexo框架 首先安装个cnpm提高速度（npm install -g cnpm –registry=https://registry.npm.taobao.org）再用cnpm -来验证是否安装好了 然后安装hexo框架（cnpm install -g hexo-cli）安装hexo （hexo -v验证） 4.利用hexo框架开始搭建 1.hexo初始化（hexo init） 2.hexo创建 (hexo g) 3.第一次使用要在终端输入你的用户名和邮件 用户名输入命令:git config –global user.name “github用户名”邮件输入命令为:git config –global user.email “1599537548@qq.com“ 4.命令三连hexo clean , hexo g , hexo d; 5.配置_config.yml文件 1.安装部署插件服务器插件: npm install hexo-deployer-git –save 2.在_config.yml最底部 配置如下： deployer: type: gitrepo: 仓库地址branch :master","categories":[],"tags":[{"name":"hexo搭建博客","slug":"hexo搭建博客","permalink":"https://1314xulujin.github.io/tags/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}]}],"categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"软实力","slug":"软实力","permalink":"https://1314xulujin.github.io/tags/%E8%BD%AF%E5%AE%9E%E5%8A%9B/"},{"name":"面试题","slug":"面试题","permalink":"https://1314xulujin.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"其他","slug":"其他","permalink":"https://1314xulujin.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"java","slug":"java","permalink":"https://1314xulujin.github.io/tags/java/"},{"name":"vue","slug":"vue","permalink":"https://1314xulujin.github.io/tags/vue/"},{"name":"js","slug":"js","permalink":"https://1314xulujin.github.io/tags/js/"},{"name":"智扬信达","slug":"智扬信达","permalink":"https://1314xulujin.github.io/tags/%E6%99%BA%E6%89%AC%E4%BF%A1%E8%BE%BE/"},{"name":"冷知识","slug":"冷知识","permalink":"https://1314xulujin.github.io/tags/%E5%86%B7%E7%9F%A5%E8%AF%86/"},{"name":"前端面试题","slug":"前端面试题","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"教程","slug":"教程","permalink":"https://1314xulujin.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"本科考试科目","slug":"本科考试科目","permalink":"https://1314xulujin.github.io/tags/%E6%9C%AC%E7%A7%91%E8%80%83%E8%AF%95%E7%A7%91%E7%9B%AE/"},{"name":"软件设计模式","slug":"软件设计模式","permalink":"https://1314xulujin.github.io/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"跨域","slug":"跨域","permalink":"https://1314xulujin.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"webpack","slug":"webpack","permalink":"https://1314xulujin.github.io/tags/webpack/"},{"name":"window10","slug":"window10","permalink":"https://1314xulujin.github.io/tags/window10/"},{"name":"微信小程序UI框架","slug":"微信小程序UI框架","permalink":"https://1314xulujin.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FUI%E6%A1%86%E6%9E%B6/"},{"name":"git","slug":"git","permalink":"https://1314xulujin.github.io/tags/git/"},{"name":"ES6","slug":"ES6","permalink":"https://1314xulujin.github.io/tags/ES6/"},{"name":"Storage存储","slug":"Storage存储","permalink":"https://1314xulujin.github.io/tags/Storage%E5%AD%98%E5%82%A8/"},{"name":"BootStrap","slug":"BootStrap","permalink":"https://1314xulujin.github.io/tags/BootStrap/"},{"name":"HTML5+css3","slug":"HTML5-css3","permalink":"https://1314xulujin.github.io/tags/HTML5-css3/"},{"name":"BFC","slug":"BFC","permalink":"https://1314xulujin.github.io/tags/BFC/"},{"name":"函数柯里化","slug":"函数柯里化","permalink":"https://1314xulujin.github.io/tags/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"},{"name":"call和apply","slug":"call和apply","permalink":"https://1314xulujin.github.io/tags/call%E5%92%8Capply/"},{"name":"Web Worker","slug":"Web-Worker","permalink":"https://1314xulujin.github.io/tags/Web-Worker/"},{"name":"websocket","slug":"websocket","permalink":"https://1314xulujin.github.io/tags/websocket/"},{"name":"css3","slug":"css3","permalink":"https://1314xulujin.github.io/tags/css3/"},{"name":"ajax","slug":"ajax","permalink":"https://1314xulujin.github.io/tags/ajax/"},{"name":"OOP面向对象思想","slug":"OOP面向对象思想","permalink":"https://1314xulujin.github.io/tags/OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/"},{"name":"javascript","slug":"javascript","permalink":"https://1314xulujin.github.io/tags/javascript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://1314xulujin.github.io/tags/jQuery/"},{"name":"photoshop","slug":"photoshop","permalink":"https://1314xulujin.github.io/tags/photoshop/"},{"name":"html4","slug":"html4","permalink":"https://1314xulujin.github.io/tags/html4/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://1314xulujin.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"hexo搭建博客","slug":"hexo搭建博客","permalink":"https://1314xulujin.github.io/tags/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}]}